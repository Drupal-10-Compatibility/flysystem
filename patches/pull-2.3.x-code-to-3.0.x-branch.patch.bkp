diff --git a/README.md b/README.md
index 4c5b1f2..4fa0769 100644
--- a/README.md
+++ b/README.md
@@ -64,7 +64,7 @@ $schemes = [
       'cache' => TRUE, 
       ...
       // This will be treated similarly to Drupal's private file system
-      'root' => '/path/to/dir/outsite/drupal',
+      'root' => '/path/to/dir/outside/drupal',
       // Or,
       // In order fo the public setting to work, the path must be relative
       // to the root of the Drupal install.
@@ -81,17 +81,6 @@ $schemes = [
       // Note: Use as a replication endpoint does not prevent that endpoint from
       //   also being used for other purposes. 
       'replicate' => 'ftpexample',
-      // Serve Javascript or CSS via this stream wrapper. This is useful for
-      // adapters that function as CDNs like the S3 adapter.
-      //
-      // Note:  if you have configured multiple flysystem schemes, you can only
-      // configure one scheme to manage CSS and JS files.  If you do happen to
-      // configure multiple schemes, the last scheme defined with the following
-      // parameters will be the one actually used for storing and serving CSS and
-      // JS.  @see https://www.drupal.org/project/flysystem/issues/3056455
-      'serve_js' => TRUE, // Serve Javascript or CSS via this stream wrapper.
-      'serve_css' => TRUE, // This is useful for adapters that function as
-      // CDNs like the S3 adapter.
     ],
   // Used as a replication endpoint for 'local-example' (see the 'replicate'
   // option) but may still be used as a standalone endpoint.
@@ -118,6 +107,9 @@ $schemes = [
 // Don't forget this!
 $settings['flysystem'] = $schemes;
 ```
+## BREAKING CHANGES ##
+With 2.3.0-alpha1, we introduced backwards compatibility breaking changes.  The settings.php scheme configuration no longer includes code to store css / js on a Flysystem scheme.  Drupal 10.1 introduced the `assets://` scheme for css and js.  To utilize Flysystem for storing CSS and JS, you
+simply override Drupal Core's implementation of `assets://` to map it to a Flysystem storage mechanism just as you would for any other file asset.
 
 ## USAGE ##
 After configuring the endpoints, the default storage location may be changed on
@@ -141,6 +133,6 @@ This code in Drupal Core:
 
 - https://git.drupalcode.org/project/drupal/-/blob/fd92a54070af95150b3e2277b97b047b4df7f995/core/modules/image/src/Entity/ImageStyle.php#L284-295
 
-assumes that all read/write filewrappers will have image styles stored stored at the uri `wrapper://styles/{$imagestyle->id()}``. This is not always the case, particularly when modules create custom filewrappers such as this one. While this works most of the time, this could be a wrong assumption when the site needs to mount something like a FTP filesystem that just so happens to have a folder named "styles" and a subfolder with the image style id that contains things like CSS files or the like. This could result in irreparable file deletion.
+assumes that all read/write file wrappers will have image styles stored at the uri `wrapper://styles/{$style->id()}``. This is not always the case, particularly when modules create custom file wrappers such as this one. While this works most of the time, this could be a wrong assumption when the site needs to mount something like a FTP filesystem that just so happens to have a folder named "styles" and a subfolder with the image style id that contains things like CSS files or the like. This could result in irreparable file deletion.
 
 More information can be found documented at https://www.drupal.org/project/drupal/issues/3284521
diff --git a/config/schema/flysystem.schema.yml b/config/schema/flysystem.schema.yml
deleted file mode 100644
index 52c2840..0000000
--- a/config/schema/flysystem.schema.yml
+++ /dev/null
@@ -1,32 +0,0 @@
-flysystem.flysystem_adapter_config.*:
-  type: config_entity
-  label: flysystem_adapter_config
-  mapping:
-    id:
-      type: string
-      label: ID
-    label:
-      type: label
-      label: Label
-    uuid:
-      type: string
-    description:
-      type: string
-      label: 'Description'
-    status:
-      type: boolean
-      label: 'Status'
-    sub_adapter:
-      type: string
-      label: 'Adapter Plugin ID'
-    sub_adapter_config:
-      type: plugin.plugin_configuration.flysystem_adapter_config.[%parent.backend]
-    langcode:
-      type: string
-      label: 'Language code'
-    dependencies:
-      type: config_dependencies
-      label: 'Dependencies'
-
-plugin.plugin_configuration.flysystem_adapter_config.*:
-  type: mapping
diff --git a/flysystem.info.yml b/flysystem.info.yml
index 75c8ba4..bc45d17 100644
--- a/flysystem.info.yml
+++ b/flysystem.info.yml
@@ -1,7 +1,5 @@
 name: Flysystem
-type: module
 description: 'Provides access to various filesystem backends using Flysystem.'
 package: Flysystem
-core_version_requirement: ^10.3
-dependencies:
-  - drupal:field
+type: module
+core_version_requirement: ^11.0
diff --git a/flysystem.install b/flysystem.install
new file mode 100644
index 0000000..2f5b0d8
--- /dev/null
+++ b/flysystem.install
@@ -0,0 +1,92 @@
+<?php
+
+/**
+ * @file
+ * Install, update and uninstall functions for the flysystem module.
+ */
+
+use Drupal\Core\Site\Settings;
+use Drupal\flysystem\Logger\Convert;
+
+/**
+ * Implements hook_requirements().
+ */
+function flysystem_requirements($phase) {
+  $requirements = [];
+
+  __flysystem_validate_schemes($requirements);
+  __flysystem_check_dependencies($requirements);
+
+  if ($phase === 'runtime') {
+    __flysystem_call_ensure($requirements);
+  }
+
+  return $requirements;
+}
+
+/**
+ * Implements hook_install().
+ */
+function flysystem_install() {
+  Drupal::service('flysystem_factory')->ensure();
+}
+
+/**
+ * Validates configured schemes.
+ */
+function __flysystem_validate_schemes(array &$requirements) {
+  $invalid = [];
+  foreach (array_keys(Settings::get('flysystem', [])) as $scheme) {
+    if (!preg_match('/^[a-zA-Z0-9+.-]+$/', $scheme)) {
+      $invalid[] = $scheme;
+    }
+  }
+
+  if ($invalid) {
+    $requirements['flysystem_invalid_scheme'] = [
+      'title' => \Drupal::translation()->translate('Invalid Flysystem schemes in settings.php'),
+      'description' => \Drupal::translation()->translate("The following schemes are not in the correct format: %schemes. Scheme names can only contain letters, numbers, + (plus sign), . (period), - (hyphen).", ['%schemes' => implode(', ', $invalid)]),
+      'severity' => REQUIREMENT_ERROR,
+    ];
+  }
+}
+
+/**
+ * Checks that dependencies are installed.
+ */
+function __flysystem_check_dependencies(array &$requirements) {
+  $dependencies = [
+    'League\Flysystem\Filesystem' => \Drupal::translation()->translate('Flysystem'),
+    'League\Flysystem\Replicate\ReplicateAdapter' => \Drupal::translation()->translate('replicate adapter'),
+    'Codementality\FlysystemStreamWrapper' => \Drupal::translation()->translate('stream wrapper'),
+  ];
+
+  $missing = array_filter(array_map(function ($dependency) use ($dependencies) {
+    return class_exists($dependency) ? FALSE : $dependencies[$dependency];
+  }, array_keys($dependencies)));
+
+  // @codeCoverageIgnoreStart
+  if ($missing) {
+    $requirements['flysystem_dependencies'] = [
+      'title' => \Drupal::translation()->translate('Flysystem'),
+      'description' => \Drupal::translation()->translate('Dependencies missing: @deps.', ['@deps' => implode(', ', $missing)]),
+      'severity' => REQUIREMENT_ERROR,
+    ];
+  }
+  // @codeCoverageIgnoreEnd
+}
+
+/**
+ * Checks the state of existing configuration.
+ */
+function __flysystem_call_ensure(array &$requirements) {
+  foreach (\Drupal::service('flysystem_factory')->ensure() as $scheme => $errors) {
+    foreach ($errors as $error) {
+      $requirements['flysystem:' . $scheme] = [
+        'title' => \Drupal::translation()->translate('Flysystem: @scheme', ['@scheme' => $scheme]),
+        'description' => \Drupal::translation()->translate($error['message'], $error['context']),
+        'severity' => Convert::rfcToHookRequirements($error['severity']),
+      ];
+    }
+  }
+}
diff --git a/flysystem.links.action.yml b/flysystem.links.action.yml
index 0b396c0..68e1953 100644
--- a/flysystem.links.action.yml
+++ b/flysystem.links.action.yml
@@ -1,5 +1,5 @@
-entity.flysystem_adapter_config.add_form:
-  route_name: 'entity.flysystem_adapter_config.add_form'
-  title: 'Configure a Flysystem Adapter'
+flysystem.sync:
+  route_name: node.add_page
+  title: 'Add content'
   appears_on:
-    - entity.flysystem_adapter_config.collection
+    - system.admin_content
diff --git a/flysystem.links.menu.yml b/flysystem.links.menu.yml
index 8491e60..38140db 100644
--- a/flysystem.links.menu.yml
+++ b/flysystem.links.menu.yml
@@ -1,5 +1,5 @@
-entity.flysystem_adapter_config.overview:
-  title: Configured Flysystem Adapters
-  parent: system.admin_config_media
-  description: 'List of configured Flysystem Adapters.'
-  route_name: entity.flysystem_adapter_config.collection
+flysystem.config:
+  title: 'Flysystem'
+  description: 'Configure settings related to Flysystem.'
+  parent: system.file_system_settings
+  route_name: flysystem.config
diff --git a/flysystem.links.task.yml b/flysystem.links.task.yml
index a9386c2..9fd6508 100644
--- a/flysystem.links.task.yml
+++ b/flysystem.links.task.yml
@@ -1,9 +1,19 @@
 system.file_system_settings:
+  title: Settings
   route_name: system.file_system_settings
   base_route: system.file_system_settings
-  title: Settings
 
 flysystem.config:
+  title: Flysystem
   route_name: flysystem.config
   base_route: system.file_system_settings
-  title: Flysystem
+
+flysystem.sync:
+  title: 'Sync filesystems'
+  route_name: flysystem.config
+  parent_id: flysystem.config
+
+flysystem.migrate_field:
+  title: 'Field migration'
+  route_name: flysystem.migrate_field
+  parent_id: flysystem.config
diff --git a/flysystem.module b/flysystem.module
index da02359..e9fb943 100644
--- a/flysystem.module
+++ b/flysystem.module
@@ -8,21 +8,29 @@
 use Drupal\Core\Access\AccessResult;
 use Drupal\Core\Entity\EntityInterface;
 use Drupal\Core\Session\AccountInterface;
+use Drupal\Core\Site\Settings;
 use Drupal\Core\StreamWrapper\StreamWrapperManager;
 use Drupal\file\FileInterface;
 
+/**
+ * Implements hook_cron().
+ */
+function flysystem_cron() {
+  Drupal::service('flysystem_factory')->ensure();
+}
+
+/**
+ * Implements hook_rebuild().
+ */
+function flysystem_rebuild() {
+  Drupal::service('flysystem_factory')->ensure();
+}
+
 /**
  * Implements hook_file_download().
  */
 function flysystem_file_download($uri) {
-  $schemes = [];
-  $config_storage = \Drupal::service('config.storage');
-  $entity_config_names = $config_storage->listAll('flysystem.flysystem_adapter_config');
-  $configured_entities = $config_storage->readMultiple($entity_config_names);
-  foreach ($configured_entities as $value) {
-    $schemes[] = $value['id'];
-  }
-
+  $schemes = Drupal::service('flysystem_factory')->getSchemes();
   $scheme = StreamWrapperManager::getScheme($uri);
 
   if (!$scheme || !in_array($scheme, $schemes, TRUE)) {
@@ -34,7 +42,7 @@ function flysystem_file_download($uri) {
   }
 
   return [
-    'Content-Type' => \Drupal::service('file.mime_type.guesser.extension')->guessMimeType($uri),
+    'Content-Type' => Drupal::service('file.mime_type.guesser.extension')->guessMimeType($uri),
     'Content-Length' => filesize($uri),
   ];
 }
@@ -45,7 +53,6 @@ function flysystem_file_download($uri) {
  * @see Drupal\file\FileAccessControlHandler
  */
 function flysystem_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {
-  $schemes = [];
   if (!$entity instanceof FileInterface) {
     return AccessResult::neutral();
   }
@@ -54,18 +61,19 @@ function flysystem_entity_access(EntityInterface $entity, $operation, AccountInt
     return AccessResult::neutral();
   }
 
-  $config_storage = \Drupal::service('config.storage');
-  $entity_config_names = $config_storage->listAll('flysystem.flysystem_adapter_config');
-  $configured_entities = $config_storage->readMultiple($entity_config_names);
-  foreach ($configured_entities as $value) {
-    $schemes[] = $value['id'];
-  }
-
+  $schemes = Drupal::service('flysystem_factory')->getSchemes();
   $scheme = StreamWrapperManager::getScheme($entity->getFileUri());
+
   if (!$scheme || !in_array($scheme, $schemes, TRUE)) {
     return AccessResult::neutral();
   }
 
+  $settings = Settings::get('flysystem', []);
+
+  if (empty($settings[$scheme]['config']['public'])) {
+    return AccessResult::neutral();
+  }
+
   if ($operation === 'download') {
     return AccessResult::allowed();
   }
diff --git a/flysystem.permissions.yml b/flysystem.permissions.yml
index 101f4fb..fd3ff5a 100644
--- a/flysystem.permissions.yml
+++ b/flysystem.permissions.yml
@@ -1,4 +1,4 @@
-administer flysystem_adapter_config:
-  title: 'Manage configuration of Flysystem Adapters'
-  descriiption:  'Manage configuration of League/Flysystem Filesystem Adapters'
-  restricted: TRUE
+administer flysystem:
+  title: 'Administer Flysystem'
+  description: 'Sync Flysystem filesystems.'
+  restrict access: 'TRUE'
diff --git a/flysystem.post_update.php b/flysystem.post_update.php
new file mode 100644
index 0000000..0e0f34f
--- /dev/null
+++ b/flysystem.post_update.php
@@ -0,0 +1,13 @@
+<?php
+
+/**
+ * @file
+ * File with hook_post_update_name() functions for Flysystem.
+ */
+
+/**
+ * Implements hook_post_update_factory_ensure().
+ */
+function flysystem_post_update_factory_ensure() {
+  Drupal::service('flysystem_factory')->ensure();
+}
diff --git a/flysystem.routing.yml b/flysystem.routing.yml
index 0bb0d43..1587dea 100644
--- a/flysystem.routing.yml
+++ b/flysystem.routing.yml
@@ -1,31 +1,43 @@
-entity.flysystem_adapter_config.collection:
-  path: '/admin/config/media/flysystem-adapter-config'
+flysystem.files:
+  path: '/_flysystem/{scheme}'
   defaults:
-    _entity_list: 'flysystem_adapter_config'
-    _title: 'Configured Flysystem Adapters'
+    _controller: 'Drupal\system\FileDownloadController::download'
+    _disable_route_normalizer: TRUE
   requirements:
-    _permission: 'administer flysystem_adapter_config'
+    # Permissions are handled through Drupal file create / update permissions
+    _access: 'TRUE'
+    scheme: '^[a-zA-Z0-9+.-]+$'
+  options:
+    _maintenance_access: TRUE
 
-entity.flysystem_adapter_config.add_form:
-  path: '/admin/config/media/flysystem_adapter_config/add'
+flysystem.serve:
+  path: '/_flysystem/{scheme}/{filepath}'
   defaults:
-    _entity_form: 'flysystem_adapter_config.add'
-    _title: 'Configure a Flysystem Adapter'
+    _controller: 'Drupal\system\FileDownloadController::download'
+    _disable_route_normalizer: TRUE
   requirements:
-    _permission: 'administer flysystem_adapter_config'
+    # Permissions are handled through Drupal access content permissions
+    _access: 'TRUE'
+    scheme: '^[a-zA-Z0-9+.-]+$'
+    filepath: .+
+  options:
+    _maintenance_access: TRUE
 
-entity.flysystem_adapter_config.edit_form:
-  path: '/admin/config/media/flysystem-adapter-config/{flysystem_adapter_config}'
+flysystem.config:
+  path: '/admin/config/media/file-system/flysystem'
   defaults:
-    _entity_form: 'flysystem_adapter_config.edit'
-    _title: 'Modify configuration for a Flysystem Adapter'
+    _form: 'Drupal\flysystem\Form\ConfigForm'
+    _title: Flysystem
   requirements:
-    _permission: 'administer flysystem_adapter_config'
+    _permission: 'administer flysystem'
 
-entity.flysystem_adapter_config.delete_form:
-  path: '/admin/config/media/flysystem-adapter-config/{flysystem_adapter_config}/delete'
+flysystem.migrate_field:
+  path: '/admin/config/media/file-system/flysystem/field-migration'
   defaults:
-    _entity_form: 'flysystem_adapter_config.delete'
-    _title: 'Delete a configured Flysystem Adapter'
+    _form: 'Drupal\flysystem\Form\FieldMigration'
+    _title: 'Field migration'
   requirements:
-    _permission: 'administer flysystem_adapter_config'
+    _permission: 'administer flysystem'
+
+route_callbacks:
+  - 'Drupal\flysystem\Routing\FlysystemRoutes::routes'
diff --git a/flysystem.services.yml b/flysystem.services.yml
index 8066417..0890692 100644
--- a/flysystem.services.yml
+++ b/flysystem.services.yml
@@ -1,24 +1,41 @@
 services:
-  ## Service Decorators
-  # Decorates the Core FileSystem service
-  flysystem.filesystem:
-    class: Drupal\flysystem\Decorator\FlysystemDrupalFileSystem
-    public: false
-    decorates: file_system
-    decoration_priority: 1
-    arguments: ['@flysystem.filesystem.inner', '@stream_wrapper_manager', '@settings']
-
   cache.flysystem:
     class: Drupal\Core\Cache\CacheBackendInterface
     tags:
       - { name: cache.bin }
     factory: 'cache_factory:get'
-    arguments: ['flysystem']
+    arguments: [flysystem]
 
   logger.channel.flysystem:
     parent: logger.channel_base
     arguments: ['flysystem']
 
-  plugin.manager.flysystem_adapter:
-    class: Drupal\flysystem\FlysystemAdapterPluginManager
-    parent: default_plugin_manager
+  plugin.manager.flysystem:
+    class: Drupal\flysystem\Plugin\FlysystemPluginManager
+    arguments: ['@container.namespaces', '@cache.discovery', '@module_handler']
+
+  flysystem_factory:
+    class: Drupal\flysystem\FlysystemFactory
+    arguments: ['@plugin.manager.flysystem', '@stream_wrapper_manager', '@cache.flysystem', '@event_dispatcher']
+
+  path_processor.flysystem:
+    class: Drupal\flysystem\PathProcessor\FlysystemPathProcessor
+    tags:
+      - { name: path_processor_inbound, priority: 200 }
+
+  flysystem.ensure_subscriber:
+    class: Drupal\flysystem\EventSubscriber\EnsureSubscriber
+    arguments: ['@logger.channel.flysystem']
+    tags:
+      - { name: event_subscriber }
+
+  flysystem.image_style_copier:
+    class: Drupal\flysystem\ImageStyleCopier
+    arguments: ['@lock', '@file_system', '@logger.channel.image', '@entity_type.manager', '@cache_tags.invalidator']
+    tags:
+      - { name: event_subscriber }
+
+  path_processor.flysystem_redirect:
+    class: Drupal\flysystem\PathProcessor\FlysystemImageStyleRedirectProcessor
+    tags:
+      - { name: path_processor_inbound, priority: 400 }
diff --git a/modules/flysystem_local/config/schema/flysystem_local.adapter.schema.yml b/modules/flysystem_local/config/schema/flysystem_local.adapter.schema.yml
deleted file mode 100644
index cf48f4e..0000000
--- a/modules/flysystem_local/config/schema/flysystem_local.adapter.schema.yml
+++ /dev/null
@@ -1,28 +0,0 @@
-plugin.plugin_configuration.flysystem_adapter_config.flysystem_local:
-  type: mapping
-  label: 'Flysystem Local Filesystem settings'
-  mapping:
-    root_directory:
-      type: 'string'
-      label: 'File Storage directory, relative to Drupal root'
-    permissions:
-      file:
-        public:
-          type: integer
-          label: 'Public file permissions'
-        private:
-          type: integer
-          label: 'Private file permissions'
-      dir:
-        public:
-          type: integer
-          label: 'Public directory permissions'
-        private:
-          type: integer
-          label: 'Private directory permissions'
-    write_flags:
-      type: integer
-      label: 'Write flags'
-    link_handling:
-      type: integer
-      label: 'Links handling (disallow or skip)'
diff --git a/modules/flysystem_local/flysystem_local.info.yml b/modules/flysystem_local/flysystem_local.info.yml
deleted file mode 100644
index 2451230..0000000
--- a/modules/flysystem_local/flysystem_local.info.yml
+++ /dev/null
@@ -1,7 +0,0 @@
-name: 'Flysystem Local Filesytem Adapter'
-type: module
-description: 'Flysystem Local Filesystem Adapter.'
-package: 'Flysystem'
-core_version_requirement: ^10
-dependencies:
-  - flysystem:flysystem
diff --git a/modules/flysystem_local/src/Plugin/FlysystemAdapter/LocalAdapter.php b/modules/flysystem_local/src/Plugin/FlysystemAdapter/LocalAdapter.php
deleted file mode 100644
index d1ae706..0000000
--- a/modules/flysystem_local/src/Plugin/FlysystemAdapter/LocalAdapter.php
+++ /dev/null
@@ -1,163 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem_local\Plugin\FlysystemAdapter;
-
-use Drupal\Core\Form\FormStateInterface;
-use Drupal\flysystem\FlysystemSubAdapterInterface;
-use Drupal\flysystem\Plugin\FlysystemAdapterPluginBase;
-use Drupal\flysystem\Plugin\FlysystemAdapterPluginTrait;
-use League\Flysystem\Local\LocalFilesystemAdapter;
-
-/**
- * Plugin implementation of the flysystem_adapter.
- *
- * @FlysystemAdapter(
- *   id = "local_adapter",
- *   label = @Translation("Local Adapter"),
- *   description = @Translation("Flysystem Local Adapter.")
- * )
- */
-final class LocalAdapter extends FlysystemAdapterPluginBase implements FlysystemSubAdapterInterface {
-
-  use FlysystemAdapterPluginTrait;
-
-  /**
-   * The flysystem_subadapter ID.
-   */
-  protected string $id;
-
-  /**
-   * The flysystem_subadapter label.
-   */
-  protected string $label;
-
-  /**
-   * The flysystem_subadapter description.
-   */
-  protected string $description;
-
-  /**
-   * Default permissions array.
-   */
-  protected array $defaultPermissions = [
-    'file' => [
-      'public' => '0664',
-      'private' => '0664',
-    ],
-    'dir' => [
-      'public' => '0775',
-      'private' => '0775',
-    ],
-  ];
-
-  /**
-   * The League\Flysystem\FilesytemAdapter class for this adapter.
-   */
-  static protected string $flysystemAdapterClass = 'League\Flysystem\Local\LocalFilesystemAdapter';
-
-  /**
-   * The fully qualified name of this class.
-   */
-  protected string $pluginAdapterClass = __CLASS__;
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getDescription() {
-    return !empty($this->description) ? $this->description : '';
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function buildSubConfigurationForm(array &$form, FormStateInterface $form_state, $flysystem_adapter_config) {
-    $defaultPermissions = $this->getDefaultPermissions();
-    $form['root_directory'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('File Storage Location'),
-      '#maxlength' => 255,
-      '#description' => $this->t('File Storage directory, relative to Drupal root.'),
-      // @todo determine how to retrieve saved values once form is saved.
-      '#default_value' => $flysystem_adapter_config->getSubAdapterConfigItem('root_directory'),
-      '#required' => TRUE,
-    ];
-    $form['permissions']['file']['public'] = [
-      '#type' => 'number',
-      '#title' => $this->t('Public file permissions'),
-      '#description' => $this->t('Default permissions for public files.'),
-      // @todo determine how to retrieve saved values once form is saved.
-      '#default_value' => $flysystem_adapter_config->getSubAdapterConfigItem(['permissions', 'file', 'public']) ?? $defaultPermissions['file']['public'],
-    ];
-    $form['permissions']['file']['private'] = [
-      '#type' => 'number',
-      '#title' => $this->t('Private file permissions'),
-      '#description' => $this->t('Default permissions for private files.'),
-      // @todo determine how to retrieve saved values once form is saved.
-      '#default_value' => $flysystem_adapter_config->getSubAdapterConfigItem(['permissions', 'file', 'private']) ?? $defaultPermissions['file']['private'],
-    ];
-    $form['permissions']['dir']['public'] = [
-      '#type' => 'number',
-      '#title' => $this->t('Public directory permissions'),
-      '#description' => $this->t('Default permissions for public directories.'),
-      // @todo determine how to retrieve saved values once form is saved.
-      '#default_value' => $flysystem_adapter_config->getSubAdapterConfigItem(['permissions', 'dir', 'public']) ?? $defaultPermissions['dir']['public'],
-    ];
-    $form['permissions']['dir']['private'] = [
-      '#type' => 'number',
-      '#title' => $this->t('Private directory permissions'),
-      '#description' => $this->t('Default permissions for private directories.'),
-      // @todo determine how to retrieve saved values once form is saved.
-      '#default_value' => $flysystem_adapter_config->getSubAdapterConfigItem(['permissions', 'dir', 'private']) ?? $defaultPermissions['dir']['private'],
-    ];
-    $form['write_flags'] = [
-      '#type' => 'hidden',
-      '#title' => $this->t('Write flags'),
-      // @todo convert to proper translated entity.
-      '#description' => $this->t('Lock types for file resources, reference <a href="https://www.php.net/manual/en/function.flock.php#:~:text=operation-,operation,-is%20one%20of">PHP file locking operations</a> for more information.'),
-      // @todo determine how to retrieve saved values once form is saved.
-      '#default_value' => (strlen($flysystem_adapter_config->getSubAdapterConfigItem('write_flag')) == 0) ? LOCK_EX : NULL,
-    ];
-    $form['link_handling'] = [
-      '#type' => 'hidden',
-      '#title' => $this->t('Link handler flags'),
-      // @todo convert to proper translated entity.
-      '#description' => $this->t('How to handle links, reference <a href="https://flysystem.thephpleague.com/docs/adapter/local/">Local File Adatper, advanced usage</a> for more information.'),
-      // @todo determine how to retrieve saved values once form is saved.
-      '#default_value' => (strlen($flysystem_adapter_config->getSubAdapterConfigItem('link_handling')) == 0) ? LocalFilesystemAdapter::DISALLOW_LINKS : NULL,
-    ];
-
-    $form['flysystem_adapter_class'] = [
-      '#type' => 'hidden',
-      '#title' => $this->t('Flysystem Adapter Class'),
-      '#default_value' => self::getFlysystemAdapterClass(),
-    ];
-
-    $form['plugin_adapter_class'] = [
-      '#type' => 'hidden',
-      '#title' => $this->t('Drupal Flysystem Plugin Adapter Class'),
-      '#default_value' => __CLASS__ . "Utility",
-    ];
-
-    return $form;
-  }
-
-  /**
-   * Return Flysystem Adapter class name.
-   *
-   * @return string
-   *   Fully qualified class name for \League\Flysystem\FilesystemAdapter
-   */
-  public static function getFlysystemAdapterClass() {
-    return self::$flysystemAdapterClass;
-  }
-
-  /**
-   * Returns a configured Flysystem FilesystemAdapter.
-   */
-  public static function configureFlysystemAdapter(array $configure_entity) {
-
-  }
-
-}
diff --git a/modules/flysystem_local/src/Plugin/FlysystemAdapter/LocalAdapterUtility.php b/modules/flysystem_local/src/Plugin/FlysystemAdapter/LocalAdapterUtility.php
deleted file mode 100644
index 51f22ff..0000000
--- a/modules/flysystem_local/src/Plugin/FlysystemAdapter/LocalAdapterUtility.php
+++ /dev/null
@@ -1,50 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem_local\Plugin\FlysystemAdapter;
-
-use League\Flysystem\Local\LocalFilesystemAdapter;
-use League\Flysystem\UnixVisibility\PortableVisibilityConverter;
-
-/**
- * Local Adapter factory class.
- */
-class LocalAdapterUtility {
-
-  /**
-   * Configures the designated adapter.
-   *
-   * @param array $sub_adapter_config
-   *   The sub adapter config item for this adapter config.
-   *
-   * @return array
-   *   Array containing configured adapter and configuration options array.
-   */
-  public static function create($sub_adapter_config) {
-    $options = [];
-    $visibilityArray = [
-      'file' => [
-        'public' => (int) $sub_adapter_config['permissions']['file']['public'],
-        'private' => (int) $sub_adapter_config['permissions']['file']['private'],
-      ],
-      'dir' => [
-        'public' => (int) $sub_adapter_config['permissions']['dir']['public'],
-        'private' => (int) $sub_adapter_config['permissions']['dir']['private'],
-      ],
-    ];
-    // Set to converter, or set to NULL if not supported.
-    // @see https://flysystem.thephpleague.com/docs/ for information on configuring adapters.
-    $visibility = PortableVisibilityConverter::fromArray($visibilityArray);
-    $link_handling = strlen($sub_adapter_config['link_handling']) == 0 ? LocalFilesystemAdapter::DISALLOW_LINKS : LocalFilesystemAdapter::SKIP_LINKS;
-    $adapter = new LocalFilesystemAdapter(
-      $sub_adapter_config['root_directory'],
-      $visibility,
-      (int) $sub_adapter_config['write_flags'],
-      $link_handling,
-    );
-    $options['visibility'] = $visibility;
-    return ['adapter' => $adapter, 'options' => $options];
-  }
-
-}
diff --git a/src/Annotation/Adapter.php b/src/Annotation/Adapter.php
new file mode 100644
index 0000000..bb11485
--- /dev/null
+++ b/src/Annotation/Adapter.php
@@ -0,0 +1,34 @@
+<?php
+
+namespace Drupal\flysystem\Annotation;
+
+use Drupal\Component\Annotation\Plugin;
+
+/**
+ * Defines a Flysystem adapter plugin.
+ *
+ * Plugin Namespace: Flysystem.
+ *
+ * For a working example, see \Drupal\flysystem\Flysystem\Local.
+ *
+ * @see plugin_api
+ *
+ * @Annotation
+ */
+class Adapter extends Plugin {
+
+  /**
+   * The plugin ID.
+   *
+   * @var string
+   */
+  public $id;
+
+  /**
+   * A list of extension dependencies.
+   *
+   * @var string[]
+   */
+  public $extensions = [];
+
+}
diff --git a/src/Annotation/FlysystemAdapter.php b/src/Annotation/FlysystemAdapter.php
deleted file mode 100644
index dce4d7a..0000000
--- a/src/Annotation/FlysystemAdapter.php
+++ /dev/null
@@ -1,35 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem\Annotation;
-
-use Drupal\Component\Annotation\Plugin;
-
-/**
- * Defines flysystem_adapter annotation object.
- *
- * @Annotation
- */
-final class FlysystemAdapter extends Plugin {
-
-  /**
-   * The plugin ID.
-   */
-  public string $id;
-
-  /**
-   * The human-readable name of the plugin.
-   *
-   * @ingroup plugin_translatable
-   */
-  public string $title;
-
-  /**
-   * The description of the plugin.
-   *
-   * @ingroup plugin_translatable
-   */
-  public string $description;
-
-}
diff --git a/src/Asset/SchemeExtensionTrait.php b/src/Asset/SchemeExtensionTrait.php
deleted file mode 100644
index f971bcb..0000000
--- a/src/Asset/SchemeExtensionTrait.php
+++ /dev/null
@@ -1,35 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\Asset;
-
-use Drupal\Core\Site\Settings;
-
-/**
- * Flysystem dependency injection container.
- */
-trait SchemeExtensionTrait {
-
-  /**
-   * Returns the scheme that should serve an extension.
-   *
-   * @param string $extension
-   *   The extension.
-   *
-   * @return string
-   *   The scheme that should serve the extension.
-   */
-  public function getSchemeForExtension($extension) {
-
-    $extension_scheme = 'public';
-
-    foreach (Settings::get('flysystem', []) as $scheme => $configuration) {
-      if (!empty($configuration['serve_' . $extension]) && !empty($configuration['driver'])) {
-        // Don't break, the last configured one will win.
-        $extension_scheme = $scheme;
-      }
-    }
-
-    return $extension_scheme;
-  }
-
-}
diff --git a/src/Controller/ImageStyleDownloadController.php b/src/Controller/ImageStyleDownloadController.php
new file mode 100644
index 0000000..f8cfa73
--- /dev/null
+++ b/src/Controller/ImageStyleDownloadController.php
@@ -0,0 +1,255 @@
+<?php
+
+namespace Drupal\flysystem\Controller;
+
+use Drupal\Component\Utility\Crypt;
+use Drupal\image\ImageStyleInterface;
+use Drupal\system\FileDownloadController;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+use Symfony\Component\HttpFoundation\BinaryFileResponse;
+use Symfony\Component\HttpFoundation\File\Exception\FileNotFoundException;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
+use Symfony\Component\HttpKernel\Exception\ServiceUnavailableHttpException;
+
+/**
+ * Defines a controller to serve image styles.
+ */
+class ImageStyleDownloadController extends FileDownloadController {
+
+  /**
+   * The lock backend.
+   *
+   * @var \Drupal\Core\Lock\LockBackendInterface
+   */
+  protected $lock;
+
+  /**
+   * The image factory.
+   *
+   * @var \Drupal\Core\Image\ImageFactory
+   */
+  protected $imageFactory;
+
+  /**
+   * A logger instance.
+   *
+   * @var \Psr\Log\LoggerInterface
+   */
+  protected $logger;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container) {
+    $instance = new static($container->get('stream_wrapper_manager'));
+    $instance->lock = $container->get('lock');
+    $instance->imageFactory = $container->get('image.factory');
+    $instance->logger = $container->get('logger.channel.image');
+
+    return $instance;
+  }
+
+  /**
+   * Generates a derivative, given a style and image path.
+   *
+   * After generating an image, transfer it to the requesting agent.
+   *
+   * @param \Symfony\Component\HttpFoundation\Request $request
+   *   The request object.
+   * @param string $scheme
+   *   The file scheme, defaults to 'private'.
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style to deliver.
+   *
+   * @return \Symfony\Component\HttpFoundation\BinaryFileResponse|\Symfony\Component\HttpFoundation\Response
+   *   The transferred file as response or some error response.
+   *
+   * @throws \Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException
+   *   Thrown when the user does not have access to the file.
+   * @throws \Symfony\Component\HttpKernel\Exception\ServiceUnavailableHttpException
+   *   Thrown when the file is still being generated.
+   */
+  public function deliver(Request $request, $scheme, ImageStyleInterface $image_style) {
+    $target = $request->query->get('file');
+    $image_uri = $scheme . '://' . $target;
+
+    $this->validateRequest($request, $image_style, $scheme, $target);
+
+    $derivative_uri = $image_style->buildUri($image_uri);
+    $headers = [];
+
+    // If using the private scheme, let other modules provide headers and
+    // control access to the file.
+    if ($scheme == 'private') {
+      if (file_exists($derivative_uri)) {
+        return parent::download($request, $scheme);
+      }
+      else {
+        $headers = $this->moduleHandler()->invokeAll('file_download', [$image_uri]);
+        if (in_array(-1, $headers) || empty($headers)) {
+          throw new AccessDeniedHttpException();
+        }
+      }
+    }
+
+    // Don't try to generate file if source is missing.
+    try {
+      $image_uri = $this->validateSource($image_uri);
+    }
+    catch (FileNotFoundException $e) {
+      $this->logger->notice('Source image at %source_image_path not found while trying to generate derivative image at %derivative_path.', [
+        '%source_image_path' => $image_uri,
+        '%derivative_path' => $derivative_uri,
+      ]);
+      return new Response($this->t('Error generating image, missing source file.'), 404);
+    }
+
+    $success = $this->generate($image_style, $image_uri, $derivative_uri);
+
+    if ($success) {
+      return $this->send($scheme, $derivative_uri, $headers);
+    }
+    else {
+      $this->logger->notice('Unable to generate the derived image located at %path.', ['%path' => $derivative_uri]);
+      return new Response($this->t('Error generating image.'), 500);
+    }
+  }
+
+  /**
+   * Validate that a source image exists, checking for double extensions.
+   *
+   * If the image style converted the extension, it has been added to the
+   * original file, resulting in filenames like image.png.jpeg. So to find
+   * the actual source image, we remove the extension and check if that
+   * image exists.
+   *
+   * @param string $image_uri
+   *   The URI to the source image.
+   *
+   * @return string
+   *   The original $image_uri, or the source with the original extension.
+   *
+   * @throws \Symfony\Component\HttpFoundation\File\Exception\FileNotFoundException
+   *   Thrown when no valid source image is found.
+   */
+  protected function validateSource($image_uri) {
+    if (!file_exists($image_uri)) {
+      $path_info = pathinfo($image_uri);
+      $converted_image_uri = $path_info['dirname'] . DIRECTORY_SEPARATOR . $path_info['filename'];
+      if (!file_exists($converted_image_uri)) {
+        throw new FileNotFoundException($converted_image_uri);
+      }
+      // The converted file does exist, use it as the source.
+      return $converted_image_uri;
+    }
+
+    return $image_uri;
+  }
+
+  /**
+   * Return a response of the derived image.
+   *
+   * @param string $scheme
+   *   The URI scheme of $derivative_uri.
+   * @param string $derivative_uri
+   *   The URI of the derived image.
+   * @param array $headers
+   *   (optional) An array of headers to return in the response.
+   *
+   * @return \Symfony\Component\HttpFoundation\BinaryFileResponse
+   *   A response with the derived image.
+   */
+  protected function send($scheme, $derivative_uri, $headers = []) {
+    $image = $this->imageFactory->get($derivative_uri);
+    $uri = $image->getSource();
+    $headers += [
+      'Content-Type' => $image->getMimeType(),
+      'Content-Length' => $image->getFileSize(),
+    ];
+    // \Drupal\Core\EventSubscriber\FinishResponseSubscriber::onRespond()
+    // sets response as not cacheable if the Cache-Control header is not
+    // already modified. We pass in FALSE for non-private schemes for the
+    // $public parameter to make sure we don't change the headers.
+    return new BinaryFileResponse($uri, 200, $headers, $scheme !== 'private');
+  }
+
+  /**
+   * Generate an image derivative.
+   *
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style to use for the derivative.
+   * @param string $image_uri
+   *   The URI of the original image.
+   * @param string $derivative_uri
+   *   The URI of the derived image.
+   *
+   * @return bool
+   *   TRUE if the image exists or was generated, FALSE otherwise.
+   */
+  protected function generate(ImageStyleInterface $image_style, $image_uri, $derivative_uri) {
+    // Don't start generating the image if the derivative already exists or if
+    // generation is in progress in another thread.
+    $lock_name = 'image_style_deliver:' . $image_style->id() . ':' . Crypt::hashBase64($image_uri);
+    if (!file_exists($derivative_uri)) {
+      $lock_acquired = $this->lock->acquire($lock_name);
+      if (!$lock_acquired) {
+        // Tell client to retry again in 3 seconds. Currently no browsers are
+        // known to support Retry-After.
+        throw new ServiceUnavailableHttpException(3, 'Image generation in progress. Try again shortly.');
+      }
+    }
+
+    // Try to generate the image, unless another thread just did it while we
+    // were acquiring the lock.
+    $success = file_exists($derivative_uri) || $image_style->createDerivative($image_uri, $derivative_uri);
+
+    if (!empty($lock_acquired)) {
+      $this->lock->release($lock_name);
+    }
+
+    return $success;
+  }
+
+  /**
+   * Validate an incoming derivative request.
+   *
+   * Check that the style is defined, the scheme is valid, and the image
+   * derivative token is valid. Sites which require image derivatives to be
+   * generated without a token can set the
+   * 'image.settings:allow_insecure_derivatives' configuration to TRUE to
+   * bypass the latter check, but this will increase the site's vulnerability
+   * to denial-of-service attacks. To prevent this variable from leaving the
+   * site vulnerable to the most serious attacks, a token is always required
+   * when a derivative of a style is requested.
+   * The $target variable for a derivative of a style has
+   * styles/<style_name>/... as structure, so we check if the $target variable
+   * starts with styles/.
+   *
+   * @param \Symfony\Component\HttpFoundation\Request $request
+   *   The incoming derivative request.
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style to use for the derivative.
+   * @param string $scheme
+   *   The URI scheme of $target.
+   * @param string $target
+   *   The path for the generated derivative.
+   *
+   * @throws \Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException
+   *   Thrown when the image style, the scheme, or the path token is invalid.
+   */
+  protected function validateRequest(Request $request, ImageStyleInterface $image_style, $scheme, $target) {
+    $valid = $this->streamWrapperManager->isValidScheme($scheme);
+    $image_uri = $scheme . '://' . $target;
+    if (!$this->config('image.settings')
+      ->get('allow_insecure_derivatives') || strpos(ltrim($target, '\/'), 'styles/') === 0
+    ) {
+      $valid &= $request->query->get(IMAGE_DERIVATIVE_TOKEN) === $image_style->getPathToken($image_uri);
+    }
+    if (!$valid) {
+      throw new AccessDeniedHttpException();
+    }
+  }
+
+}
diff --git a/src/Controller/ImageStyleRedirectController.php b/src/Controller/ImageStyleRedirectController.php
new file mode 100644
index 0000000..4afeea1
--- /dev/null
+++ b/src/Controller/ImageStyleRedirectController.php
@@ -0,0 +1,296 @@
+<?php
+
+namespace Drupal\flysystem\Controller;
+
+use Drupal\Core\Render\RenderContext;
+use Drupal\Core\Routing\TrustedRedirectResponse;
+use Drupal\Core\Url;
+use Drupal\image\ImageStyleInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+use Symfony\Component\HttpFoundation\BinaryFileResponse;
+use Symfony\Component\HttpFoundation\File\Exception\FileNotFoundException;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpFoundation\Response;
+use Symfony\Component\HttpKernel\Exception\ServiceUnavailableHttpException;
+
+/**
+ * Defines an image style controller that serves from temporary, then redirects.
+ */
+class ImageStyleRedirectController extends ImageStyleDownloadController {
+
+  /**
+   * The file entity storage.
+   *
+   * @var \Drupal\Core\Entity\EntityStorageInterface
+   */
+  protected $fileStorage;
+
+  /**
+   * The file system.
+   *
+   * @var \Drupal\Core\File\FileSystemInterface
+   */
+  protected $fileSystem;
+
+  /**
+   * The renderer.
+   *
+   * @var \Drupal\Core\Render\RendererInterface
+   */
+  protected $renderer;
+
+  /**
+   * The image style copier.
+   *
+   * @var \Drupal\flysystem\ImageStyleCopier
+   */
+  protected $imageStyleCopier;
+
+  /**
+   * The mime type guesser.
+   *
+   * @var \Symfony\Component\Mime\MimeTypeGuesserInterface
+   */
+  protected $mimeTypeGuesser;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container) {
+    $instance = parent::create($container);
+    $instance->fileStorage = $container->get('entity_type.manager')->getStorage('file');
+    $instance->fileSystem = $container->get('file_system');
+    $instance->renderer = $container->get('renderer');
+    $instance->imageStyleCopier = $container->get('flysystem.image_style_copier');
+    $instance->mimeTypeGuesser = $container->get('file.mime_type.guesser');
+
+    return $instance;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deliver(Request $request, $scheme, ImageStyleInterface $image_style) {
+    $target = $request->query->get('file');
+    $source_uri = $scheme . '://' . $target;
+
+    $this->validateRequest($request, $image_style, $scheme, $target);
+
+    // Don't try to generate file if source is missing.
+    try {
+      $source_uri = $this->validateSource($source_uri);
+    }
+    catch (FileNotFoundException $e) {
+      $derivative_uri = $image_style->buildUri($source_uri);
+      $this->logger->notice('Source image at %source_image_path not found while trying to generate derivative image at %derivative_path.', [
+        '%source_image_path' => $source_uri,
+        '%derivative_path' => $derivative_uri,
+      ]);
+      return new Response($this->t('Error generating image, missing source file.'), 404);
+    }
+
+    // If the image already exists on the adapter, deliver it instead.
+    try {
+      return $this->redirectAdapterImage($source_uri, $image_style);
+    }
+    catch (FileNotFoundException $e) {
+      return $this->deliverTemporary($scheme, $target, $image_style);
+    }
+  }
+
+  /**
+   * Generate a temporary image for an image style.
+   *
+   * @param string $scheme
+   *   The file scheme, defaults to 'private'.
+   * @param string $source_path
+   *   The image file to generate the temporary image for.
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style to generate.
+   *
+   * @throws \RuntimeException
+   *   Thrown when generate() failed to generate an image.
+   *
+   * @return \Drupal\file\Entity\File
+   *   The temporary image that was generated.
+   */
+  protected function generateTemporaryImage($scheme, $source_path, ImageStyleInterface $image_style) {
+    // Remove any derivative extension from the source path.
+    $derivative_extension = $image_style->getDerivativeExtension('');
+    if ($derivative_extension) {
+      $source_path = substr($source_path, 0, -strlen($derivative_extension) - 1);
+    }
+
+    $image_uri = "$scheme://$source_path";
+    $destination_temp = $this->getTemporaryDestination($scheme, $source_path, $image_style);
+
+    // Try to generate the temporary image, watching for other threads that may
+    // also be trying to generate the temporary image.
+    try {
+      $success = $this->generate($image_style, $image_uri, $destination_temp);
+      if (!$success) {
+        throw new \RuntimeException('The temporary image could not be generated');
+      }
+    }
+    catch (ServiceUnavailableHttpException $e) {
+      // This exception is only thrown if the lock could not be acquired.
+      $tries = 0;
+
+      do {
+        if (file_exists($destination_temp)) {
+          break;
+        }
+
+        // The file still doesn't exist.
+        usleep(250000);
+        $tries++;
+      } while ($tries < 4);
+
+      // We waited for more than 1 second for the temporary image to appear.
+      // Since local image generation should be fast, fail out here to try to
+      // limit PHP process demands.
+      if ($tries >= 4) {
+        throw $e;
+      }
+    }
+
+    return $destination_temp;
+  }
+
+  /**
+   * Flushes the output buffer and copies the temporary images to the adapter.
+   */
+  protected function flushCopy() {
+    // We have to call both of these to actually flush the image.
+    Response::closeOutputBuffers(0, TRUE);
+    flush();
+    $this->imageStyleCopier->processCopyTasks();
+  }
+
+  /**
+   * Redirects to an adapter hosted image, if it exists.
+   *
+   * @param string $source_uri
+   *   The URI to the source image.
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style to redirect to.
+   *
+   * @throws \Symfony\Component\HttpFoundation\File\Exception\FileNotFoundException
+   *   Thrown if the derivative does not exist on the adapter.
+   *
+   * @return \Drupal\Core\Routing\TrustedRedirectResponse
+   *   A redirect to the image if it exists.
+   */
+  protected function redirectAdapterImage($source_uri, ImageStyleInterface $image_style) {
+    $derivative_uri = $image_style->buildUri($source_uri);
+
+    if (file_exists($derivative_uri)) {
+      // We can't just return TrustedRedirectResponse because core throws an
+      // exception about missing cache metadata.
+      // https://www.drupal.org/node/2638686
+      // https://www.drupal.org/node/2630808
+      // http://drupal.stackexchange.com/questions/187086/trustedresponseredirect-failing-how-to-prevent-cache-metadata
+      $render_context = new RenderContext();
+      $url = $this->renderer->executeInRenderContext($render_context, function () use ($image_style, $source_uri) {
+        return Url::fromUri($image_style->buildUrl($source_uri))->toString();
+      });
+
+      $response = new TrustedRedirectResponse($url);
+      if (!$render_context->isEmpty()) {
+        $response->addCacheableDependency($render_context->pop());
+      }
+
+      return $response;
+    }
+
+    throw new FileNotFoundException(sprintf('%derivative_uri does not exist', $derivative_uri));
+  }
+
+  /**
+   * Delivers a generate an image, deliver it, and upload it to the adapter.
+   *
+   * @param string $scheme
+   *   The scheme of the source image.
+   * @param string $source_path
+   *   The path of the source image.
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style to generate.
+   *
+   * @return \Symfony\Component\HttpFoundation\BinaryFileResponse|\Symfony\Component\HttpFoundation\Response
+   *   The image response, or an error response if image generation failed.
+   */
+  protected function deliverTemporary($scheme, $source_path, ImageStyleInterface $image_style) {
+    $source_uri = $scheme . '://' . $source_path;
+
+    // Try to serve the temporary image if possible. Load into memory, since it
+    // can be deleted at any point.
+    $destination_temp = $this->getTemporaryDestination($scheme, $source_path, $image_style);
+
+    if (file_exists($destination_temp)) {
+      return $this->sendRawImage($destination_temp);
+    }
+
+    try {
+      $temporary_uri = $this->generateTemporaryImage($scheme, $source_path, $image_style);
+    }
+    catch (\RuntimeException $e) {
+      $derivative_uri = $image_style->buildUri($source_uri);
+      $this->logger->notice('Unable to generate the derived image located at %path.', ['%path' => $derivative_uri]);
+      return new Response($this->t('Error generating image.'), 500);
+    }
+
+    // Register a copy task with the kernel terminate handler.
+    $this->imageStyleCopier->addCopyTask($temporary_uri, $source_uri, $image_style);
+
+    // Symfony's kernel terminate handler is documented to only executes after
+    // flushing with fastcgi, and not with mod_php or regular CGI. However,
+    // it appears to work with mod_php. We assume it doesn't and register a
+    // shutdown handler unless we know we are under fastcgi. If images have
+    // been previously flushed and uploaded, this call will do nothing.
+    //
+    // https://github.com/symfony/symfony-docs/issues/6520
+    if (!function_exists('fastcgi_finish_request')) {
+      drupal_register_shutdown_function(function () {
+        $this->flushCopy();
+      });
+    }
+
+    return $this->send($scheme, $temporary_uri);
+  }
+
+  /**
+   * Returns the temporary image path.
+   *
+   * @param string $scheme
+   *   The scheme of the source image.
+   * @param string $source_path
+   *   The path of the source image.
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style to generate.
+   *
+   * @return string
+   *   The temporary image path.
+   */
+  protected function getTemporaryDestination($scheme, $source_path, ImageStyleInterface $image_style) {
+    return $image_style->buildUri("temporary://flysystem/$scheme/$source_path");
+  }
+
+  /**
+   * Returns a response of the derived raw image.
+   *
+   * @param string $path
+   *   The file path.
+   * @param array $headers
+   *   (optional) An array of headers to return in the response.
+   *
+   * @return \Symfony\Component\HttpFoundation\Response
+   *   A response with the derived image.
+   */
+  protected function sendRawImage(string $path, array $headers = []): Response {
+    $response = new BinaryFileResponse($path, 200, $headers);
+    $response->headers->set('Content-Type', $this->mimeTypeGuesser->guessMimeType($path));
+
+    return $response;
+  }
+
+}
diff --git a/src/Decorator/FlysystemDrupalFileSystem.php b/src/Decorator/FlysystemDrupalFileSystem.php
deleted file mode 100644
index 264d48a..0000000
--- a/src/Decorator/FlysystemDrupalFileSystem.php
+++ /dev/null
@@ -1,265 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\Decorator;
-
-use Drupal\Component\Utility\Unicode;
-use Drupal\Core\File\Exception\FileException;
-use Drupal\Core\File\Exception\FileWriteException;
-use Drupal\Core\File\Exception\InvalidStreamWrapperException;
-use Drupal\Core\File\FileExists;
-use Drupal\Core\File\FileSystem;
-use Drupal\Core\Site\Settings;
-use Drupal\Core\StreamWrapper\StreamWrapperManager;
-use Drupal\Core\StreamWrapper\StreamWrapperManagerInterface;
-use Drupal\flysystem\FlyStream\FlyStreamWrapperInterface;
-
-/**
- * Decorates \Drupal::service('file_system').
- *
- * Unmodified public methods:
- * - ::basename
- * - ::getTempDirectory.
- *
- * The trait FlysystemFileSystemTrait contains the logic that is passed to the
- * Flysystem Stream Wrapper instance.
- *
- * @see Drupal\Core\File\FileSystemInteface
- * @see Drupal\Core\File\FileSystem
- */
-class FlysystemDrupalFileSystem extends FileSystem {
-
-  use FlysystemFileSystemTrait;
-
-  /**
-   * The inner service.
-   *
-   * @var \Drupal\Core\File\FileSystem
-   */
-  protected $decoratedService;
-
-  /**
-   * The site settings.
-   *
-   * @var \Drupal\Core\Site\Settings
-   */
-  protected $settings;
-
-  /**
-   * The stream wrapper manager.
-   *
-   * @var \Drupal\Core\StreamWrapper\StreamWrapperManagerInterface
-   */
-  protected $streamWrapperManager;
-
-  /**
-   * Constructs a new FileSystem.
-   *
-   * Leverages Drupal's existing FileSystem object, enhanced by Flysystem's
-   * Adapters.
-   *
-   * Flysystem Adapters are implemented as part of instantiating a Flysystem
-   * Operator.  In this module, Flysystem Operators are registered using
-   * Drupal's StreamWrapperManager.
-   *
-   * @param \Drupal\Core\File\FileSystem $decorated_service
-   *   Drupal Core's FileSystem service, which is being decorated here.
-   * @param \Drupal\Core\StreamWrapper\StreamWrapperManagerInterface $stream_wrapper_manager
-   *   The stream wrapper manager.
-   * @param \Drupal\Core\Site\Settings $settings
-   *   The site settings.
-   */
-  public function __construct(FileSystem $decorated_service, StreamWrapperManagerInterface $stream_wrapper_manager, Settings $settings) {
-    $this->decoratedService = $decorated_service;
-    $this->streamWrapperManager = $stream_wrapper_manager;
-    $this->settings = $settings;
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo rewrite to leverage Flysystem (yes)
-   * @see \Drupal\Core\File\FileSystem::moveUploadedFile()
-   */
-  public function moveUploadedFile($filename, $uri) {
-    return $this->decoratedService->moveUploadedFile($filename, $uri);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function chmod($uri, $mode = NULL) {
-    if (!isset($mode)) {
-      /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-      $wrapper = $this->streamWrapperManager->getViaUri($uri);
-      if ($wrapper instanceof FlyStreamWrapperInterface) {
-        return $this->chmodFs($wrapper, $uri, $mode);
-      }
-    }
-    return $this->decoratedService->chmod($uri, $mode);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function mkdir($uri, $mode = NULL, $recursive = FALSE, $context = NULL) {
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaUri($uri);
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->mkdirFs($wrapper, $uri, $mode, $recursive, $context);
-    }
-    return $this->decoratedService->mkdir($uri, $mode, $recursive, $context);
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo finish writing, see inline todo comments.
-   */
-  public function rmdir($uri, $context = NULL) {
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaUri($uri);
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->rmdirFs($wrapper, $uri, $context);
-    }
-    return $this->decoratedService->rmdir($uri, $context);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function copy($source, $destination, $fileExists = FileExists::Rename) {
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaScheme(StreamWrapperManager::getScheme($source));
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->copyFs($wrapper, $source, $destination, $fileExists);
-    }
-    return $this->decoratedService->copy($source, $destination, $fileExists);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function delete($path) {
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperManager $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaUri($path);
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->deleteFs($wrapper, $path);
-    }
-    return $this->decoratedService->delete($path);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function deleteRecursive($path, callable $callback = NULL) {
-    if ($callback) {
-      return $this->decoratedService->deleteRecursive($path, $callback);
-    }
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaUri($path);
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->deleteRecursiveFs($wrapper, $path, $callback);
-    }
-    return $this->decoratedService->deleteRecursive($path, NULL);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function move($source, $destination, $fileExists = FileExists::Rename) {
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaScheme(StreamWrapperManager::getScheme($source));
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->moveFs($wrapper, $source, $destination, $fileExists);
-    }
-    return $this->decoratedService->move($source, $destination, $fileExists);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function saveData($data, $destination, $fileExists = FileExists::Rename) {
-    // Write the data to a temporary file.
-    // The assumption here is that temporary files will always use the local
-    // filespace.
-    $temp_name = $this->tempnam('temporary://', 'file');
-    if (file_put_contents($temp_name, $data) === FALSE) {
-      throw new FileWriteException("Temporary file '$temp_name' could not be created.");
-    }
-    if (!$this->streamWrapperManager->isValidUri($destination)) {
-      throw new InvalidStreamWrapperException("Invalid stream wrapper: {$destination}");
-    }
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaScheme(StreamWrapperManager::getScheme($destination));
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->saveDataFs($wrapper, $temp_name, $destination, $fileExists);
-    }
-    return $this->decoratedService->move($temp_name, $destination, $fileExists);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function prepareDirectory(&$directory, $options = self::MODIFY_PERMISSIONS) {
-    if (!$this->streamWrapperManager->isValidUri($directory)) {
-      // Only trim if we're not dealing with a stream.
-      $directory = rtrim($directory, '/\\');
-    }
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaScheme(StreamWrapperManager::getScheme($directory));
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->prepareDirectoryFs($wrapper, $directory, $options);
-    }
-    return $this->decoratedService->prepareDirectory($directory, $options);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function createFilename($basename, $directory) {
-    $original = $basename;
-    // Strip control characters (ASCII value < 32). Though these are allowed in
-    // some filesystems, not many applications handle them well.
-    $basename = preg_replace('/[\x00-\x1F]/u', '_', $basename);
-    if (preg_last_error() !== PREG_NO_ERROR) {
-      throw new FileException(sprintf("Invalid filename '%s'", $original));
-    }
-    if (str_starts_with(PHP_OS, 'WIN')) {
-      // These characters are not allowed in Windows filenames.
-      $basename = str_replace([':', '*', '?', '"', '<', '>', '|'], '_', $basename);
-    }
-
-    // A URI or path may already have a trailing slash or look like "public://".
-    if (str_ends_with($directory, '/')) {
-      $separator = '';
-    }
-    else {
-      $separator = '/';
-    }
-    $destination = $directory . $separator . $basename;
-
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaScheme(StreamWrapperManager::getScheme($destination));
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->createFilenameFs($wrapper, $separator, $destination, $basename, $directory);
-    }
-    return $this->decoratedService->createFilename($basename, $directory);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getDestinationFilename($destination, $fileExists) {
-    $basename = $this->basename($destination);
-    if (!Unicode::validateUtf8($basename)) {
-      throw new FileException(sprintf("Invalid filename '%s'", $basename));
-    }
-    /** @var \Drupal\Core\StreamWrapper\StreamWrapperInterface $wrapper */
-    $wrapper = $this->streamWrapperManager->getViaScheme(StreamWrapperManager::getScheme($destination));
-    if ($wrapper instanceof FlyStreamWrapperInterface) {
-      return $this->getDestinationFilenameFs($wrapper, $basename, $destination, $fileExists);
-    }
-    return $this->decoratedService->getDestinationFilename($destination, $fileExists);
-  }
-
-}
diff --git a/src/Decorator/FlysystemFileSystemTrait.php b/src/Decorator/FlysystemFileSystemTrait.php
deleted file mode 100644
index 3d8d2d1..0000000
--- a/src/Decorator/FlysystemFileSystemTrait.php
+++ /dev/null
@@ -1,468 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\Decorator;
-
-use Drupal\Core\File\Exception\NotRegularFileException;
-use Drupal\Core\File\FileExists;
-
-/**
- * League\Flysystem\Filesystem to Drupal\Core\File\FileSystem conversion.
- *
- * Contains all logic to convert Drupal's FileSystem service methods to utilize
- * League\Flysystem\Filesystem methods and logic.
- *
- * The purpose of this trait is to isolate the logic specific to this logic
- * conversion into one maintainable class, separate from the decorator logic
- * itself, which is pretty straightforward.
- */
-trait FlysystemFileSystemTrait {
-
-  /**
-   * Converts Drupal's FileSystem::chmod() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $uri
-   *   A string containing a URI file, or directory path.
-   * @param int $mode
-   *   Integer value for permissions.
-   *
-   * @return bool
-   *   TRUE for success, FALSE in the event of an error.
-   */
-  protected function chmodFs($wrapper, $uri, $mode = NULL): bool {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', uri: ' . $uri);
-    try {
-      $drupalMode = NULL;
-      if ($wrapper->filesystem->directoryExists($uri)) {
-        // @todo May have to write a Flysystem VisibilityConverter for
-        // Local file adapter that substitutes Drupal file and directory
-        // permission settings for the default settings in Flysystem.
-        $drupalMode = $this->settings->get('file_chmod_directory', static::CHMOD_DIRECTORY);
-      }
-      elseif ($wrapper->filesystem->fileExists($uri)) {
-        $drupalMode = $this->settings->get('file_chmod_file', static::CHMOD_FILE);
-      }
-      $wrapper->filesystem->setVisibility($uri, $drupalMode);
-      return TRUE;
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      // @todo write exception handler for possible exceptions thrown
-      // by FlysystemAdapter::setVisibility();
-    }
-    return FALSE;
-  }
-
-  /**
-   * Converts Drupal's FileSystem::mkdir() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $uri
-   *   A URI or pathname.
-   * @param int $mode
-   *   Mode given to created directories. Defaults to the directory mode
-   *   configured in the Drupal installation. It must have a leading zero.
-   * @param bool $recursive
-   *   Create directories recursively, defaults to FALSE. Cannot work with a
-   *   mode which denies writing or execution to the owner of the process.
-   * @param resource $context
-   *   Refer to http://php.net/manual/ref.stream.php.
-   *
-   * @return bool
-   *   Boolean TRUE on success, or FALSE on failure.
-   *
-   * @todo finish writing, see inline todo comments.
-   */
-  protected function mkdirFs($wrapper, $uri, $mode = NULL, $recursive = FALSE, $context = NULL): bool {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', uri: ' . $uri);
-    if (!isset($mode)) {
-      $mode = $this->settings->get('file_chmod_directory', static::CHMOD_DIRECTORY);
-    }
-
-    try {
-      // @todo figure out how to utilize directory permissions, see notes on
-      // Flysystem VisibilityConverter.
-      // @see \League\Flysystem\Filesystem::createDirectory()
-      $wrapper->filesystem->createDirectory($uri);
-      return TRUE;
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      \Drupal::logger('FlyStreamWrapper')->error('Failed to create directory for ' . $uri);
-      // @todo write exception handler to handle Flysystem Exception, and
-      // return a proper return code, which is FALSE.
-    }
-    return FALSE;
-  }
-
-  /**
-   * Converts Drupal's FileSystem::rmdir() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $uri
-   *   A URI or pathname.
-   * @param resource $context
-   *   Refer to http://php.net/manual/ref.stream.php.
-   *
-   * @return bool
-   *   Boolean TRUE on success, or FALSE on failure.
-   *
-   * @todo finish writing, see inline todo comments.
-   */
-  protected function rmdirFs($wrapper, $uri, $context = NULL): bool {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', uri: ' . $uri);
-    try {
-      // @todo figure out how to utilize directory permissions, see notes on
-      // Flysystem VisibilityConverter.
-      // @see \League\Flysystem\Filesystem::deleteDirectory()
-      $wrapper->filesystem->deleteDirectory($uri);
-      return TRUE;
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      // @todo write exception handler to handle Flysystem Exception, and
-      // return a proper return code, which is FALSE.
-    }
-    return FALSE;
-  }
-
-  /**
-   * Converts Drupal's FileSystem::copy() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $source
-   *   A string specifying the filepath or URI of the source file.
-   * @param string $destination
-   *   A URI containing the destination that $source should be copied to. The
-   *   URI may be a bare filepath (without a scheme).
-   * @param \Drupal\Core\File\FileExists|int $fileExists
-   *   The behavior when the destination file already exists.
-   *
-   * @return string
-   *   The path to the new file.
-   *
-   * @todo Rewrite to leverage Flysystem (yes)
-   */
-  protected function copyFs($wrapper, $source, $destination, $fileExists): string {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', source: ' . $source . ', destination: ' . $destination);
-    try {
-      // @todo figure out how to utilize directory permissions, see notes on
-      // Flysystem VisibilityConverter.
-      // @see \League\Flysystem\Filesystem::copy().
-      $wrapper->filesystem->copy($source, $destination);
-      return $destination;
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      // @todo write exception handler to handle Flysystem Exception, and
-      // return a proper return code, which is FALSE.
-    }
-    return '';
-  }
-
-  /**
-   * Converts Drupal's FileSystem::delete() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $path
-   *   A string containing a file path or (streamwrapper) URI.
-   *
-   * @return true
-   *   Always return true, unless an exception is thrown.
-   *
-   * @todo finish writing, see inline todo comments.
-   */
-  protected function deleteFs($wrapper, $path) {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', path: ' . $path);
-    if ($wrapper->filesystem->directoryExists($path)) {
-      throw new NotRegularFileException("Cannot delete '$path' because it is a directory. Use deleteRecursive() instead.");
-    }
-    if ($wrapper->filesystem->fileExists($path)) {
-      try {
-        $wrapper->filesystem->delete($path);
-      }
-      catch (\Exception $e) {
-        \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-        // @todo modify \Exception to use class from Flysystem,
-        // and throw a proper exception.
-      }
-    }
-    // If file does not exist, return TRUE, that is the intended result.
-    return TRUE;
-  }
-
-  /**
-   * Drupal's FileSystem::deleteRecursive() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $path
-   *   A string containing either an URI or a file or directory path.
-   * @param callable|null $callback
-   *   Callback function to run on each file prior to deleting it and on each
-   *   directory prior to traversing it. For example, can be used to modify
-   *   permissions.
-   *
-   * @return bool
-   *   TRUE if successful, FALSE if not.
-   */
-  protected function deleteRecursiveFs($wrapper, $path, callable $callback = NULL):  bool {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', path: ' . $path);
-    if (!$wrapper->filesystem->fileExists($path)) {
-      return TRUE;
-    }
-
-    if ($wrapper->filesystem->directoryExists($path)) {
-      $dir = $wrapper->filesystem->listContents($path);
-      foreach ($dir as $entry) {
-        $entry_path = $path . '/' . $entry->path();
-        $this->deleteRecursive($entry_path, $callback);
-      }
-      return $this->rmdir($path);
-    }
-    return $this->delete($path);
-  }
-
-  /**
-   * Converts Drupal's FileSystem::move() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $source
-   *   A string specifying the filepath or URI of the source file.
-   * @param string $destination
-   *   A URI containing the destination that $source should be moved to. The
-   *   URI may be a bare filepath (without a scheme) and in that case the
-   *   default scheme (public://) will be used.
-   * @param \Drupal\Core\File\FileExists|int $fileExists
-   *   Replace behavior when the destination file already exists.
-   *
-   * @return string
-   *   The path to the new file.
-   *
-   * @todo finish writing, see inline todo comments.
-   */
-  protected function moveFs($wrapper, $source, $destination, $fileExists): string {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', source: ' . $source . ', destination: ' . $destination);
-    try {
-      // @todo figure out how to utilize directory permissions, see notes on
-      // Flysystem VisibilityConverter.
-      // @see \League\Flysystem\Filesystem::move().
-      // What do we do with the $replace flag?
-      $wrapper->filesystem->move($source, $destination);
-      return $destination;
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      // @todo write exception handler to handle Flysystem Exception, and
-      // return a proper return code, which is FALSE.
-    }
-    return '';
-  }
-
-  /**
-   * Converts Drupal's FileSystem::saveData() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $temp_nam
-   *   A string containing the contents of the file, moved to a temporary
-   *   location.
-   * @param string $destination
-   *   A string containing the destination location. This must be a stream
-   *   wrapper URI.
-   * @param \Drupal\Core\File\FileExists|int $fileExists
-   *   Replace behavior when the destination file already exists.
-   *
-   * @return string
-   *   A string with the path of the resulting file, or FALSE on error.
-   *
-   * @todo finish writing, see inline todo comments.
-   */
-  protected function saveDataFs($wrapper, $temp_nam, $destination, $fileExists) {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', temp_nam: ' . $temp_nam . ', destination: ' . $destination);
-    // Move the file to its final destination.
-    try {
-      // @todo figure out how to utilize directory permissions, see notes on
-      // Flysystem VisibilityConverter.
-      // @see \League\Flysystem\Filesystem::move().
-      // Do we need to use the $replace flag here in the FlysystemAdapter?
-      $wrapper->filesystem->move($temp_nam, $destination);
-      return $destination;
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      // @todo write exception handler to handle Flysystem Exception, and
-      // return a proper return code, which is FALSE.
-    }
-    return '';
-  }
-
-  /**
-   * Drupal's FileSystem::prepareDirectory() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $directory
-   *   A string reference containing the name of a directory path or URI. A
-   *   trailing slash will be trimmed from a path.
-   * @param int $options
-   *   A bitmask to indicate if the directory should be created if it does
-   *   not exist (FileSystemInterface::CREATE_DIRECTORY) or made writable if it
-   *   is read-only (FileSystemInterface::MODIFY_PERMISSIONS).
-   *
-   * @return bool
-   *   TRUE if the directory exists (or was created) and is writable. FALSE
-   *   otherwise.
-   *
-   * @todo finish writing, see inline todo comments.
-   * @see \League\Flysystem\FilesystemOperator::directoryExists()
-   */
-  protected function prepareDirectoryFs($wrapper, &$directory, $options): bool {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', directory: ' . $directory);
-    if (!$this->streamWrapperManager->isValidUri($directory)) {
-      // Only trim if we're not dealing with a stream.
-      $directory = rtrim($directory, '/\\');
-    }
-    // How do we use the flags, self::MODIFY_PERMISSIONS and
-    // static::CREATE_DIRECTORY here?
-    // @see Drupal\Core\File\FileSystemInterface::prepareDirectory().
-    try {
-      // Let mkdir() recursively create directories and use the default
-      // directory permissions.
-      $success = $this->mkdir($directory, NULL, TRUE);
-      if ($success) {
-        return TRUE;
-      }
-      // If the operation failed, check again if the directory was created
-      // by another process/server, only report a failure if not. In this case
-      // we still need to ensure the directory is writable.
-      if (!is_dir($directory)) {
-        return FALSE;
-      }
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      // @todo write exception handler to handle Flysystem Exception, and
-      // return a proper return code, which is FALSE.
-    }
-    // If the operation failed, check again if the directory was created
-    // by another process/server, only report a failure if not. In this case
-    // we still need to ensure the directory is writable.
-    if (!$wrapper->filesystem->directoryExists($directory)) {
-      return FALSE;
-    }
-    $writable = is_writable($directory);
-    if (!$writable && ($options & static::MODIFY_PERMISSIONS)) {
-      return $this->chmod($directory);
-    }
-    return $writeable;
-  }
-
-  /**
-   * Drupal's FileSystem::createFilename() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $separator
-   *   The pathname separator.
-   * @param string $destination
-   *   The destination filename.
-   * @param string $basename
-   *   The filename.
-   * @param string $directory
-   *   The directory or parent URI.
-   *
-   * @return string
-   *   File path consisting of $directory and a unique filename based off
-   *   of $basename.
-   *
-   * @todo finish writing, see inline todo comments.
-   * @todo reevaluate against \Drupal\Core\File\FileSystem::createFilename().
-   */
-  protected function createFilenameFs($wrapper, $separator, $destination, $basename, $directory): string {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', separator: ' . $separator . ', destination: ' . $destination . ', basename: ' . $basename . ', directory: ' . $directory);
-    try {
-      $exists = $wrapper->filesystem->fileExists($destination);
-      if ($exists) {
-        // Destination file already exists, generate an alternative.
-        $pos = strrpos($basename, '.');
-        if ($pos !== FALSE) {
-          $name = substr($basename, 0, $pos);
-          $ext = substr($basename, $pos);
-        }
-        else {
-          $name = $basename;
-          $ext = '';
-        }
-
-        $counter = 0;
-        do {
-          $destination = $directory . $separator . $name . '_' . $counter++ . $ext;
-        } while ($wrapper->filesystem->fileExists($destination));
-
-      }
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      // @todo write exception handler to handle Flysystem Exception, and
-      // return a proper return code, which is FALSE.
-    }
-    return $destination;
-  }
-
-  /**
-   * FileSystem::getDestinationFilename() to FilesystemOperator methods.
-   *
-   * @param \Drupal\flysystem\FlyStream\FlyStreamWrapperInterface $wrapper
-   *   Drupal StreamWrapper service.
-   * @param string $basename
-   *   The base file name, calculated.
-   * @param string $destination
-   *   The desired final URI or filepath.
-   * @param \Drupal\Core\File\FileExists|int $fileExists
-   *   Replace behavior when the destination file already exists.
-   *
-   * @return string|bool
-   *   The destination filepath, or FALSE if the file already exists
-   *   and FileExists::Error is specified.
-   *
-   * @todo finish writing, see inline todo comments.
-   */
-  protected function getDestinationFilenameFs($wrapper, $basename, $destination, $fileExists): string|bool {
-    \Drupal::logger('flysystem')->notice('Calling ' . __METHOD__ . ', basename: ' . $basename . ', destination: ' . $destination);
-    try {
-      if ($wrapper->filesystem->fileExists($destination)) {
-        switch ($fileExists) {
-          case FileExists::Replace:
-            // Do nothing here, we want to overwrite the existing file.
-            break;
-
-          case FileExists::Rename:
-            // Hmm, we are using the original Drupal FileSystem::dirname()
-            // method here, will it error out?  Do we actually need to call
-            // this?
-            $directory = $this->dirname($destination);
-            $destination = $this->createFilename($basename, $directory);
-            break;
-
-          case FileExists::Error:
-            // Error reporting handled by calling function.
-            return FALSE;
-        }
-      }
-    }
-    catch (\Exception $e) {
-      \Drupal::logger('FlyStreamWrapper')->error('Exception: ' . $e->getMessage());
-      // @todo write exception handler to handle Flysystem Exception, and
-      // return a proper return code, which is FALSE.
-    }
-    return $destination;
-  }
-
-}
diff --git a/src/Entity/FlysystemAdapterConfig.php b/src/Entity/FlysystemAdapterConfig.php
deleted file mode 100644
index b32319b..0000000
--- a/src/Entity/FlysystemAdapterConfig.php
+++ /dev/null
@@ -1,265 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem\Entity;
-
-use Drupal\Component\Utility\NestedArray;
-use Drupal\Core\Config\Config;
-use Drupal\Core\Config\Entity\ConfigEntityBase;
-use Drupal\Core\Config\Entity\ConfigEntityTypeInterface;
-use Drupal\Core\Entity\EntityInterface;
-use Drupal\Core\Entity\EntityStorageInterface;
-use Drupal\flysystem\FlysystemAdapterConfigInterface;
-use Drupal\flysystem\FlysystemException;
-
-/**
- * Defines the flysystem_adapter_config entity type.
- *
- * @ConfigEntityType(
- *   id = "flysystem_adapter_config",
- *   label = @Translation("Configured Flysystem Adapter"),
- *   label_collection = @Translation("Configured Flysystem Adapters"),
- *   label_singular = @Translation("configured Flysystem Adapter"),
- *   label_plural = @Translation("configured Flysystem Adapters"),
- *   label_count = @PluralTranslation(
- *     singular = "@count configured Flysystem Adapter",
- *     plural = "@count configured Flysystem Adapters",
- *   ),
- *   handlers = {
- *     "list_builder" = "Drupal\flysystem\FlysystemAdapterConfigListBuilder",
- *     "form" = {
- *       "add" = "Drupal\flysystem\Form\FlysystemAdapterConfigForm",
- *       "edit" = "Drupal\flysystem\Form\FlysystemAdapterConfigForm",
- *       "delete" = "Drupal\Core\Entity\EntityDeleteForm",
- *     },
- *   },
- *   config_prefix = "flysystem_adapter_config",
- *   admin_permission = "administer flysystem_adapter_config",
- *   links = {
- *     "collection" = "/admin/config/media/flysystem-adapter-config",
- *     "add-form" = "/admin/config/media/flysystem-adapter-config/add",
- *     "edit-form" = "/admin/config/media/flysystem-adapter-config/{flysystem_adapter_config}",
- *     "delete-form" = "/admin/config/media/flysystem-adapter-config/{flysystem_adapter_config}/delete",
- *   },
- *   entity_keys = {
- *     "id" = "id",
- *     "label" = "label",
- *     "uuid" = "uuid",
- *   },
- *   config_export = {
- *     "id",
- *     "label",
- *     "description",
- *     "sub_adapter",
- *     "sub_adapter_config",
- *   },
- * )
- */
-final class FlysystemAdapterConfig extends ConfigEntityBase implements FlysystemAdapterConfigInterface {
-
-  /**
-   * The flysystem_adapter_config ID.
-   */
-  protected string $id;
-
-  /**
-   * The flysystem_adapter_config label.
-   */
-  protected string $label;
-
-  /**
-   * The flysystem_adapter_config description.
-   */
-  protected string $description;
-
-  /**
-   * The ID of the subAdapter plugin.
-   *
-   * @var string
-   */
-  protected $sub_adapter;
-
-  /**
-   * The adapter plugin configuration.
-   *
-   * @var array
-   */
-  protected $sub_adapter_config = [];
-
-  /**
-   * The adapter plugin instance.
-   *
-   * @var \Drupal\flysystem\FlysystemAdapterInterface|null
-   */
-  protected $subAdapterPlugin;
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getDescription() {
-    return !empty($this->description) ? $this->description : '';
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function hasValidSubAdapter() {
-    $subadapter_plugin_definition = \Drupal::service('plugin.manager.flysystem_adapter')->getDefinition($this->getSubAdapterId(), FALSE);
-    return !empty($subadapter_plugin_definition);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getSubAdapterId() {
-    return $this->sub_adapter;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getSubAdapterConfigItem($key) {
-    if (is_array($key)) {
-      return NestedArray::getValue($this->sub_adapter_config, $key);
-    }
-    return $this->sub_adapter_config[$key] ?? '';
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getSubAdapter() {
-    if (!$this->subAdapterPlugin) {
-      $subadapter_plugin_manager = \Drupal::service('plugin.manager.flysystem_adapter');
-      $config = $this->sub_adapter_config;
-      $config['#flysystem_adapter_config'] = $this;
-      if (!($this->subAdapterPlugin = $subadapter_plugin_manager->createInstance($this->getSubAdapterId(), $config))) {
-        $sub_adapter_id = $this->getSubAdapterId();
-        throw new FlysystemException("The adapter with ID '$sub_adapter_id' could not be retrieved.");
-      }
-    }
-    return $this->subAdapterPlugin;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getSubAdapterConfig() {
-    return $this->sub_adapter_config;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function setSubAdapterConfig(array $sub_adapter_config) {
-    $this->sub_adapter_config = $sub_adapter_config;
-    // In case the subadapter plugin is already loaded, make sure the
-    // configuration stays in sync.
-    if ($this->subAdapterPlugin
-        && $this->getSubAdapter()->getConfiguration() !== $sub_adapter_config) {
-      $this->getSubAdapter()->setConfiguration($sub_adapter_config);
-    }
-    return $this;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function preSave(EntityStorageInterface $storage) {
-    parent::preSave($storage);
-
-    // The rest of the code only applies to updates.
-    if (!isset($this->original)) {
-      return;
-    }
-    // Retrieve active config overrides for this adapter config entity.
-    $overrides = $this->getConfigOverrides($this);
-
-    // If there are overrides for the sub_adapter or its configuration, attempt
-    // to apply them for the preUpdate() call.
-    if (isset($overrides['sub_adapter']) || isset($overrides['sub_adapter_config'])) {
-      $sub_adapter_config = $this->getSubAdapterConfig();
-      if (isset($overrides['sub_adapter_config'])) {
-        $sub_adapter_config = $overrides['sub_adapter_config'];
-      }
-      $sub_adapter_id = $this->getSubAdapterId();
-      if (isset($overrides['sub_adapter'])) {
-        $sub_adapter_id = $overrides['sub_adapter'];
-      }
-      $subadapter_plugin_manager = \Drupal::service('plugin.manager.flysystem_adapter');
-      $sub_adapter_config['#flysystem_adapter_config'] = $this;
-      if (!($subadapter_plugin_manager->createInstance($sub_adapter_id, $sub_adapter_config))) {
-        throw new FlysystemException("The adapter with ID '$sub_adapter_id' could not be retrieved.");
-      }
-    }
-  }
-
-  /**
-   * Implements the magic __clone() method.
-   *
-   * Prevents the adapter plugin instance from being cloned.
-   */
-  public function __clone() {
-    $this->subAdapterPlugin = NULL;
-  }
-
-  /**
-   * Retrieves all overridden property values for the given config entity.
-   *
-   * @param \Drupal\Core\Entity\EntityInterface $entity
-   *   The config entity to check for overrides.
-   *
-   * @return array
-   *   An associative array mapping property names to their overridden values.
-   */
-  private function getConfigOverrides(EntityInterface $entity) {
-    $entity_type = $entity->getEntityType();
-    if (!($entity_type instanceof ConfigEntityTypeInterface)) {
-      return [];
-    }
-
-    $config_key = $entity_type->getConfigPrefix() . '.' . $entity->id();
-    $config = \Drupal::config($config_key);
-    if (!$config->hasOverrides()) {
-      return [];
-    }
-
-    return $this->collectOverrides($config, $config->get());
-  }
-
-  /**
-   * Collects overrides from a config object.
-   *
-   * @param \Drupal\Core\Config\Config $config
-   *   The config object.
-   * @param array $values
-   *   The array of values for the given $prefix.
-   * @param array $overrides
-   *   (optional) The overrides collected so far. Internal use only.
-   * @param string $prefix
-   *   (optional) The config key prefix for the current call level.  Internal
-   *   use only.
-   *
-   * @return array
-   *   An associative array mapping property names to their overridden values.
-   */
-  private function collectOverrides(Config $config, array $values, array $overrides = [], $prefix = '') {
-    foreach ($values as $key => $value) {
-      $key = "$prefix$key";
-      if (!$config->hasOverrides($key)) {
-        continue;
-      }
-      if (is_array($value)) {
-        NestedArray::setValue($overrides, explode('.', $key), []);
-        $overrides = $this->collectOverrides($config, $value, $overrides, "$key.");
-      }
-      else {
-        NestedArray::setValue($overrides, explode('.', $key), $value);
-      }
-    }
-
-    return $overrides;
-  }
-
-}
diff --git a/src/Event/EnsureEvent.php b/src/Event/EnsureEvent.php
new file mode 100644
index 0000000..56b646e
--- /dev/null
+++ b/src/Event/EnsureEvent.php
@@ -0,0 +1,99 @@
+<?php
+
+namespace Drupal\flysystem\Event;
+
+use Drupal\Component\EventDispatcher\Event;
+
+/**
+ * The event fired for every result from an ensure() call.
+ */
+class EnsureEvent extends Event {
+
+  /**
+   * The log context.
+   *
+   * @var array
+   */
+  protected $context;
+
+  /**
+   * The log message.
+   *
+   * @var string
+   */
+  protected $message;
+
+  /**
+   * The scheme of the item being logged.
+   *
+   * @var string
+   */
+  protected $scheme;
+
+  /**
+   * The severity of the message being logged.
+   *
+   * @var int
+   */
+  protected $severity;
+
+  /**
+   * Constructs an EnsureEvent object.
+   *
+   * @param string $scheme
+   *   The scheme.
+   * @param int $severity
+   *   The severity.
+   * @param string $message
+   *   The message.
+   * @param array $context
+   *   The context for the message.
+   */
+  public function __construct($scheme, $severity, $message, array $context) {
+    $this->scheme = $scheme;
+    $this->severity = $severity;
+    $this->message = $message;
+    $this->context = $context;
+  }
+
+  /**
+   * Returns the context.
+   *
+   * @return array
+   *   Context.
+   */
+  public function getContext() {
+    return $this->context;
+  }
+
+  /**
+   * Returns the message.
+   *
+   * @return string
+   *   The message text.
+   */
+  public function getMessage() {
+    return $this->message;
+  }
+
+  /**
+   * Returns the scheme.
+   *
+   * @return string
+   *   The scheme identifier.
+   */
+  public function getScheme() {
+    return $this->scheme;
+  }
+
+  /**
+   * Returns the severity.
+   *
+   * @return int
+   *   The severity.
+   */
+  public function getSeverity() {
+    return $this->severity;
+  }
+
+}
diff --git a/src/Event/FlysystemEvents.php b/src/Event/FlysystemEvents.php
new file mode 100644
index 0000000..f21fc6a
--- /dev/null
+++ b/src/Event/FlysystemEvents.php
@@ -0,0 +1,15 @@
+<?php
+
+namespace Drupal\flysystem\Event;
+
+/**
+ * Defines events for the Flysystem module.
+ */
+final class FlysystemEvents {
+
+  /**
+   * Fired when FlysystemFactory::ensure() is called.
+   */
+  const ENSURE = 'feeds.ensure';
+
+}
diff --git a/src/EventSubscriber/EnsureSubscriber.php b/src/EventSubscriber/EnsureSubscriber.php
new file mode 100644
index 0000000..aef0402
--- /dev/null
+++ b/src/EventSubscriber/EnsureSubscriber.php
@@ -0,0 +1,63 @@
+<?php
+
+namespace Drupal\flysystem\EventSubscriber;
+
+use Drupal\Core\Logger\RfcLogLevel;
+use Drupal\flysystem\Event\EnsureEvent;
+use Drupal\flysystem\Event\FlysystemEvents;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;
+
+/**
+ * Event listener that listens to Flysystem ensure() calls.
+ */
+class EnsureSubscriber implements EventSubscriberInterface {
+
+  /**
+   * The logger to use.
+   *
+   * @var \Psr\Log\LoggerInterface
+   */
+  protected $logger;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function getSubscribedEvents(): array {
+    $events = [];
+
+    $events[FlysystemEvents::ENSURE][] = 'onEnsure';
+
+    return $events;
+  }
+
+  /**
+   * Constructs an EnsureSubscriber object.
+   *
+   * @param \Psr\Log\LoggerInterface $logger
+   *   The logger.
+   */
+  public function __construct(LoggerInterface $logger) {
+    $this->logger = $logger;
+  }
+
+  /**
+   * Responds to FlysystemFactory::ensure().
+   */
+  public function onEnsure(EnsureEvent $event, $event_name, EventDispatcherInterface $dispatcher) {
+    // We only want to log failures, since this runs frequently.
+    switch ($event->getSeverity()) {
+      case RfcLogLevel::NOTICE:
+      case RfcLogLevel::INFO:
+        return;
+    }
+
+    $this->logger->log(
+      $event->getSeverity(),
+      $event->getMessage(),
+      $event->getContext()
+    );
+  }
+
+}
diff --git a/src/FlyStream/Exception/CouldNotDeleteFileException.php b/src/FlyStream/Exception/CouldNotDeleteFileException.php
deleted file mode 100644
index f180ef5..0000000
--- a/src/FlyStream/Exception/CouldNotDeleteFileException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when File Could Not be Deleted.
- */
-class CouldNotDeleteFileException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Could not delete file';
-
-}
diff --git a/src/FlyStream/Exception/CouldNotRemoveDirectoryException.php b/src/FlyStream/Exception/CouldNotRemoveDirectoryException.php
deleted file mode 100644
index 6b7c8b3..0000000
--- a/src/FlyStream/Exception/CouldNotRemoveDirectoryException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Directory Could Not be Removed.
- */
-class CouldNotRemoveDirectoryException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Could not remove directory';
-
-}
diff --git a/src/FlyStream/Exception/DirectoryExistsException.php b/src/FlyStream/Exception/DirectoryExistsException.php
deleted file mode 100644
index 1e36c46..0000000
--- a/src/FlyStream/Exception/DirectoryExistsException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Directory exists.
- */
-class DirectoryExistsException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Directory exists';
-
-}
diff --git a/src/FlyStream/Exception/DirectoryNotEmptyException.php b/src/FlyStream/Exception/DirectoryNotEmptyException.php
deleted file mode 100644
index 383f5e3..0000000
--- a/src/FlyStream/Exception/DirectoryNotEmptyException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Directory is Not Empty.
- */
-class DirectoryNotEmptyException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Directory not empty';
-
-}
diff --git a/src/FlyStream/Exception/DirectoryNotFoundException.php b/src/FlyStream/Exception/DirectoryNotFoundException.php
deleted file mode 100644
index 74c1c6e..0000000
--- a/src/FlyStream/Exception/DirectoryNotFoundException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Directory is not found.
- */
-class DirectoryNotFoundException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Failed to open dir';
-
-}
diff --git a/src/FlyStream/Exception/FileNotFoundException.php b/src/FlyStream/Exception/FileNotFoundException.php
deleted file mode 100644
index e36d1d1..0000000
--- a/src/FlyStream/Exception/FileNotFoundException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when File is Not Found.
- */
-class FileNotFoundException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'No such file or directory';
-
-}
diff --git a/src/FlyStream/Exception/InvalidStreamModeException.php b/src/FlyStream/Exception/InvalidStreamModeException.php
deleted file mode 100644
index 5f3c2a4..0000000
--- a/src/FlyStream/Exception/InvalidStreamModeException.php
+++ /dev/null
@@ -1,40 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-use League\Flysystem\FilesystemException;
-
-/**
- * Exception handler when stream mode is not valid.
- */
-class InvalidStreamModeException extends \RuntimeException implements FilesystemException {
-
-  /**
-   * Returns meta information for exception.
-   *
-   * @param string $command
-   *   Command triggering exception.
-   * @param string $location
-   *   Code location where exception was triggered.
-   * @param string $mode
-   *   File / Directory mode.
-   * @param \Throwable $previous
-   *   Previous exception.
-   *
-   * @return \Drupal\flysystem\FlyStream\Exception\InvalidStreamModeException
-   *   Exception thrown.
-   */
-  public static function atLocation(
-    string $command,
-    string $location,
-    string $mode,
-    \Throwable $previous = NULL,
-  ): InvalidStreamModeException {
-    return new self(
-      "$command($location): Failed to open stream: '$mode' is not a valid mode",
-      0,
-      $previous
-    );
-  }
-
-}
diff --git a/src/FlyStream/Exception/IsDirectoryException.php b/src/FlyStream/Exception/IsDirectoryException.php
deleted file mode 100644
index e397c4f..0000000
--- a/src/FlyStream/Exception/IsDirectoryException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when File is Not Found.
- */
-class IsDirectoryException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Is a directory';
-
-}
diff --git a/src/FlyStream/Exception/IsNotDirectoryException.php b/src/FlyStream/Exception/IsNotDirectoryException.php
deleted file mode 100644
index e8dfdf9..0000000
--- a/src/FlyStream/Exception/IsNotDirectoryException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when File is Not Found.
- */
-class IsNotDirectoryException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Not a directory';
-
-}
diff --git a/src/FlyStream/Exception/RootDirectoryException.php b/src/FlyStream/Exception/RootDirectoryException.php
deleted file mode 100644
index 687884f..0000000
--- a/src/FlyStream/Exception/RootDirectoryException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Directory is the root directory.
- */
-class RootDirectoryException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Directory is root';
-
-}
diff --git a/src/FlyStream/Exception/StatFailedException.php b/src/FlyStream/Exception/StatFailedException.php
deleted file mode 100644
index 5235778..0000000
--- a/src/FlyStream/Exception/StatFailedException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Directory is the root directory.
- */
-class StatFailedException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Stat failed';
-
-}
diff --git a/src/FlyStream/Exception/StreamWrapperException.php b/src/FlyStream/Exception/StreamWrapperException.php
deleted file mode 100644
index cd59eeb..0000000
--- a/src/FlyStream/Exception/StreamWrapperException.php
+++ /dev/null
@@ -1,34 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-use League\Flysystem\FilesystemException;
-
-/**
- * StreamWrapper exception handler.
- */
-class StreamWrapperException extends \RuntimeException implements FilesystemException {
-  protected const ERROR_MESSAGE = 'Error message not defined';
-
-  /**
-   * Returns meta information for exception.
-   *
-   * @param string $command
-   *   Command triggering exception.
-   * @param string $location
-   *   Code location where exception was triggered.
-   * @param \Throwable $previous
-   *   Previous exception.
-   *
-   * @return \Drupal\flysystem\FlyStream\Exception\StreamWrapperException
-   *   Exception thrown.
-   */
-  public static function atLocation(
-    string $command,
-    string $location,
-    \Throwable $previous = NULL,
-  ): StreamWrapperException {
-    return new self("$command($location): " . static::ERROR_MESSAGE, 0, $previous);
-  }
-
-}
diff --git a/src/FlyStream/Exception/UnableToChangePermissionsException.php b/src/FlyStream/Exception/UnableToChangePermissionsException.php
deleted file mode 100644
index 7417e9e..0000000
--- a/src/FlyStream/Exception/UnableToChangePermissionsException.php
+++ /dev/null
@@ -1,36 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-use League\Flysystem\FilesystemException;
-
-/**
- * Exception handler when Unable to change permissions.
- */
-class UnableToChangePermissionsException extends \RuntimeException implements FilesystemException {
-
-  /**
-   * Returns meta information for exception.
-   *
-   * @param string $command
-   *   Command triggering exception.
-   * @param string $location
-   *   Code location where exception was triggered.
-   * @param string $permission
-   *   File / Directory permission.
-   * @param \Throwable $previous
-   *   Previous exception.
-   *
-   * @return \Drupal\flysystem\FlyStream\Exception\UnableToChangePermissionsException
-   *   Exception thrown.
-   */
-  public static function atLocation(
-    string $command,
-    string $location,
-    string $permission,
-    \Throwable $previous = NULL,
-  ): UnableToChangePermissionsException {
-    return new self("$command($location,$permission): Unable to change permissions", 0, $previous);
-  }
-
-}
diff --git a/src/FlyStream/Exception/UnableToCreateDirectoryException.php b/src/FlyStream/Exception/UnableToCreateDirectoryException.php
deleted file mode 100644
index fda17a6..0000000
--- a/src/FlyStream/Exception/UnableToCreateDirectoryException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Directory cannot be created.
- */
-class UnableToCreateDirectoryException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Cannot create directory';
-
-}
diff --git a/src/FlyStream/Exception/UnableToReadException.php b/src/FlyStream/Exception/UnableToReadException.php
deleted file mode 100644
index 3403b6a..0000000
--- a/src/FlyStream/Exception/UnableToReadException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Unable to Read file.
- */
-class UnableToReadException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Unable to read file';
-
-}
diff --git a/src/FlyStream/Exception/UnableToWriteException.php b/src/FlyStream/Exception/UnableToWriteException.php
deleted file mode 100644
index b112edd..0000000
--- a/src/FlyStream/Exception/UnableToWriteException.php
+++ /dev/null
@@ -1,11 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream\Exception;
-
-/**
- * Exception handler when Unable to Write to file.
- */
-class UnableToWriteException extends StreamWrapperException {
-  protected const ERROR_MESSAGE = 'Unable to write to file';
-
-}
diff --git a/src/FlyStream/ExceptionHandlerTrait.php b/src/FlyStream/ExceptionHandlerTrait.php
deleted file mode 100644
index 8e080c7..0000000
--- a/src/FlyStream/ExceptionHandlerTrait.php
+++ /dev/null
@@ -1,46 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream;
-
-use League\Flysystem\FilesystemException;
-
-/**
- * ExceptionHandler trait for Stream Wrappers.
- */
-trait ExceptionHandlerTrait {
-
-  /**
-   * Triggers error handler.
-   *
-   * @param \League\Flysystem\FilesystemException $e
-   *   FilesystemException thrown by FilesystemOperator.
-   *
-   * @return bool
-   *   Returns a FALSE value after triggering error.
-   */
-  protected function triggerError(FilesystemException $e): bool {
-    trigger_error($this->collectErrorMessage($e), E_USER_WARNING);
-
-    return FALSE;
-  }
-
-  /**
-   * Collects the information abou the error message thrown in the exception.
-   *
-   * @param \Throwable $e
-   *   Throwable exception.
-   *
-   * @return string
-   *   Error message to return to handler.
-   */
-  protected function collectErrorMessage(\Throwable $e): string {
-    $message = $e->getMessage();
-    $previous = $e->getPrevious();
-    if (!$previous instanceof \Throwable) {
-      return $message;
-    }
-
-    return $message . ' : ' . $this->collectErrorMessage($previous);
-  }
-
-}
diff --git a/src/FlyStream/FlyStreamWrapper.php b/src/FlyStream/FlyStreamWrapper.php
deleted file mode 100644
index 4f618a8..0000000
--- a/src/FlyStream/FlyStreamWrapper.php
+++ /dev/null
@@ -1,98 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream;
-
-use Drupal\Core\StreamWrapper\StreamWrapperInterface;
-use Drupal\Core\StringTranslation\StringTranslationTrait;
-
-/**
- * FlyStream Stram Wrapper implementation.
- */
-class FlyStreamWrapper extends FlyStreamWrapperBase implements FlyStreamWrapperInterface, StreamWrapperInterface {
-
-  use StringTranslationTrait;
-
-  /**
-   * Instance URI (stream).
-   *
-   * A stream is referenced as "scheme://target".
-   *
-   * @var string
-   */
-  protected $uri;
-
-  /**
-   * StreamWrapper type.
-   *
-   * @var int
-   */
-  protected static $type = StreamWrapperInterface::NORMAL;
-
-  /**
-   * {@inheritdoc}
-   */
-  public static function getType() {
-    return self::$type;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getName() {
-    return $this->t("Flysystem Stream Wrapper: @scheme", ['@scheme' => $this->scheme]);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getDescription() {
-    return $this->t("Flysystem Stream Wrapper: @scheme", ['@scheme' => $this->scheme]);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getExternalUrl() {
-    return $this->uri;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function setUri($uri) {
-    $this->uri = $uri;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getUri() {
-    return $this->uri;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function realpath() {
-    return '';
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function dirname($uri = NULL): string {
-    if (!isset($uri)) {
-      $uri = $this->uri;
-    }
-
-    [$scheme, $target] = explode('://', $uri, 2);
-    $dirname = dirname($target);
-
-    if ($dirname == '.') {
-      $dirname = '';
-    }
-
-    return $scheme . '://' . $dirname;
-  }
-
-}
diff --git a/src/FlyStream/FlyStreamWrapperBase.php b/src/FlyStream/FlyStreamWrapperBase.php
deleted file mode 100644
index d652465..0000000
--- a/src/FlyStream/FlyStreamWrapperBase.php
+++ /dev/null
@@ -1,1075 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream;
-
-use Drupal\Core\Config\CachedStorage;
-use Drupal\Core\StreamWrapper\PhpStreamWrapperInterface;
-use Drupal\flysystem\FlyStream\Exception\CouldNotDeleteFileException;
-use Drupal\flysystem\FlyStream\Exception\CouldNotRemoveDirectoryException;
-use Drupal\flysystem\FlyStream\Exception\DirectoryExistsException;
-use Drupal\flysystem\FlyStream\Exception\DirectoryNotEmptyException;
-use Drupal\flysystem\FlyStream\Exception\DirectoryNotFoundException;
-use Drupal\flysystem\FlyStream\Exception\FileNotFoundException;
-use Drupal\flysystem\FlyStream\Exception\InvalidStreamModeException;
-use Drupal\flysystem\FlyStream\Exception\IsDirectoryException;
-use Drupal\flysystem\FlyStream\Exception\IsNotDirectoryException;
-use Drupal\flysystem\FlyStream\Exception\RootDirectoryException;
-use Drupal\flysystem\FlyStream\Exception\StatFailedException;
-use Drupal\flysystem\FlyStream\Exception\UnableToChangePermissionsException;
-use Drupal\flysystem\FlyStream\Exception\UnableToCreateDirectoryException;
-use Drupal\flysystem\FlyStream\Exception\UnableToReadException;
-use Drupal\flysystem\FlyStream\Exception\UnableToWriteException;
-use League\Flysystem\Config;
-use League\Flysystem\Filesystem;
-use League\Flysystem\FilesystemException;
-use League\Flysystem\StorageAttributes;
-use League\Flysystem\UnableToRetrieveMetadata;
-use League\Flysystem\UnixVisibility\PortableVisibilityConverter;
-use League\Flysystem\Visibility;
-use League\Flysystem\WhitespacePathNormalizer;
-use Symfony\Component\Lock\Key;
-use Symfony\Component\Lock\Lock;
-use Symfony\Component\Lock\Store\StoreFactory;
-
-/**
- * FlyStreamWrapper class, stream wrapper base for Flysystem Drupal module.
- */
-class FlyStreamWrapperBase implements PhpStreamWrapperInterface, FlyStreamWrapperInterface {
-
-  use ExceptionHandlerTrait;
-
-  /**
-   * Config Storage service.
-   *
-   * @var \Drupal\Core\Config\CachedStorage
-   */
-  protected $configStorage;
-  /**
-   * Configuration file name.
-   *
-   * @var string|null
-   */
-  protected $configuration;
-
-  /**
-   * File permission mode.
-   *
-   * @var string|null
-   */
-  protected $mode = NULL;
-
-  /**
-   * Directory listing.
-   *
-   * @var \Iterator|\IteratorAggregate|\Traversable|null
-   */
-  protected $dir = NULL;
-
-  /**
-   * Resource context.
-   *
-   * @var resource
-   */
-  public $context;
-
-  /**
-   * Directory Listing contents.
-   *
-   * @var \Iterator<mixed,\League\Flysystem\StorageAttributes>
-   */
-  public $dirListing;
-
-  /**
-   * File directory path.
-   *
-   * @var string
-   */
-  public $path;
-
-  /**
-   * Wrapper scheme.
-   *
-   * @var string
-   */
-  protected $scheme;
-
-  /**
-   * File path.
-   *
-   * @var string
-   */
-  public $file;
-
-  /**
-   * Flysystem Filesystem instance.
-   *
-   * @var \League\Flysystem\FilesystemOperator
-   */
-  public $filesystem;
-
-  /**
-   * Configuration data.
-   *
-   * @var array<string, int|string|bool|null>
-   */
-  public $config = [];
-
-  /**
-   * Work on Local Copy setting.
-   *
-   * @var bool
-   */
-  public $workOnLocalCopy = FALSE;
-
-  /**
-   * Bytes written to stream.
-   *
-   * @var int
-   */
-  public $bytesWritten = 0;
-
-  /**
-   * Lock Key setting.
-   *
-   * @var \Symfony\Component\Lock\Key
-   */
-  public $lockKey;
-
-  /**
-   * Write only setting.
-   *
-   * @var bool
-   */
-  public $writeOnly = FALSE;
-
-  /**
-   * Always Append setting.
-   *
-   * @var bool
-   */
-  public $alwaysAppend = FALSE;
-
-  /**
-   * Write Buffer Size.
-   *
-   * @var int
-   */
-  public $writeBufferSize = 0;
-
-  /**
-   * Resource handle.
-   *
-   * @var resource|false
-   */
-  public $handle = FALSE;
-
-  /**
-   * Adapter Factory options.
-   *
-   * @var array|null
-   */
-  public $options = NULL;
-
-  /**
-   * Class constructor.
-   *
-   * @param string $configuration
-   *   Name of configuration file for adapter.
-   * @param \Drupal\Core\Config\CachedStorage $config_storage
-   *   Config Storage service.
-   */
-  public function __construct(string $configuration, CachedStorage $config_storage) {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    \Drupal::logger('FlyStreamWrapper')->notice('Configuration: ' . $configuration);
-    \Drupal::logger('FlyStreamWrapper')->notice('config.storage ' . isset($config_storage));
-
-    $this->configuration = $configuration;
-    $this->configStorage = $config_storage;
-
-    $config = $this->configStorage->read($configuration);
-
-    $adapterClass = new \ReflectionClass($config['sub_adapter_config']['plugin_adapter_class']);
-
-    $adapterFactory = $adapterClass->newInstance();
-
-    $adapterFactoryInstance = $adapterFactory::create($config['sub_adapter_config']);
-
-    $this->options = $adapterFactoryInstance['options'];
-    $this->filesystem = new Filesystem($adapterFactoryInstance['adapter']);
-
-  }
-
-  // phpcs:disable Drupal.NamingConventions.ValidFunctionName.ScopeNotCamelCaps
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function dir_closedir(): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    unset($this->dirListing);
-    return TRUE;
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function dir_opendir($path, $options): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $this->setPath($path);
-    try {
-      $listing = $this->filesystem->listContents($this->file)->getIterator();
-      $this->dirListing = ($listing instanceof \Iterator) ? $listing : new \IteratorIterator($listing);
-    }
-    catch (FilesystemException $e) {
-      return $this->triggerError(
-        DirectoryNotFoundException::atLocation(__METHOD__, $path, $e)
-      );
-    }
-
-    $valid = @is_dir($path);
-    if (!$valid) {
-      return self::triggerError(
-        DirectoryNotFoundException::atLocation(__METHOD__, $path)
-      );
-    }
-
-    return TRUE;
-
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function dir_readdir(): string|bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!$this->dirListing->valid()) {
-      return FALSE;
-    }
-
-    $item = $this->dirListing->current();
-
-    $this->dirListing->next();
-
-    return basename($item->path());
-
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function dir_rewinddir(): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    try {
-      $listing = $this->filesystem->listContents($this->file)->getIterator();
-      $this->dirListing = ($listing instanceof \Iterator) ? $listing : new \IteratorIterator($listing);
-    }
-    catch (FilesystemException $e) {
-      return self::triggerError($e);
-    }
-
-    return TRUE;
-
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function mkdir($path, $mode, $options): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (file_exists($path)) {
-      return self::triggerError(DirectoryExistsException::atLocation(__METHOD__, $path));
-    }
-
-    $this->setPath($path);
-
-    try {
-      $visibility = new PortableVisibilityConverter();
-      $config = [
-        Config::OPTION_VISIBILITY => $visibility->inverseForDirectory($mode),
-      ];
-      $this->filesystem->createDirectory($this->file, $config);
-
-      return TRUE;
-    }
-    catch (FilesystemException $e) {
-      return self::triggerError(
-        UnableToCreateDirectoryException::atLocation(__METHOD__, $path, $e)
-      );
-    }
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function rename($path_from, $path_to): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $this->setPath($path_from);
-    $errorLocation = $path_from . ',' . $path_to;
-    if (!file_exists($path_from)) {
-      return self::triggerError(FileNotFoundException::atLocation(__METHOD__, $errorLocation));
-    }
-
-    if (file_exists($path_to)) {
-      if (is_file($path_from) && is_dir($path_to)) {
-        return self::triggerError(
-          IsDirectoryException::atLocation(__METHOD__, $errorLocation)
-        );
-      }
-      if (is_dir($path_from) && is_file($path_to)) {
-        return self::triggerError(
-          IsNotDirectoryException::atLocation(__METHOD__, $errorLocation)
-        );
-      }
-    }
-
-    try {
-      $this->filesystem->move($this->file, $this->getFile($path_to));
-      return TRUE;
-    }
-    catch (FilesystemException $e) {
-      return self::triggerError(
-        DirectoryNotEmptyException::atLocation(__METHOD__, $errorLocation, $e)
-      );
-    }
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function rmdir($path, $options): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $this->setPath($path);
-
-    $n = new WhitespacePathNormalizer();
-    $n->normalizePath($this->file);
-    if ('' === $n->normalizePath($this->file)) {
-      return self::triggerError(
-        RootDirectoryException::atLocation(__METHOD__, $this->path)
-      );
-    }
-
-    if (($options & STREAM_MKDIR_RECURSIVE) !== 0) {
-      try {
-        $this->filesystem->deleteDirectory($this->file);
-        return TRUE;
-      }
-      catch (FilesystemException $e) {
-        return self::triggerError(
-          CouldNotRemoveDirectoryException::atLocation(__METHOD__, $this->path, $e)
-        );
-      }
-    }
-
-    try {
-      $listing = $this->filesystem->listContents($this->file);
-    }
-    catch (FilesystemException $e) {
-      return self::triggerError(
-        DirectoryNotEmptyException::atLocation(__METHOD__, $this->path)
-      );
-    }
-
-    foreach ($listing as $ignored) {
-      if (!$ignored instanceof StorageAttributes) {
-        continue;
-      }
-
-      return self::triggerError(
-        DirectoryNotEmptyException::atLocation(__METHOD__, $this->path)
-      );
-    }
-
-    try {
-      $this->filesystem->deleteDirectory($this->file);
-      return TRUE;
-    }
-    catch (FilesystemException $e) {
-      return self::triggerError(
-        CouldNotRemoveDirectoryException::atLocation(__METHOD__, $this->path, $e)
-      );
-    }
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function stream_cast($cast_as) {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    return $this->handle;
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function stream_close(): void {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!is_resource($this->handle)) {
-      return;
-    }
-
-    if ($this->workOnLocalCopy) {
-      fflush($this->handle);
-      rewind($this->handle);
-
-      try {
-        $this->filesystem->writeStream($this->file, $this->handle);
-      }
-      catch (FilesystemException $e) {
-        trigger_error(
-          'stream_close(' . $this->path . ') Unable to sync file : ' . $e->getMessage(),
-          E_USER_WARNING
-        );
-      }
-    }
-    fclose($this->handle);
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function stream_eof(): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!is_resource($this->handle)) {
-      return FALSE;
-    }
-
-    return feof($this->handle);
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function stream_flush(): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!is_resource($this->handle)) {
-      trigger_error(
-        'stream_flush(): Supplied resource is not a valid stream resource',
-        E_USER_WARNING
-      );
-
-      return FALSE;
-    }
-
-    $success = fflush($this->handle);
-
-    if ($this->workOnLocalCopy) {
-      fflush($this->handle);
-      $currentPosition = ftell($this->handle);
-      rewind($this->handle);
-
-      try {
-        $this->filesystem->writeStream($this->file, $this->handle);
-      }
-      catch (FilesystemException $e) {
-        trigger_error(
-          'stream_flush(' . $this->path . ') Unable to sync file : ' . $e->getMessage(),
-          E_USER_WARNING
-        );
-        $success = FALSE;
-      }
-
-      if (FALSE !== $currentPosition) {
-        if (is_resource($this->handle)) {
-          fseek($this->handle, $currentPosition);
-        }
-      }
-    }
-
-    $this->bytesWritten = 0;
-
-    return $success;
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo In progress
-   */
-  public function stream_lock($operation): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (NULL === $this->lockKey) {
-      $this->lockKey = new Key($this->path);
-    }
-
-    $store = StoreFactory::createStore((string) $this->config[FlyStreamWrapperInterface::LOCK_STORE]);
-    $lock = new Lock(
-      $this->lockKey,
-      $store,
-      (float) $this->config[FlyStreamWrapperInterface::LOCK_TTL],
-      FALSE
-    );
-
-    switch ($operation) {
-      case LOCK_SH:
-        return $lock->acquireRead(TRUE);
-
-      case LOCK_EX:
-        return $lock->acquire(TRUE);
-
-      case LOCK_UN:
-        $lock->release();
-        return TRUE;
-
-      case LOCK_SH | LOCK_NB:
-        return $lock->acquireRead();
-
-      case LOCK_EX | LOCK_NB:
-        return $lock->acquire();
-    }
-
-    return FALSE;
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function stream_metadata($path, $option, $value): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $this->setPath($path);
-    $filesystem = $this->filesystem;
-    $file = $this->file;
-    $converter = $this->options['visibility'] ?? new PortableVisibilityConverter();
-    switch ($option) {
-      case STREAM_META_ACCESS:
-        if (!is_int($value)) {
-          $value = (int) $value;
-        }
-        $visibility = is_dir($path) ? $converter->inverseForDirectory($value) : $converter->inverseForFile($value);
-
-        try {
-          $filesystem->setVisibility($file, $visibility);
-        }
-        catch (FilesystemException $e) {
-          if (!$this->ignoreVisibilityErrors()) {
-            return self::triggerError(UnableToChangePermissionsException::atLocation(
-              __METHOD__,
-              $this->path,
-              decoct($value),
-              $e
-            ));
-          }
-        }
-        return TRUE;
-
-      case STREAM_META_TOUCH:
-        try {
-          if (!$filesystem->fileExists($file)) {
-            $filesystem->write($file, '');
-          }
-        }
-        catch (FilesystemException $e) {
-          return self::triggerError(UnableToWriteException::atLocation(
-            __METHOD__,
-            $this->path,
-            $e
-          ));
-        }
-
-        return TRUE;
-
-      default:
-        return FALSE;
-    }
-
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo Done
-   */
-  public function stream_open($path, $mode, $options, &$openedPath = NULL): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $this->setPath($path);
-    $filesystem = $this->filesystem;
-    $file = $this->file;
-
-    if (!preg_match('/^[rwacx](\+b?|b\+?)?$/', $mode)) {
-      return self::triggerError(InvalidStreamModeException::atLocation(
-        __METHOD__,
-        $this->path,
-        $mode
-      ));
-    }
-
-    $this->writeOnly = !strpos($mode, '+');
-    try {
-      if ('r' === $mode[0] && $this->writeOnly) {
-        $this->handle = $filesystem->readStream($file);
-        $this->workOnLocalCopy = FALSE;
-        $this->writeOnly = FALSE;
-      }
-      else {
-        $this->handle = fopen('php://temp', 'w+b');
-        $this->workOnLocalCopy = TRUE;
-
-        if ('w' !== $mode[0] && $filesystem->fileExists($file)) {
-          if ('x' === $mode[0]) {
-            throw UnableToWriteException::atLocation(__METHOD__, $this->path);
-          }
-
-          $result = FALSE;
-          if (is_resource($this->handle)) {
-            $result = stream_copy_to_stream($filesystem->readStream($file), $this->handle);
-          }
-          if (!$result) {
-            throw UnableToWriteException::atLocation(__METHOD__, $this->path);
-          }
-        }
-      }
-
-      $this->alwaysAppend = 'a' === $mode[0];
-      if (is_resource($this->handle) && !$this->alwaysAppend) {
-        @rewind($this->handle);
-      }
-    }
-    catch (FilesystemException $e) {
-      if (($options & STREAM_REPORT_ERRORS) !== 0) {
-        return self::triggerError(UnableToReadException::atLocation(
-          __METHOD__,
-          $this->path,
-          $e
-        ));
-      }
-      return FALSE;
-    }
-
-    if ($this->handle && $options & STREAM_USE_PATH) {
-      $openedPath = $path;
-    }
-
-    if (is_resource($this->handle)) {
-      return TRUE;
-    }
-
-    if (($options & STREAM_REPORT_ERRORS) !== 0) {
-      return self::triggerError(FileNotFoundException::atLocation(__METHOD__, $this->path));
-    }
-
-    return FALSE;
-  }
-
-  /**
-   * {@inheritdoc}
-   *
-   * @todo DONE
-   */
-  public function stream_read($count): string {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if ($this->writeOnly || !is_resource($this->handle) || $count < 0) {
-      return '';
-    }
-
-    return (string) fread($this->handle, $count);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function stream_seek($offset, $whence = SEEK_SET): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!is_resource($this->handle)) {
-      return FALSE;
-    }
-
-    return 0 === fseek($this->handle, $offset, $whence);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function stream_set_option($option, $arg1, $arg2 = NULL): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!is_resource($this->handle)) {
-      return FALSE;
-    }
-
-    switch ($option) {
-      case STREAM_OPTION_BLOCKING:
-        return stream_set_blocking($this->handle, 1 === $arg1);
-
-      case STREAM_OPTION_READ_BUFFER:
-        return 0 === stream_set_read_buffer(
-          $this->handle,
-            STREAM_BUFFER_NONE === $arg1 ? 0 : (int) $arg2
-          );
-
-      case STREAM_OPTION_WRITE_BUFFER:
-        $this->writeBufferSize = STREAM_BUFFER_NONE === $arg1 ? 0 : (int) $arg2;
-
-        return TRUE;
-
-      case STREAM_OPTION_READ_TIMEOUT:
-        return stream_set_timeout($this->handle, $arg1, (int) $arg2);
-    }
-
-    return FALSE;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function stream_stat(): array|false {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    try {
-      return $this->getStat();
-    }
-    catch (FilesystemException $e) {
-      self::triggerError(StatFailedException::atLocation(__METHOD__, $this->path, $e));
-
-      return FALSE;
-    }
-
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function stream_tell(): int {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!is_resource($this->handle)) {
-      return 0;
-    }
-
-    if ($this->alwaysAppend && $this->writeOnly) {
-      return 0;
-    }
-
-    return (int) ftell($this->handle);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function stream_truncate($new_size): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!is_resource($this->handle) || $new_size < 0) {
-      return FALSE;
-    }
-
-    return ftruncate($this->handle, $new_size);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function stream_write($data): int|false {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!is_resource($this->handle)) {
-      return 0;
-    }
-
-    if ($this->alwaysAppend) {
-      fseek($this->handle, 0, SEEK_END);
-    }
-
-    $size = (int) fwrite($this->handle, $data);
-    $this->bytesWritten += $size;
-
-    if ($this->alwaysAppend) {
-      fseek($this->handle, 0, SEEK_SET);
-    }
-
-    return $size;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function unlink($path): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $this->setPath($path);
-
-    if (!file_exists($this->path)) {
-      return self::triggerError(FileNotFoundException::atLocation(__METHOD__, $this->path));
-    }
-
-    try {
-      $this->filesystem->delete($this->file);
-      return TRUE;
-    }
-    catch (FilesystemException $e) {
-      return self::triggerError(
-        CouldNotDeleteFileException::atLocation(__METHOD__, $this->path, $e)
-          );
-    }
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function url_stat($path, $flags): array|false {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $this->setPath($path);
-
-    try {
-      return $this->getStat();
-    }
-    catch (FilesystemException $e) {
-      if (($flags & STREAM_URL_STAT_QUIET) !== 0) {
-        return FALSE;
-      }
-
-      self::triggerError(StatFailedException::atLocation(__METHOD__, $path, $e));
-
-      return FALSE;
-    }
-  }
-
-  // phpcs:enable
-
-  /**
-   * Get file, directory, or resource stat.
-   *
-   * @return array<int|string,int|string>|false
-   *   Requested stat, or FALSE if it doesn't exist.
-   *
-   * @throws \League\Flysystem\FilesystemException
-   */
-  protected function getStat() {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $stats = [];
-
-    if ($this->workOnLocalCopy && is_resource($this->handle)) {
-      $stats = fstat($this->handle);
-      if (!$stats) {
-        return FALSE;
-      }
-      if ($this->filesystem->fileExists($this->file)) {
-        [$mode, $size, $time] = $this->getRemoteStats();
-
-        unset($size);
-      }
-    }
-    else {
-      [$mode, $size, $time] = $this->getRemoteStats();
-    }
-
-    foreach (self::STATS_ZERO as $key) {
-      $stats[$key] = 0;
-    }
-
-    foreach (self::STATS_MINUS_ONE as $key) {
-      $stats[$key] = -1;
-    }
-
-    if (isset($mode)) {
-      foreach (self::STATS_MODE as $key) {
-        $stats[$key] = $mode;
-      }
-    }
-
-    if (isset($size)) {
-      foreach (self::STATS_SIZE as $key) {
-        $stats[$key] = $size;
-      }
-    }
-
-    if (isset($time)) {
-      foreach (self::STATS_TIME as $key) {
-        $stats[$key] = $time;
-      }
-    }
-
-    $stats['uid'] = $stats[4] = (int) $this->config[FlyStreamWrapperInterface::UID];
-    $stats['gid'] = $stats[5] = (int) $this->config[FlyStreamWrapperInterface::GID];
-
-    return $stats;
-  }
-
-  /**
-   * Gets stats from remote resource.
-   *
-   * @throws \League\Flysystem\FilesystemException
-   *
-   * @return array<int,int>
-   *   Requested stats.
-   */
-  protected function getRemoteStats(): array {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $newConverter = new PortableVisibilityConverter(
-      (int) $this->config[FlyStreamWrapperInterface::VISIBILITY_FILE_PUBLIC],
-      (int) $this->config[FlyStreamWrapperInterface::VISIBILITY_FILE_PRIVATE],
-      (int) $this->config[FlyStreamWrapperInterface::VISIBILITY_DIRECTORY_PUBLIC],
-      (int) $this->config[FlyStreamWrapperInterface::VISIBILITY_DIRECTORY_PRIVATE],
-      (string) $this->config[FlyStreamWrapperInterface::VISIBILITY_DEFAULT_FOR_DIRECTORIES]
-    );
-
-    $converter = $this->options['visibility'] ?? $newConverter;
-    try {
-      $visibility = $this->filesystem->visibility($this->file);
-    }
-    catch (UnableToRetrieveMetadata | \TypeError $e) {
-      if (!$this->ignoreVisibilityErrors()) {
-        throw $e;
-      }
-
-      $visibility = Visibility::PUBLIC;
-    }
-
-    $mode = 0;
-    $size = 0;
-    $lastModified = 0;
-
-    try {
-      if ('directory' === $this->filesystem->mimeType($this->file)) {
-        [$mode, $size, $lastModified] = $this->getRemoteDirectoryStats($converter, $visibility);
-      }
-      else {
-        [$mode, $size, $lastModified] = $this->getRemoteFileStats($converter, $visibility);
-      }
-    }
-    catch (UnableToRetrieveMetadata $e) {
-      if (method_exists($this->filesystem, 'directoryExists')) {
-        if ($this->filesystem->directoryExists($this->file)) {
-          [$mode, $size, $lastModified] = $this->getRemoteDirectoryStats($converter, $visibility);
-        }
-        elseif ($this->filesystem->fileExists($this->file)) {
-          [$mode, $size, $lastModified] = $this->getRemoteFileStats($converter, $visibility);
-        }
-      }
-      else {
-        throw $e;
-      }
-    }
-
-    return [$mode, $size, $lastModified];
-  }
-
-  /**
-   * Get stats for Remote Directory.
-   *
-   * @return array<int, int>
-   *   Requested stats.
-   *
-   * @throws \League\Flysystem\FilesystemException
-   */
-  private function getRemoteDirectoryStats(
-    PortableVisibilityConverter $converter,
-    string $visibility,
-  ): array {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $mode = 040000 + $converter->forDirectory($visibility);
-    $size = 0;
-    $lastModified = $this->getRemoteDirectoryLastModified();
-    return [$mode, $size, $lastModified];
-  }
-
-  /**
-   * Get stats for remote file.
-   *
-   * @return array<int, int>
-   *   Requested stats.
-   *
-   * @throws \League\Flysystem\FilesystemException
-   */
-  private function getRemoteFileStats(
-    PortableVisibilityConverter $converter,
-    string $visibility,
-  ): array {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    $mode = 0100000 + $converter->forFile($visibility);
-    $size = $this->filesystem->fileSize($this->file);
-    $lastModified = $this->filesystem->lastModified($this->file);
-    return [$mode, $size, $lastModified];
-  }
-
-  /**
-   * Gets Last Modified stat for remote directory.
-   *
-   * @return int
-   *   Last modified stat.
-   *
-   * @throws \League\Flysystem\FilesystemException
-   */
-  private function getRemoteDirectoryLastModified(): int {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    if (!$this->emulateDirectoryLastModified()) {
-      return $this->filesystem->lastModified($this->file);
-    }
-
-    $lastModified = 0;
-    $listing = $this->filesystem->listContents($this->file)->getIterator();
-    $dirListing = $listing instanceof \Iterator ? $listing : new \IteratorIterator($listing);
-
-    /** @var \League\Flysystem\FileAttributes $item */
-    foreach ($dirListing as $item) {
-      $lastModified = max($lastModified, $item->lastModified());
-    }
-    return $lastModified;
-  }
-
-  /**
-   * Get the file path.
-   *
-   * @param string $path
-   *   File path.
-   *
-   * @return string
-   *   File path converted.
-   */
-  private function getFile(string $path): string {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    return (string) substr($path, strpos($path, '://') + 3);
-  }
-
-  /**
-   * Configures settings based on path.
-   *
-   * @param string $path
-   *   File path.
-   */
-  private function setPath(string $path): void {
-    $this->path = $path;
-    $this->scheme = substr($path, 0, (int) strpos($path, '://'));
-    $this->file = $this->getFile($path);
-  }
-
-  /**
-   * Gets Emulate Directory Last Modified settings.
-   *
-   * @return bool
-   *   Boolean setting.
-   */
-  private function emulateDirectoryLastModified(): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    // @refactor??
-    return (bool) $this->config[FlyStreamWrapper::EMULATE_DIRECTORY_LAST_MODIFIED];
-  }
-
-  /**
-   * Gets Ignore Visibility Errors settings.
-   *
-   * @return bool
-   *   Boolean setting.
-   */
-  private function ignoreVisibilityErrors(): bool {
-    \Drupal::logger('FlyStreamWrapper')->notice('Calling ' . __METHOD__);
-    return (bool) $this->config[FlyStreamWrapper::IGNORE_VISIBILITY_ERRORS];
-  }
-
-}
diff --git a/src/FlyStream/FlyStreamWrapperInterface.php b/src/FlyStream/FlyStreamWrapperInterface.php
deleted file mode 100644
index 0b45566..0000000
--- a/src/FlyStream/FlyStreamWrapperInterface.php
+++ /dev/null
@@ -1,53 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\FlyStream;
-
-use League\Flysystem\Visibility;
-
-/**
- * Interface for FlyStream stream wrappers.
- */
-interface FlyStreamWrapperInterface {
-
-  public const LOCK_STORE = 'lock_store';
-  public const LOCK_TTL = 'lock_ttl';
-
-  public const IGNORE_VISIBILITY_ERRORS = 'ignore_visibility_errors';
-
-  public const EMULATE_DIRECTORY_LAST_MODIFIED = 'emulate_directory_last_modified';
-
-  public const UID = 'uid';
-  public const GID = 'gid';
-
-  public const VISIBILITY_FILE_PUBLIC = 'visibility_file_public';
-  public const VISIBILITY_FILE_PRIVATE = 'visibility_file_private';
-  public const VISIBILITY_DIRECTORY_PUBLIC = 'visibility_directory_public';
-  public const VISIBILITY_DIRECTORY_PRIVATE = 'visibility_directory_private';
-  public const VISIBILITY_DEFAULT_FOR_DIRECTORIES = 'visibility_default_for_directories';
-
-  public const DEFAULT_CONFIGURATION = [
-    // Const LOCK_STORE.
-    self::LOCK_STORE => 'flock:///tmp',
-    // Const LOCK_TTL.
-    self::LOCK_TTL => 300,
-    // Const IGNORE_VISIBILITY_ERRORS.
-    self::IGNORE_VISIBILITY_ERRORS => FALSE,
-    self::EMULATE_DIRECTORY_LAST_MODIFIED => FALSE,
-
-    self::UID => NULL,
-    self::GID => NULL,
-
-    self::VISIBILITY_FILE_PUBLIC => 0644,
-    self::VISIBILITY_FILE_PRIVATE => 0600,
-    self::VISIBILITY_DIRECTORY_PUBLIC => 0755,
-    self::VISIBILITY_DIRECTORY_PRIVATE => 0700,
-    self::VISIBILITY_DEFAULT_FOR_DIRECTORIES => Visibility::PRIVATE,
-  ];
-
-  public const STATS_ZERO = [0, 'dev', 1, 'ino', 3, 'nlink', 6, 'rdev'];
-  public const STATS_MODE = [2, 'mode'];
-  public const STATS_SIZE = [7, 'size'];
-  public const STATS_TIME = [8, 'atime', 9, 'mtime', 10, 'ctime'];
-  public const STATS_MINUS_ONE = [11, 'blksize', 12, 'blocks'];
-
-}
diff --git a/src/Flysystem/Adapter/CacheItem.php b/src/Flysystem/Adapter/CacheItem.php
new file mode 100644
index 0000000..4a2ea11
--- /dev/null
+++ b/src/Flysystem/Adapter/CacheItem.php
@@ -0,0 +1,45 @@
+<?php
+
+namespace Drupal\flysystem\Flysystem\Adapter;
+
+/**
+ * A filesystem item stored in the Drupal cache.
+ */
+class CacheItem {
+
+  /**
+   * The array of metadata for the item.
+   *
+   * @var array
+   */
+  protected $metadata = [];
+
+  /**
+   * Returns the metadata for the item.
+   *
+   * @return array
+   *   The array of metadata for the item.
+   */
+  public function getMetadata() {
+    return $this->metadata;
+  }
+
+  /**
+   * Updates the metadata for the item.
+   *
+   * @param array $metadata
+   *   The array of metadata for the item.
+   */
+  public function updateMetadata(array $metadata) {
+    static $keys = [
+      'size' => TRUE,
+      'mimetype' => TRUE,
+      'visibility' => TRUE,
+      'timestamp' => TRUE,
+      'type' => TRUE,
+    ];
+
+    $this->metadata = array_intersect_key($metadata, $keys) + $this->metadata;
+  }
+
+}
diff --git a/src/Flysystem/Adapter/CacheItemBackend.php b/src/Flysystem/Adapter/CacheItemBackend.php
new file mode 100644
index 0000000..da12e1c
--- /dev/null
+++ b/src/Flysystem/Adapter/CacheItemBackend.php
@@ -0,0 +1,129 @@
+<?php
+
+namespace Drupal\flysystem\Flysystem\Adapter;
+
+use Drupal\Component\Utility\Crypt;
+use Drupal\Core\Cache\CacheBackendInterface;
+
+/**
+ * Storage backend for cache items.
+ *
+ * This class is separated out from CacheItems so we can easily test loading,
+ * saving, and deleting separately from the logic to reach back to a child
+ * Flysystem adapter.
+ */
+class CacheItemBackend {
+
+  /**
+   * The Drupal cache backend to store data in.
+   *
+   * @var \Drupal\Core\Cache\CacheBackendInterface
+   */
+  protected $cacheBackend;
+
+  /**
+   * The scheme this cache is managing.
+   *
+   * @var string
+   */
+  protected $scheme;
+
+  /**
+   * Constructs a new CacheItemBackend.
+   *
+   * @param string $scheme
+   *   The scheme being managed by the cache.
+   * @param \Drupal\Core\Cache\CacheBackendInterface $cacheBackend
+   *   The Drupal cache backend to store items in.
+   */
+  public function __construct($scheme, CacheBackendInterface $cacheBackend) {
+    $this->scheme = $scheme;
+    $this->cacheBackend = $cacheBackend;
+  }
+
+  /**
+   * Returns whether the cache item exists.
+   *
+   * @param string $path
+   *   The path of the cache item.
+   *
+   * @return bool
+   *   True if the item exists, false if not.
+   */
+  public function has($path) {
+    return (bool) $this->cacheBackend->get($this->getCacheKey($path));
+  }
+
+  /**
+   * Loads a cache item for a given path.
+   *
+   * @param string $path
+   *   The path of the item to load.
+   *
+   * @return \Drupal\flysystem\Flysystem\Adapter\CacheItem
+   *   The cache item, or a new cache item if one isn't in the cache.
+   */
+  public function load($path) {
+    $key = $this->getCacheKey($path);
+
+    if ($cached = $this->cacheBackend->get($key)) {
+      /** @var \Drupal\flysystem\Flysystem\Adapter\CacheItem $item */
+      $item = $cached->data;
+    }
+    else {
+      $item = new CacheItem();
+    }
+
+    return $item;
+  }
+
+  /**
+   * Sets a cache item in the backend.
+   *
+   * @param string $path
+   *   The file path.
+   * @param \Drupal\flysystem\Flysystem\Adapter\CacheItem $item
+   *   The item to set.
+   */
+  public function set($path, CacheItem $item) {
+    $this->cacheBackend->set($this->getCacheKey($path), $item);
+  }
+
+  /**
+   * Deletes an item by the path.
+   *
+   * @param string $path
+   *   The path of the item to delete.
+   */
+  public function delete($path) {
+    $this->deleteMultiple([$path]);
+  }
+
+  /**
+   * Deletes multiple paths.
+   *
+   * @param array $paths
+   *   The array of paths to delete.
+   */
+  public function deleteMultiple(array $paths) {
+    $keys = [];
+    foreach ($paths as $path) {
+      $keys[] = $this->getCacheKey($path);
+    }
+    $this->cacheBackend->deleteMultiple($keys);
+  }
+
+  /**
+   * Gets the cache key for a cache item.
+   *
+   * @param string $path
+   *   The path of the cache item.
+   *
+   * @return string
+   *   A hashed key suitable for use in a cache.
+   */
+  protected function getCacheKey($path) {
+    return Crypt::hashBase64($this->scheme . '://' . $path);
+  }
+
+}
diff --git a/src/Flysystem/Adapter/DrupalCacheAdapter.php b/src/Flysystem/Adapter/DrupalCacheAdapter.php
new file mode 100644
index 0000000..63ce0db
--- /dev/null
+++ b/src/Flysystem/Adapter/DrupalCacheAdapter.php
@@ -0,0 +1,298 @@
+<?php
+
+namespace Drupal\flysystem\Flysystem\Adapter;
+
+use League\Flysystem\AdapterInterface;
+use League\Flysystem\Config;
+
+/**
+ * A Flysystem adapter implementing caching with Drupal's Cache API.
+ */
+class DrupalCacheAdapter implements AdapterInterface {
+
+  /**
+   * The Flysystem adapter to cache data for.
+   *
+   * @var \League\Flysystem\AdapterInterface
+   */
+  protected $adapter;
+
+  /**
+   * The cache backend to store data in.
+   *
+   * @var \Drupal\flysystem\Flysystem\Adapter\CacheItemBackend
+   */
+  protected $cacheItemBackend;
+
+  /**
+   * The scheme of the stream wrapper used for this adapter.
+   *
+   * @var string
+   */
+  protected $scheme;
+
+  /**
+   * Constructs a new caching Flysystem adapter.
+   *
+   * @param string $scheme
+   *   The scheme of the stream wrapper used for this adapter.
+   * @param \League\Flysystem\AdapterInterface $adapter
+   *   The flysystem adapter to cache data for.
+   * @param \Drupal\flysystem\Flysystem\Adapter\CacheItemBackend $cacheItemBackend
+   *   The cache backend to store data in.
+   */
+  public function __construct($scheme, AdapterInterface $adapter, CacheItemBackend $cacheItemBackend) {
+    $this->scheme = $scheme;
+    $this->adapter = $adapter;
+    $this->cacheItemBackend = $cacheItemBackend;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function write($path, $contents, Config $config): array|false {
+    $metadata = $this->adapter->write($path, $contents, $config);
+
+    return $this->updateMetadata($path, $metadata);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function writeStream($path, $resource, Config $config): array|false {
+    $metadata = $this->adapter->writeStream($path, $resource, $config);
+
+    return $this->updateMetadata($path, $metadata);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function update($path, $contents, Config $config): array|false {
+    $metadata = $this->adapter->update($path, $contents, $config);
+
+    return $this->updateMetadata($path, $metadata);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function updateStream($path, $resource, Config $config): array|false {
+    $metadata = $this->adapter->updateStream($path, $resource, $config);
+
+    return $this->updateMetadata($path, $metadata);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rename($path, $newPath): bool {
+    $result = $this->adapter->rename($path, $newPath);
+
+    if ($result) {
+      $item = $this->cacheItemBackend->load($path);
+      $newItem = clone $item;
+      $this->cacheItemBackend->set($newPath, $newItem);
+      $this->cacheItemBackend->delete($path);
+    }
+
+    return $result;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function copy($path, $newPath): bool {
+    $result = $this->adapter->copy($path, $newPath);
+
+    if ($result) {
+      $item = $this->cacheItemBackend->load($path);
+      $newItem = clone $item;
+      $this->cacheItemBackend->set($newPath, $newItem);
+    }
+
+    return $result;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function delete($path): bool {
+    $result = $this->adapter->delete($path);
+
+    if ($result) {
+      $this->cacheItemBackend->delete($path);
+    }
+
+    return $result;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deleteDir($dirname): bool {
+    // Before the delete we need to know what files are in the directory.
+    $contents = $this->adapter->listContents($dirname, TRUE);
+
+    $result = $this->adapter->deleteDir($dirname);
+
+    if ($result) {
+      $paths = array_column($contents, 'path');
+      $this->cacheItemBackend->deleteMultiple($paths);
+    }
+
+    return $result;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function createDir($dirname, Config $config): array|false {
+    $metadata = $this->adapter->createDir($dirname, $config);
+
+    // Warm the metadata cache.
+    if ($metadata) {
+      $item = new CacheItem();
+      $item->updateMetadata($metadata);
+      $this->cacheItemBackend->set($dirname, $item);
+    }
+
+    return $metadata;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setVisibility($path, $visibility): array|false {
+    $metadata = $this->adapter->setVisibility($path, $visibility);
+
+    return $this->updateMetadata($path, $metadata);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function has($path): array|bool|null {
+    if ($this->cacheItemBackend->has($path)) {
+      return TRUE;
+    }
+
+    // Always check the upstream adapter for new files.
+    // @todo This could be a good place for a micro-cache?
+    return $this->adapter->has($path);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function read($path): array|false {
+    return $this->adapter->read($path);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function readStream($path): array|false {
+    return $this->adapter->readStream($path);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function listContents($directory = '', $recursive = FALSE): array {
+    // Don't cache directory listings to avoid having to keep track of
+    // incomplete cache entries.
+    // @todo This could be a good place for a micro-cache?
+    return $this->adapter->listContents($directory, $recursive);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getMetadata($path): array|false {
+    $item = $this->cacheItemBackend->load($path);
+
+    if ($metadata = $item->getMetadata()) {
+      return $metadata;
+    }
+
+    $metadata = $this->adapter->getMetadata($path);
+    $item->updateMetadata($metadata);
+    $this->cacheItemBackend->set($path, $item);
+
+    return $metadata;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getSize($path): array|false {
+    return $this->fetchMetadataKey($path, 'size');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getMimetype($path): array|false {
+    return $this->fetchMetadataKey($path, 'mimetype');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getTimestamp($path): array|false {
+    return $this->fetchMetadataKey($path, 'timestamp');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getVisibility($path): array|false {
+    return $this->fetchMetadataKey($path, 'visibility');
+  }
+
+  /**
+   * Fetches a specific key from metadata.
+   *
+   * @param string $path
+   *   The path to load metadata for.
+   * @param string $key
+   *   The key in metadata, such as 'mimetype', to load metadata for.
+   *
+   * @return array
+   *   The array of metadata.
+   */
+  protected function fetchMetadataKey($path, $key) {
+    $item = $this->cacheItemBackend->load($path);
+
+    if (($metadata = $item->getMetadata()) && isset($metadata[$key])) {
+      return $metadata;
+    }
+
+    $method = 'get' . ucfirst($key);
+
+    return $this->updateMetadata($path, $this->adapter->$method($path));
+  }
+
+  /**
+   * Updates the metadata for a given path.
+   *
+   * @param string $path
+   *   The path of file file or directory.
+   * @param array|false $metadata
+   *   The metadata to update.
+   *
+   * @return array|false
+   *   Returns the value passed in as metadata.
+   */
+  protected function updateMetadata($path, $metadata) {
+    if (!empty($metadata)) {
+      $item = $this->cacheItemBackend->load($path);
+      $item->updateMetadata($metadata);
+      $this->cacheItemBackend->set($path, $item);
+    }
+
+    return $metadata;
+  }
+
+}
diff --git a/src/Flysystem/Adapter/MissingAdapter.php b/src/Flysystem/Adapter/MissingAdapter.php
new file mode 100644
index 0000000..a006b3b
--- /dev/null
+++ b/src/Flysystem/Adapter/MissingAdapter.php
@@ -0,0 +1,146 @@
+<?php
+
+namespace Drupal\flysystem\Flysystem\Adapter;
+
+use League\Flysystem\AdapterInterface;
+use League\Flysystem\Config;
+
+/**
+ * An adapter used when a plugin is missing. It fails at everything.
+ */
+class MissingAdapter implements AdapterInterface {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function copy($path, $newPath): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function createDir($dirname, Config $config): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function delete($path): bool {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function deleteDir($dirname): bool {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function listContents($directory = '', $recursive = FALSE): array {
+    return [];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getMetadata($path): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getMimetype($path): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getSize($path): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getTimestamp($path): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getVisibility($path): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function has($path): array|bool|null {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setVisibility($path, $visibility): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function update($path, $contents, Config $config): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function updateStream($path, $resource, Config $config): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function read($path): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function readStream($path): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rename($path, $newPath): bool {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function write($path, $contents, Config $config): array|false {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function writeStream($path, $resource, Config $config): array|false {
+    return FALSE;
+  }
+
+}
diff --git a/src/Flysystem/Ftp.php b/src/Flysystem/Ftp.php
new file mode 100644
index 0000000..b09427d
--- /dev/null
+++ b/src/Flysystem/Ftp.php
@@ -0,0 +1,90 @@
+<?php
+
+namespace Drupal\flysystem\Flysystem;
+
+use Drupal\Core\Logger\RfcLogLevel;
+use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+use Drupal\flysystem\Plugin\FlysystemPluginInterface;
+use Drupal\flysystem\Plugin\FlysystemUrlTrait;
+use League\Flysystem\Adapter\Ftp as FtpAdapter;
+
+/**
+ * Drupal plugin for the "FTP" Flysystem adapter.
+ *
+ * @Adapter(
+ *   id = "ftp",
+ *   extensions = {"ftp"}
+ * )
+ */
+class Ftp implements FlysystemPluginInterface {
+
+  use FlysystemUrlTrait;
+
+  /**
+   * Plugin configuration.
+   *
+   * @var array
+   */
+  protected $configuration;
+
+  /**
+   * Constructs an Ftp object.
+   *
+   * @param array $configuration
+   *   Plugin configuration array.
+   */
+  public function __construct(array $configuration) {
+    $this->configuration = $configuration;
+
+    if (empty($this->configuration['host'])) {
+      $this->configuration['host'] = '127.0.0.1';
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getAdapter() {
+    try {
+      $adapter = new FtpAdapter($this->configuration);
+      $adapter->connect();
+    }
+
+    catch (\RuntimeException $e) {
+      // A problem connecting to the server.
+      $adapter = new MissingAdapter();
+    }
+
+    return $adapter;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function ensure($force = FALSE) {
+    if ($this->getAdapter() instanceof FtpAdapter) {
+      return [
+        [
+          'severity' => RfcLogLevel::INFO,
+          'message' => 'Successfully connected to %host:%port.',
+          'context' => [
+            '%host' => $this->configuration['host'],
+            '%port' => $this->configuration['port'] ?? 21,
+          ],
+        ],
+      ];
+    }
+
+    return [
+      [
+        'severity' => RfcLogLevel::ERROR,
+        'message' => 'There was an error connecting to the FTP server %host:%port.',
+        'context' => [
+          '%host' => $this->configuration['host'],
+          '%port' => $this->configuration['port'] ?? 21,
+        ],
+      ],
+    ];
+  }
+
+}
diff --git a/src/Flysystem/Local.php b/src/Flysystem/Local.php
new file mode 100644
index 0000000..74e6dd9
--- /dev/null
+++ b/src/Flysystem/Local.php
@@ -0,0 +1,190 @@
+<?php
+
+namespace Drupal\flysystem\Flysystem;
+
+use Drupal\Component\FileSecurity\FileSecurity;
+use Drupal\Component\Utility\UrlHelper;
+use Drupal\Core\File\FileSystem;
+use Drupal\Core\Logger\RfcLogLevel;
+use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+use Drupal\flysystem\Plugin\FlysystemPluginInterface;
+use Drupal\flysystem\Plugin\FlysystemUrlTrait;
+use League\Flysystem\Adapter\Local as LocalAdapter;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Drupal plugin for the "Local" Flysystem adapter.
+ *
+ * @Adapter(id = "local")
+ */
+class Local implements FlysystemPluginInterface, ContainerFactoryPluginInterface {
+
+  use FlysystemUrlTrait {
+    getExternalUrl as getDownloadUrl;
+  }
+
+  /**
+   * The permissions to create directories with.
+   *
+   * @var int
+   */
+  protected $directoryPerm;
+
+  /**
+   * Whether the root is in the public path.
+   *
+   * @var bool
+   */
+  protected $isPublic;
+
+  /**
+   * The root of the local adapter.
+   *
+   * @var string
+   */
+  protected $root;
+
+  /**
+   * Whether the root exists and is readable.
+   *
+   * @var bool
+   */
+  protected $rootExists;
+
+  /**
+   * Constructs a Local object.
+   *
+   * @param string $root
+   *   The of the adapter's filesystem.
+   * @param bool $is_public
+   *   (optional) Whether this is a public file system. Defaults to false.
+   * @param int $directory_permission
+   *   (optional) The permissions to create directories with.
+   */
+  public function __construct($root, $is_public = FALSE, $directory_permission = FileSystem::CHMOD_DIRECTORY) {
+    $this->isPublic = $is_public;
+    $this->root = $root;
+    $this->directoryPerm = $directory_permission;
+    $this->rootExists = $this->ensureDirectory();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    return new static(
+      $configuration['root'],
+      !empty($configuration['public']),
+      $container->get('settings')->get('file_chmod_directory', FileSystem::CHMOD_DIRECTORY)
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getAdapter() {
+    return $this->rootExists ? new LocalAdapter($this->root) : new MissingAdapter();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getExternalUrl($uri) {
+    if ($this->isPublic === FALSE) {
+      return $this->getDownloadUrl($uri);
+    }
+
+    $path = str_replace('\\', '/', $this->root . '/' . $this->getTarget($uri));
+
+    return $GLOBALS['base_url'] . '/' . UrlHelper::encodePath($path);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function ensure($force = FALSE) {
+    if (!$this->rootExists) {
+      return [
+        [
+          'severity' => RfcLogLevel::ERROR,
+          'message' => 'The %root directory either does not exist or is not readable and attempts to create it have failed.',
+          'context' => ['%root' => $this->root],
+        ],
+      ];
+    }
+
+    if (!$this->writeHtaccess($force)) {
+      return [
+        [
+          'severity' => RfcLogLevel::ERROR,
+          'message' => 'See <a href="@url">@url</a> for information about the recommended .htaccess file which should be added to the %directory directory to help protect against arbitrary code execution.',
+          'context' => [
+            '%directory' => $this->root,
+            '@url' => 'https://www.drupal.org/SA-CORE-2013-003',
+          ],
+        ],
+      ];
+    }
+
+    return [
+      [
+        'severity' => RfcLogLevel::INFO,
+        'message' => 'The directory %root exists and is readable.',
+        'context' => ['%root' => $this->root],
+      ],
+    ];
+  }
+
+  /**
+   * Checks that the directory exists and is readable.
+   *
+   * This will attempt to create the directory if it doesn't exist.
+   *
+   * @return bool
+   *   True on success, false on failure.
+   */
+  protected function ensureDirectory() {
+    // Go for the success case first.
+    if (is_dir($this->root) && is_readable($this->root)) {
+      return TRUE;
+    }
+
+    if (!file_exists($this->root)) {
+      mkdir($this->root, $this->directoryPerm, TRUE);
+    }
+
+    if (is_dir($this->root) && chmod($this->root, $this->directoryPerm)) {
+      clearstatcache(TRUE, $this->root);
+      $this->writeHtaccess(TRUE);
+      return TRUE;
+    }
+
+    return FALSE;
+  }
+
+  /**
+   * Writes an .htaccess file.
+   *
+   * @param bool $force
+   *   Whether to overwrite an existing file.
+   *
+   * @return bool
+   *   True on success, false on failure.
+   */
+  protected function writeHtaccess($force) {
+    $htaccess_path = $this->root . '/.htaccess';
+
+    if (file_exists($htaccess_path) && !$force) {
+      // Short circuit if the .htaccess file already exists.
+      return TRUE;
+    }
+
+    // Make file writable so that we can overwrite it.
+    if (file_exists($htaccess_path)) {
+      chmod($htaccess_path, 0666);
+    }
+    return @file_put_contents($htaccess_path, FileSecurity::htaccessLines(!$this->isPublic)) && chmod($htaccess_path, 0444);
+  }
+
+}
diff --git a/src/Flysystem/Missing.php b/src/Flysystem/Missing.php
new file mode 100644
index 0000000..d2ea885
--- /dev/null
+++ b/src/Flysystem/Missing.php
@@ -0,0 +1,43 @@
+<?php
+
+namespace Drupal\flysystem\Flysystem;
+
+use Drupal\Core\Logger\RfcLogLevel;
+use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+use Drupal\flysystem\Plugin\FlysystemPluginInterface;
+
+/**
+ * Drupal plugin for the "NullAdapter" Flysystem adapter.
+ *
+ * @Adapter(id = "missing")
+ */
+class Missing implements FlysystemPluginInterface {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getAdapter() {
+    return new MissingAdapter();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getExternalUrl($uri) {
+    return '';
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function ensure($force = FALSE) {
+    return [
+      [
+        'severity' => RfcLogLevel::ERROR,
+        'message' => 'The Flysystem driver is missing.',
+        'context' => [],
+      ],
+    ];
+  }
+
+}
diff --git a/src/FlysystemAdapterConfigInterface.php b/src/FlysystemAdapterConfigInterface.php
deleted file mode 100644
index 43b12e4..0000000
--- a/src/FlysystemAdapterConfigInterface.php
+++ /dev/null
@@ -1,68 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem;
-
-use Drupal\Core\Config\Entity\ConfigEntityInterface;
-
-/**
- * Provides an interface defining a flysystem_adapter_config entity type.
- */
-interface FlysystemAdapterConfigInterface extends ConfigEntityInterface {
-
-  /**
-   * Determines whether Flysystem adapter is valid.
-   *
-   * @return bool
-   *   TRUE if valid, FALSE otherwise.
-   */
-  public function hasValidSubAdapter();
-
-  /**
-   * Retrieves the Flysystem adapter.
-   *
-   * @return \Drupal\flysystem\FlysystemAdapterInterface
-   *   This adapter config entity's Flysystem adapter.
-   *
-   * @throws \Drupal\flysystem\FlysystemException
-   *   Thrown if the adapter plugin could not be retrieved.
-   */
-  public function getSubAdapter();
-
-  /**
-   * Retrieves plugin ID of the Flysystem (sub)adapter of this config entity.
-   *
-   * @return string
-   *   The plugin ID of the subadapter.
-   */
-  public function getSubAdapterId();
-
-  /**
-   * Return the configuration of this config entity's Flysystem (sub)adapter.
-   *
-   * @return array
-   *   An associative array with the subadapter configuration.
-   */
-  public function getSubAdapterConfig();
-
-  /**
-   * Get adapter config description.
-   *
-   * @return string
-   *   Adapter config description.
-   */
-  public function getDescription();
-
-  /**
-   * Returns the value of a configuration item from the key.
-   *
-   * @param string|array $key
-   *   Key or array of keys of item in the configuration array.
-   *
-   * @return mixed
-   *   Value to return from array key.
-   */
-  public function getSubAdapterConfigItem($key);
-
-}
diff --git a/src/FlysystemAdapterConfigListBuilder.php b/src/FlysystemAdapterConfigListBuilder.php
deleted file mode 100644
index 41768dc..0000000
--- a/src/FlysystemAdapterConfigListBuilder.php
+++ /dev/null
@@ -1,36 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem;
-
-use Drupal\Core\Config\Entity\ConfigEntityListBuilder;
-use Drupal\Core\Entity\EntityInterface;
-
-/**
- * Provides a listing of flysystem_adapter_config entities.
- */
-final class FlysystemAdapterConfigListBuilder extends ConfigEntityListBuilder {
-
-  /**
-   * {@inheritdoc}
-   */
-  public function buildHeader(): array {
-    $header['label'] = $this->t('Label');
-    $header['id'] = $this->t('Machine name');
-    $header['status'] = $this->t('Status');
-    return $header + parent::buildHeader();
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function buildRow(EntityInterface $entity): array {
-    /** @var \Drupal\flysystem\FlysystemAdapterConfigInterface $entity */
-    $row['label'] = $entity->label();
-    $row['id'] = $entity->id();
-    $row['status'] = $entity->status() ? $this->t('Enabled') : $this->t('Disabled');
-    return $row + parent::buildRow($entity);
-  }
-
-}
diff --git a/src/FlysystemAdapterInterface.php b/src/FlysystemAdapterInterface.php
deleted file mode 100644
index 60092bd..0000000
--- a/src/FlysystemAdapterInterface.php
+++ /dev/null
@@ -1,63 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem;
-
-use Drupal\Component\Plugin\ConfigurableInterface;
-use Drupal\Component\Plugin\DependentPluginInterface;
-use Drupal\Component\Plugin\DerivativeInspectionInterface;
-use Drupal\Component\Plugin\PluginInspectionInterface;
-use Drupal\Core\Form\FormStateInterface;
-use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
-
-/**
- * Interface for flysystem_adapter plugins.
- */
-interface FlysystemAdapterInterface extends PluginInspectionInterface, DerivativeInspectionInterface, ConfigurableInterface, DependentPluginInterface, ContainerFactoryPluginInterface {
-
-  /**
-   * Returns the translated plugin label.
-   */
-  public function label(): string;
-
-  /**
-   * Retrieves plugin ID of the Flysystem (sub)adapter of this config entity.
-   *
-   * @return string
-   *   The plugin ID of the subadapter.
-   */
-  public function getSubAdapterId();
-
-  /**
-   * Return the configuration of this config entity's Flysystem (sub)adapter.
-   *
-   * @return array
-   *   An associative array with the subadapter configuration.
-   */
-  public function getSubAdapterConfig();
-
-  /**
-   * Builds the Sub Configuration Form components for Form array.
-   *
-   * @param array $form
-   *   Form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
-   *   Drupal Form State object.
-   * @param \Drupal\flysystem\FlysystemAdapterConfigInterface $flysystem_adapter_config
-   *   Flysystem Adapter Configuration entity.
-   *
-   * @return array
-   *   Form array with subform items added.
-   */
-  public function buildSubConfigurationForm(array $form, FormStateInterface $form_state, FlysystemAdapterConfigInterface $flysystem_adapter_config);
-
-  /**
-   * Get Default file/directory permissions.
-   *
-   * Return array
-   *   Default permissions stored in $defaultPermissions property.
-   */
-  public function getDefaultPermissions();
-
-}
diff --git a/src/FlysystemAdapterPluginManager.php b/src/FlysystemAdapterPluginManager.php
deleted file mode 100644
index 7b032a3..0000000
--- a/src/FlysystemAdapterPluginManager.php
+++ /dev/null
@@ -1,26 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem;
-
-use Drupal\Core\Cache\CacheBackendInterface;
-use Drupal\Core\Extension\ModuleHandlerInterface;
-use Drupal\Core\Plugin\DefaultPluginManager;
-use Drupal\flysystem\Annotation\FlysystemAdapter;
-
-/**
- * FlysystemAdapter plugin manager.
- */
-final class FlysystemAdapterPluginManager extends DefaultPluginManager {
-
-  /**
-   * Constructs the object.
-   */
-  public function __construct(\Traversable $namespaces, CacheBackendInterface $cache_backend, ModuleHandlerInterface $module_handler) {
-    parent::__construct('Plugin/FlysystemAdapter', $namespaces, $module_handler, FlysystemSubAdapterInterface::class, FlysystemAdapter::class);
-    $this->alterInfo('flysystem_adapter_info');
-    $this->setCacheBackend($cache_backend, 'flysystem_adapter_plugins');
-  }
-
-}
diff --git a/src/FlysystemBridge.php b/src/FlysystemBridge.php
new file mode 100644
index 0000000..57db5f6
--- /dev/null
+++ b/src/FlysystemBridge.php
@@ -0,0 +1,139 @@
+<?php
+
+namespace Drupal\flysystem;
+
+use Drupal\Core\StreamWrapper\StreamWrapperInterface;
+use Drupal\Core\StringTranslation\StringTranslationTrait;
+use League\Flysystem\FilesystemInterface;
+use League\Flysystem\Util;
+use Codementality\FlysystemStreamWrapper;
+
+/**
+ * An adapter for Flysystem to StreamWrapperInterface.
+ */
+class FlysystemBridge extends FlysystemStreamWrapper implements StreamWrapperInterface {
+
+  use StringTranslationTrait;
+
+  /**
+   * PHP-passed stream context.
+   *
+   * @var resource|null
+   */
+  public $context;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function getType() {
+    return StreamWrapperInterface::WRITE_VISIBLE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getName() {
+    $scheme = $this->getProtocol();
+    $name = $this->getFactory()->getSettings($scheme)['name'];
+    $default = $this->t('Flysystem: @scheme', ['@scheme' => $scheme]);
+
+    return $name !== '' ? $name : $default;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getDescription() {
+    $scheme = $this->getProtocol();
+    $description = $this->getFactory()->getSettings($scheme)['description'];
+    $default = $this->t('Flysystem: @scheme', ['@scheme' => $scheme]);
+
+    return $description !== '' ? $description : $default;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getUri() {
+    return $this->uri;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUri($uri) {
+    $this->uri = $uri;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getExternalUrl() {
+    return $this
+      ->getFactory()
+      ->getPlugin($this->getProtocol())
+      ->getExternalUrl($this->uri);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function realpath() {
+    return FALSE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function dirname($uri = NULL) {
+    if (!isset($uri)) {
+      $uri = $this->uri;
+    }
+
+    [$scheme, $target] = explode('://', $uri, 2);
+
+    return $scheme . '://' . ltrim(Util::dirname($target), '\/');
+  }
+
+  /**
+   * Returns the filesystem for a given scheme.
+   *
+   * @param string $scheme
+   *   The scheme.
+   *
+   * @return \League\Flysystem\FilesystemInterface
+   *   The filesystem for the scheme.
+   */
+  protected function getFilesystemForScheme($scheme) {
+    if (!isset(static::$filesystems[$scheme])) {
+      static::$filesystems[$scheme] = $this->getFactory()->getFilesystem($scheme);
+      static::$config[$scheme] = static::$defaultConfiguration;
+      static::$config[$scheme]['permissions']['dir']['public'] = 0777;
+      static::registerPlugins($scheme, static::$filesystems[$scheme]);
+    }
+
+    return static::$filesystems[$scheme];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function getFilesystem(): FilesystemInterface {
+    if (!isset($this->filesystem)) {
+      $this->filesystem = $this->getFilesystemForScheme($this->getProtocol());
+    }
+
+    return $this->filesystem;
+  }
+
+  /**
+   * Returns the filesystem factory.
+   *
+   * @return \Drupal\flysystem\FlysystemFactory
+   *   The Flysystem factory.
+   */
+  protected function getFactory() {
+    return \Drupal::service('flysystem_factory');
+  }
+
+}
diff --git a/src/FlysystemException.php b/src/FlysystemException.php
deleted file mode 100644
index f9ad08f..0000000
--- a/src/FlysystemException.php
+++ /dev/null
@@ -1,8 +0,0 @@
-<?php
-
-namespace Drupal\flysystem;
-
-/**
- * Represents an exception that occurred in some part of Flysystem.
- */
-class FlysystemException extends \Exception {}
diff --git a/src/FlysystemFactory.php b/src/FlysystemFactory.php
new file mode 100644
index 0000000..e387ca9
--- /dev/null
+++ b/src/FlysystemFactory.php
@@ -0,0 +1,233 @@
+<?php
+
+namespace Drupal\flysystem;
+
+use Drupal\Component\Plugin\PluginManagerInterface;
+use Drupal\Core\Cache\CacheBackendInterface;
+use Drupal\Core\Site\Settings;
+use Drupal\Core\StreamWrapper\StreamWrapperManagerInterface;
+use Drupal\flysystem\Event\EnsureEvent;
+use Drupal\flysystem\Event\FlysystemEvents;
+use Drupal\flysystem\Flysystem\Adapter\CacheItemBackend;
+use Drupal\flysystem\Flysystem\Adapter\DrupalCacheAdapter;
+use League\Flysystem\Filesystem;
+use League\Flysystem\Replicate\ReplicateAdapter;
+use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;
+
+/**
+ * A factory for Flysystem filesystems.
+ */
+class FlysystemFactory {
+
+  /**
+   * Default settings.
+   *
+   * @var array
+   */
+  protected $defaults = [
+    'driver' => '',
+    'config' => [],
+    'replicate' => FALSE,
+    'cache' => FALSE,
+    'name' => '',
+    'description' => '',
+  ];
+
+  /**
+   * The cache backend.
+   *
+   * @var \Drupal\Core\Cache\CacheBackendInterface
+   */
+  protected $cacheBackend;
+
+  /**
+   * The event dispatcher.
+   *
+   * @var \Symfony\Contract\EventDispatcher\EventDispatcherInterface
+   */
+  protected $eventDispatcher;
+
+  /**
+   * A cache of filesystems.
+   *
+   * @var \League\Flysystem\FilesystemInterface[]
+   */
+  protected $filesystems = [];
+
+  /**
+   * The Flysystem plugin manager.
+   *
+   * @var \Drupal\Component\Plugin\PluginManagerInterface
+   */
+  protected $pluginManager;
+
+  /**
+   * Created plugins.
+   *
+   * @var \Drupal\flysystem\Plugin\FlysystemPluginInterface[]
+   */
+  protected $plugins = [];
+
+  /**
+   * Settings for stream wrappers.
+   *
+   * @var array
+   */
+  protected $settings = [];
+
+  /**
+   * Constructs a FlysystemFactory object.
+   *
+   * @param \Drupal\Component\Plugin\PluginManagerInterface $plugin_manager
+   *   The plugin manager.
+   * @param \Drupal\Core\StreamWrapper\StreamWrapperManagerInterface $stream_wrapper_manager
+   *   The stream wrapper manager service.
+   * @param \Drupal\Core\Cache\CacheBackendInterface $cache
+   *   The cache backend.
+   * @param \Symfony\Contract\EventDispatcher\EventDispatcherInterface $event_dispatcher
+   *   The event dispatcher.
+   */
+  public function __construct(PluginManagerInterface $plugin_manager, StreamWrapperManagerInterface $stream_wrapper_manager, CacheBackendInterface $cache, EventDispatcherInterface $event_dispatcher) {
+    $this->pluginManager = $plugin_manager;
+    $this->cacheBackend = $cache;
+    $this->eventDispatcher = $event_dispatcher;
+
+    // Apply defaults and validate registered services.
+    foreach (Settings::get('flysystem', []) as $scheme => $configuration) {
+
+      // The settings.php file could be changed before rebuilding the container.
+      if (!$stream_wrapper_manager->isValidScheme($scheme)) {
+        continue;
+      }
+
+      $this->settings[$scheme] = $configuration + $this->defaults;
+    }
+  }
+
+  /**
+   * Returns the filesystem for a given scheme.
+   *
+   * @param string $scheme
+   *   The scheme.
+   *
+   * @return \League\Flysystem\FilesystemInterface
+   *   The filesystem for the scheme.
+   */
+  public function getFilesystem($scheme) {
+    if (!isset($this->filesystems[$scheme])) {
+      $this->filesystems[$scheme] = new Filesystem($this->getAdapter($scheme));
+    }
+
+    return $this->filesystems[$scheme];
+  }
+
+  /**
+   * Returns the plugin for a scheme.
+   *
+   * @param string $scheme
+   *   The scheme.
+   *
+   * @return \Drupal\flysystem\Plugin\FlysystemPluginInterface
+   *   The plugin.
+   */
+  public function getPlugin($scheme) {
+    if (!isset($this->plugins[$scheme])) {
+      $settings = $this->getSettings($scheme);
+
+      $this->plugins[$scheme] = $this->pluginManager->createInstance($settings['driver'], $settings['config']);
+    }
+
+    return $this->plugins[$scheme];
+  }
+
+  /**
+   * Returns a list of valid schemes.
+   *
+   * @return string[]
+   *   The list of valid schemes.
+   */
+  public function getSchemes() {
+    return array_keys($this->settings);
+  }
+
+  /**
+   * Finds the settings for a given scheme.
+   *
+   * @param string $scheme
+   *   The scheme.
+   *
+   * @return array
+   *   The settings array from settings.php.
+   */
+  public function getSettings($scheme) {
+    return $this->settings[$scheme] ?? $this->defaults;
+  }
+
+  /**
+   * Calls FlysystemPluginInterface::ensure() on each plugin.
+   *
+   * @param bool $force
+   *   (optional) Whether to force the insurance. Defaults to false.
+   *
+   * @return array
+   *   Errors keyed by scheme.
+   */
+  public function ensure($force = FALSE) {
+    $errors = [];
+
+    foreach ($this->getSchemes() as $scheme) {
+
+      foreach ($this->getPlugin($scheme)->ensure($force) as $error) {
+
+        $event = new EnsureEvent(
+          $scheme,
+          $error['severity'],
+          $error['message'],
+          $error['context']
+        );
+
+        $this->eventDispatcher->dispatch($event, FlysystemEvents::ENSURE);
+
+        $errors[$scheme][] = $error;
+      }
+    }
+
+    return $errors;
+  }
+
+  /**
+   * Prevents the class from being serialized.
+   */
+  public function __sleep() {
+    $message = sprintf('%s can not be serialized. This probably means you are serializing an object that has an indirect reference to the %s object. Adjust your code so that is not necessary.', __CLASS__, __CLASS__);
+    throw new \LogicException($message);
+  }
+
+  /**
+   * Returns the adapter for a scheme.
+   *
+   * @param string $scheme
+   *   The scheme to find an adapter for.
+   *
+   * @return \League\Flysystem\AdapterInterface
+   *   The correct adapter from settings.
+   */
+  protected function getAdapter($scheme) {
+    $settings = $this->getSettings($scheme);
+
+    $adapter = $this->getPlugin($scheme)->getAdapter();
+
+    if ($settings['replicate']) {
+      $replica = $this->getAdapter($settings['replicate']);
+      $adapter = new ReplicateAdapter($adapter, $replica);
+    }
+
+    if ($settings['cache']) {
+      $cache_item_backend = new CacheItemBackend($scheme, $this->cacheBackend);
+      $adapter = new DrupalCacheAdapter($scheme, $adapter, $cache_item_backend);
+    }
+
+    return $adapter;
+  }
+
+}
diff --git a/src/FlysystemServiceProvider.php b/src/FlysystemServiceProvider.php
index aef4626..e9980c5 100644
--- a/src/FlysystemServiceProvider.php
+++ b/src/FlysystemServiceProvider.php
@@ -3,43 +3,36 @@
 namespace Drupal\flysystem;
 
 use Drupal\Core\DependencyInjection\ContainerBuilder;
-use Drupal\Core\DependencyInjection\ServiceProviderBase;
-use Symfony\Component\DependencyInjection\Reference;
-use Symfony\Component\DependencyInjection\ContainerInterface;
+use Drupal\Core\DependencyInjection\ServiceProviderInterface;
+use Drupal\Core\Site\Settings;
 
 /**
- * Registers Flysystem Stream Wrappers.
- *
- * Registers stream wrappers using the configured Flysystem adapters.
+ * Flysystem dependency injection container.
  */
-class FlysystemServiceProvider extends ServiceProviderBase {
+class FlysystemServiceProvider implements ServiceProviderInterface {
 
   /**
    * {@inheritdoc}
    */
-  public function register(ContainerBuilder $container): void {
+  public function register(ContainerBuilder $container) {
 
-    /** @var \Drupal\Core\Config\DatabaseStorage $config_storage */
-    $config_storage = $container->get('config.storage.active');
-    $entity_config_names = $config_storage->listAll('flysystem.flysystem_adapter_config');
+    foreach (Settings::get('flysystem', []) as $scheme => $settings) {
 
-    if (!empty($entity_config_names)) {
-      $configured_entities = $config_storage->readMultiple($entity_config_names);
+      // Just some sanity checking, so things don't explode.
+      if (empty($settings['driver'])) {
+        continue;
+      }
 
-      foreach ($configured_entities as $key => $value) {
-        if (empty($value)) {
-          // This should never happen, however if it does skip this entry.
-          continue;
-        }
+      $container
+        ->register('flysystem_stream_wrapper.' . $scheme, 'Drupal\flysystem\FlysystemBridge')
+        ->addTag('stream_wrapper', ['scheme' => $scheme]);
 
-        if ($value['status'] !== TRUE) {
-          // Scheme is not enabled.
-          continue;
-        }
+      // Register the path processors for local files.
+      if ($settings['driver'] === 'local' && !empty($settings['config']['public'])) {
         $container
-          ->register('stream_wrapper.' . $value['id'], 'Drupal\flysystem\FlyStream\FlyStreamWrapper')
-          ->addTag('stream_wrapper', ['scheme' => $value['id']])
-          ->setArguments([$key, new Reference('config.storage')]);
+          ->register('flysystem.' . $scheme . '.path_processor', 'Drupal\flysystem\PathProcessor\LocalPathProcessor')
+          ->addTag('path_processor_inbound', ['priority' => 400])
+          ->addArgument($scheme);
       }
     }
   }
diff --git a/src/FlysystemSubAdapterInterface.php b/src/FlysystemSubAdapterInterface.php
deleted file mode 100644
index bf78c2d..0000000
--- a/src/FlysystemSubAdapterInterface.php
+++ /dev/null
@@ -1,61 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem;
-
-use Drupal\Component\Plugin\ConfigurableInterface;
-use Drupal\Component\Plugin\DependentPluginInterface;
-use Drupal\Component\Plugin\DerivativeInspectionInterface;
-use Drupal\Component\Plugin\PluginInspectionInterface;
-use Drupal\Core\Form\FormStateInterface;
-use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
-use Drupal\Core\Plugin\PluginFormInterface;
-
-/**
- * Interface for flysystem_adapter plugins.
- */
-interface FlysystemSubAdapterInterface extends PluginFormInterface, PluginInspectionInterface, DerivativeInspectionInterface, ConfigurableInterface, DependentPluginInterface, ContainerFactoryPluginInterface {
-
-  /**
-   * Returns the translated plugin label.
-   */
-  public function label(): string;
-
-  /**
-   * Returns the subAdaper description.
-   *
-   * @return string
-   *   SubAdapter description.
-   */
-  public function getDescription();
-
-  /**
-   * Builds the Sub Configuration Form components for Form array.
-   *
-   * This method description is the same as that declared in
-   * \Drupal/flysystem\FlysystemAdapterInterface, but is also included here for
-   * clarity and documentation of what needs to be implemented in a
-   * sub adapter plugin entity type.
-   *
-   * @param array $form
-   *   Form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
-   *   Drupal Form State object.
-   * @param \Drupal\flysystem\FlysystemAdapterConfigInterface $flysystem_adapter_config
-   *   Flysystem Adapter Configuration entity.
-   *
-   * @return array
-   *   Form array with subform items added.
-   */
-  public function buildSubConfigurationForm(array &$form, FormStateInterface $form_state, FlysystemAdapterConfigInterface $flysystem_adapter_config);
-
-  /**
-   * Get Default file/directory permissions.
-   *
-   * Return array
-   *   Default permissions stored in $defaultPermissions property.
-   */
-  public function getDefaultPermissions();
-
-}
diff --git a/src/Form/ConfigForm.php b/src/Form/ConfigForm.php
new file mode 100644
index 0000000..1d8bac3
--- /dev/null
+++ b/src/Form/ConfigForm.php
@@ -0,0 +1,239 @@
+<?php
+
+namespace Drupal\flysystem\Form;
+
+use Drupal\Component\Utility\Environment;
+use Drupal\Component\Utility\Html;
+use Drupal\Core\Form\FormBase;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\flysystem\FlysystemFactory;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Configure file system settings for this site.
+ */
+class ConfigForm extends FormBase {
+
+  /**
+   * The Flysystem factory.
+   *
+   * @var \Drupal\flysystem\FlysystemFactory
+   */
+  protected $factory;
+
+  /**
+   * Constructs a ConfigForm object.
+   *
+   * @param \Drupal\flysystem\FlysystemFactory $factory
+   *   The FlysystemF factory.
+   */
+  public function __construct(FlysystemFactory $factory) {
+    $this->factory = $factory;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container) {
+    return new static($container->get('flysystem_factory'));
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFormId() {
+    return 'flysystem_config_form';
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildForm(array $form, FormStateInterface $form_state) {
+    $schemes = $this->factory->getSchemes();
+
+    $form['sync_from'] = [
+      '#type' => 'select',
+      '#options' => array_combine($schemes, $schemes),
+      '#title' => $this->t('Sync from'),
+      '#required' => TRUE,
+    ];
+
+    $form['sync_to'] = [
+      '#type' => 'select',
+      '#options' => array_combine($schemes, $schemes),
+      '#title' => $this->t('Sync to'),
+      '#required' => TRUE,
+    ];
+
+    $form['force'] = [
+      '#type' => 'checkbox',
+      '#title' => $this->t('Force'),
+      '#description' => $this->t('Normally, existing files will be ignored. Selecting this option will overwrite any existing files.'),
+    ];
+
+    $form['actions']['#type'] = 'actions';
+    $form['actions']['submit'] = [
+      '#type' => 'submit',
+      '#value' => $this->t('Sync'),
+      '#button_type' => 'primary',
+    ];
+
+    return $form;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function validateForm(array &$form, FormStateInterface $form_state) {
+    if ($form_state->getValue('sync_from') === $form_state->getValue('sync_to')) {
+      $form_state->setError($form['sync_from'], $this->t('"Sync from" and "Sync to" cannot be the same scheme.'));
+      $form_state->setError($form['sync_to']);
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function submitForm(array &$form, FormStateInterface $form_state) {
+    $scheme_from = $form_state->getValue('sync_from');
+    $scheme_to = $form_state->getValue('sync_to');
+
+    $from_files = $this->getFileList($scheme_from);
+
+    $to_files = [];
+    if (!$form_state->getValue('force')) {
+      $to_files = $this->getFileList($scheme_to);
+    }
+
+    $batch = [
+      'operations' => [],
+      'finished' => get_class($this) . '::finishBatch',
+      'title' => $this->t('Synchronizing file systems'),
+      'init_message' => $this->t('Starting file system synchronization.'),
+      'progress_message' => $this->t('Completed @current step of @total.'),
+      'error_message' => $this->t('File system synchronization has encountered an error.'),
+    ];
+
+    // @todo We shouldn't do all files in one go, but rather add files and
+    // directories and recurse in a batch callback.
+    foreach (array_diff($from_files, $to_files) as $filepath) {
+      $batch['operations'][] = [
+        get_class($this) . '::copyFile',
+        [$scheme_from, $scheme_to, $filepath],
+      ];
+    }
+
+    batch_set($batch);
+  }
+
+  /**
+   * Copies a single file.
+   *
+   * @param string $scheme_from
+   *   The scheme to sync from.
+   * @param string $scheme_to
+   *   The scheme to sync to.
+   * @param string $filepath
+   *   The file to sync.
+   * @param array &$context
+   *   The batch context.
+   */
+  public static function copyFile($scheme_from, $scheme_to, $filepath, array &$context) {
+    $context['message'] = \Drupal::translation()->translate('Copying: %file', ['%file' => $filepath]);
+    $context['finished'] = 1;
+
+    $factory = \Drupal::service('flysystem_factory');
+
+    // Copying files could take a very long time. Using streams will keep memory
+    // usage down, but we could still timeout.
+    Environment::setTimeLimit(0);
+
+    try {
+      $read_handle = $factory->getFilesystem($scheme_from)->readStream($filepath);
+
+      if (!is_resource($read_handle)) {
+        $args = ['%scheme' => $scheme_from, '%file' => $filepath];
+        $context['results']['errors'][] = [
+          'The file %scheme://%file could not be opened.', $args,
+        ];
+        return;
+      }
+
+      $success = $factory->getFilesystem($scheme_to)->putStream($filepath, $read_handle);
+
+      if (!$success) {
+        $args = ['%scheme' => $scheme_to, '%file' => $filepath];
+        $context['results']['errors'][] = [
+          'The file %scheme://%file could not be saved.', $args,
+        ];
+      }
+    }
+
+    // Catch all exceptions so we don't break batching. The types of exceptions
+    // that adapters can throw varies greatly.
+    catch (\Exception $e) {
+      $context['results']['errors'][] = [
+        'An error occurred while copying %file.', ['%file' => $filepath],
+      ];
+      $context['results']['errors'][] = $e->getMessage();
+
+      watchdog_exception('flysystem', $e);
+    }
+
+    if (isset($read_handle) && is_resource($read_handle)) {
+      fclose($read_handle);
+    }
+  }
+
+  /**
+   * Finish batch.
+   */
+  public static function finishBatch($success, array $results, array $operations) {
+    $messenger = \Drupal::messenger();
+    if (!$success) {
+      // An error occurred.
+      // $operations contains the operations that remained unprocessed.
+      $args = ['%file' => reset($operations)[2]];
+      $messenger->addError(\Drupal::translation()->translate('An error occurred while syncing: %file', $args));
+      return;
+    }
+
+    if (empty($results['errors'])) {
+      $messenger->addStatus(\Drupal::translation()->translate('File synchronization finished successfully.'));
+      return;
+    }
+
+    foreach ($results['errors'] as $error) {
+      if (is_array($error)) {
+        $messenger->addError(\Drupal::translation()->translate($error[0], $error[1]), TRUE);
+        \Drupal::logger('flysystem')->error($error[0], $error[1]);
+      }
+      else {
+        $messenger->addError(Html::escape($error), TRUE);
+      }
+    }
+    $messenger->addWarning(\Drupal::translation()->translate('File synchronization experienced errors.'));
+  }
+
+  /**
+   * Returns the file list for a scheme.
+   *
+   * @param string $scheme
+   *   The scheme.
+   *
+   * @return string[]
+   *   A list of files.
+   */
+  protected function getFileList($scheme) {
+    $filesystem = $this->factory->getFilesystem($scheme);
+
+    $files = array_filter($filesystem->listContents('', TRUE), function ($meta) {
+      return $meta['type'] === 'file';
+    });
+
+    return array_map(function (array $meta) {
+      return $meta['path'];
+    }, $files);
+  }
+
+}
diff --git a/src/Form/FieldMigration.php b/src/Form/FieldMigration.php
new file mode 100644
index 0000000..1da994e
--- /dev/null
+++ b/src/Form/FieldMigration.php
@@ -0,0 +1,429 @@
+<?php
+
+namespace Drupal\flysystem\Form;
+
+use Drupal\Core\File\FileSystemInterface;
+use Drupal\Core\Entity\EntityFieldManagerInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Entity\FieldableEntityInterface;
+use Drupal\Core\Field\FieldStorageDefinitionInterface;
+use Drupal\Core\Field\FieldTypePluginManagerInterface;
+use Drupal\Core\Field\Plugin\Field\FieldType\EntityReferenceItem;
+use Drupal\Core\Form\FormBase;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\StreamWrapper\StreamWrapperInterface;
+use Drupal\Core\StreamWrapper\StreamWrapperManagerInterface;
+use Drupal\field\Entity\FieldStorageConfig;
+use Drupal\flysystem\FlysystemFactory;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Configure file system settings for this site.
+ */
+class FieldMigration extends FormBase {
+
+  /**
+   * Entity Type Manager.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * Field Manager.
+   *
+   * @var \Drupal\Core\Entity\EntityFieldManagerInterface
+   */
+  protected $fieldManager;
+
+  /**
+   * Field Type Manager.
+   *
+   * @var \Drupal\Core\Field\FieldTypePluginManagerInterface
+   */
+  protected $fieldTypeManager;
+
+  /**
+   * The Flysystem factory.
+   *
+   * @var \Drupal\flysystem\FlysystemFactory
+   */
+  protected $factory;
+
+  /**
+   * Stream Wrapper Manager.
+   *
+   * @var \Drupal\Core\StreamWrapper\StreamWrapperManagerInterface
+   */
+  protected $streamWrapperManager;
+
+  /**
+   * Constructs a FieldMigration object.
+   *
+   * @param \Drupal\flysystem\FlysystemFactory $factory
+   *   The FlysystemF factory.
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   Entity type manager.
+   * @param \Drupal\Core\Entity\EntityFieldManagerInterface $field_manager
+   *   Field manager.
+   * @param \Drupal\Core\Field\FieldTypePluginManagerInterface $field_type_manager
+   *   Field type manager.
+   * @param \Drupal\Core\StreamWrapper\StreamWrapperManagerInterface $stream_wrapper_manager
+   *   Stream wrapper manager.
+   */
+  public function __construct(
+    FlysystemFactory $factory,
+    EntityTypeManagerInterface $entity_type_manager,
+    EntityFieldManagerInterface $field_manager,
+    FieldTypePluginManagerInterface $field_type_manager,
+    StreamWrapperManagerInterface $stream_wrapper_manager,
+  ) {
+
+    $this->factory = $factory;
+    $this->entityTypeManager = $entity_type_manager;
+    $this->fieldManager = $field_manager;
+    $this->fieldTypeManager = $field_type_manager;
+    $this->streamWrapperManager = $stream_wrapper_manager;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container) {
+    return new static(
+      $container->get('flysystem_factory'),
+      $container->get('entity_type.manager'),
+      $container->get('entity_field.manager'),
+      $container->get('plugin.manager.field.field_type'),
+      $container->get('stream_wrapper_manager')
+    );
+  }
+
+  /**
+   * Callback for ajax requests.
+   *
+   * @param array $form
+   *   Form array.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   Form State object.
+   *
+   * @return array
+   *   Form array.
+   */
+  public static function ajaxCallback(
+    array $form,
+    FormStateInterface $form_state,
+  ) {
+    return $form;
+  }
+
+  /**
+   * Migrate the storage of the files in the field of the given entity.
+   *
+   * @param string $entity_type
+   *   Entity type machine name.
+   * @param string $entity_id
+   *   Entity id.
+   * @param string $field
+   *   Field name.
+   * @param string $scheme
+   *   Scheme.
+   *
+   * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
+   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   */
+  public static function migrateFieldStorage(
+    $entity_type,
+    $entity_id,
+    $field,
+    $scheme,
+  ) {
+    $storage = \Drupal::entityTypeManager()->getStorage($entity_type);
+
+    /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */
+    $entity = $storage->load($entity_id);
+
+    /** @var \Drupal\Core\Field\EntityReferenceFieldItemListInterface $entityReferenceField */
+    $entityReferenceField = $entity->get($field);
+    /** @var \Drupal\file\FileInterface[] $files */
+    $files = $entityReferenceField->referencedEntities();
+
+    foreach ($files as $file) {
+      if (!file_exists($file->getFileUri())) {
+        continue;
+      }
+
+      [$current_scheme, $path] = explode('://', $file->getFileUri());
+
+      if ($current_scheme === $scheme) {
+        continue;
+      }
+
+      $destination = "$scheme://$path";
+      $destination_dir = \Drupal::service('file_system')->dirname($destination);
+
+      \Drupal::service('file_system')->prepareDirectory(
+                $destination_dir,
+                FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS
+              );
+
+      copy($file->getFileUri(), $destination);
+      $source = clone $file;
+
+      $file->setFileUri($destination);
+      $file->save();
+
+      // Inform modules that the file has been moved.
+      \Drupal::moduleHandler()->invokeAll('file_move', [$file, $source]);
+
+      // Delete the original if it's not in use elsewhere.
+      if (!\Drupal::service('file.usage')->listUsage($source)) {
+        $source->delete();
+      }
+    }
+  }
+
+  /**
+   * Update field settings.
+   *
+   * @param string $entity_type
+   *   Entity Type with field.
+   * @param string $field_name
+   *   Field Name.
+   * @param string $scheme
+   *   URI Scheme for updated field.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   */
+  public static function updateFieldSettings(
+    $entity_type,
+    $field_name,
+    $scheme,
+  ) {
+    $field_storage = FieldStorageConfig::loadByName($entity_type, $field_name);
+    $field_storage->setSetting('uri_scheme', $scheme);
+    $field_storage->save();
+
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFormId() {
+    return 'flysystem_field_migration';
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
+   */
+  public function buildForm(array $form, FormStateInterface $form_state) {
+    $entity_type = $form_state->getValue('entity_type');
+    $field = $form_state->getValue('field');
+    $scheme = $form_state->getValue('scheme');
+
+    $form['update_field_settings'] = [
+      '#type' => 'checkbox',
+      '#title' => $this->t('Update field settings'),
+      '#default_value' => FALSE,
+    ];
+
+    $form['actions'] = [
+      '#type' => 'actions',
+      '#weight' => 100,
+    ];
+    $form['actions']['submit'] = [
+      '#type' => 'submit',
+      '#value' => $this->t('Migrate'),
+      '#disabled' => TRUE,
+    ];
+
+    $form['#prefix'] = '<div id="flysystem-field-options-ajax-wrapper">';
+    $form['#suffix'] = '</div>';
+
+    $form['entity_type'] = [
+      '#title' => $this->t('Entity type'),
+      '#type' => 'select',
+      '#options' => $this->getEntityTypeOptions(),
+      '#required' => TRUE,
+      '#ajax' => [
+        'callback' => '::ajaxCallback',
+        'wrapper' => 'flysystem-field-options-ajax-wrapper',
+      ],
+    ];
+
+    if (!$entity_type) {
+      return $form;
+    }
+
+    $form['field'] = [
+      '#title' => $this->t('Field'),
+      '#type' => 'select',
+      '#options' => $this->getFieldOptions($entity_type),
+      '#required' => TRUE,
+      '#ajax' => [
+        'callback' => '::ajaxCallback',
+        'wrapper' => 'flysystem-field-options-ajax-wrapper',
+      ],
+    ];
+
+    if (!$field) {
+      return $form;
+    }
+
+    $scheme_options = $this->streamWrapperManager->getNames(
+      StreamWrapperInterface::WRITE_VISIBLE
+    );
+
+    $fields = $this->getFileFields($entity_type);
+    $existing_scheme = $fields[$field]->getSettings()['uri_scheme'];
+    $scheme_label = $scheme_options[$existing_scheme];
+
+    $form['scheme'] = [
+      '#title' => $this->t('Migrate to'),
+      '#type' => 'select',
+      '#options' => $scheme_options,
+      '#description' => $this->t(
+        'This field currently stores files in the %scheme scheme.',
+        ['%scheme' => $scheme_label]
+      ),
+      '#ajax' => [
+        'callback' => '::ajaxCallback',
+        'wrapper' => 'flysystem-field-options-ajax-wrapper',
+      ],
+      '#required' => TRUE,
+    ];
+
+    if (!$scheme) {
+      return $form;
+    }
+
+    unset($form['actions']['submit']['#disabled']);
+
+    return $form;
+  }
+
+  /**
+   * Get EntityType options.
+   *
+   * @return array
+   *   Array of options.
+   */
+  protected function getEntityTypeOptions() {
+    $entity_type_options = [];
+
+    foreach ($this->entityTypeManager->getDefinitions() as $entity_type) {
+      if ($entity_type->entityClassImplements(
+        FieldableEntityInterface::class
+      )) {
+        $entity_type_options[$entity_type->id()] = $entity_type->getLabel();
+      }
+    }
+
+    return $entity_type_options;
+  }
+
+  /**
+   * Get Field options.
+   *
+   * @param string $entity_type_id
+   *   Entity Type.
+   *
+   * @return array
+   *   Array of options.
+   *
+   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
+   */
+  protected function getFieldOptions($entity_type_id) {
+    return array_map(
+      static function (FieldStorageDefinitionInterface $field) {
+        return $field->getLabel();
+      },
+      $this->getFileFields($entity_type_id)
+    );
+  }
+
+  /**
+   * Get file fields by entity type.
+   *
+   * @param string $entity_type_id
+   *   Entity Type.
+   *
+   * @return array
+   *   Array of file fields.
+   *
+   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
+   */
+  protected function getFileFields($entity_type_id) {
+    $fields = [];
+
+    foreach ($this->fieldManager->getFieldStorageDefinitions($entity_type_id) as $field) {
+      $field_type_definition = $this->fieldTypeManager->getDefinition(
+        $field->getType()
+      );
+
+      if (!is_a(
+        $field_type_definition['class'],
+        EntityReferenceItem::class,
+        TRUE
+      )) {
+        continue;
+      }
+
+      $fields[$field->getName()] = $field;
+    }
+
+    return $fields;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function validateForm(array &$form, FormStateInterface $form_state) {
+
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
+   * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
+   */
+  public function submitForm(array &$form, FormStateInterface $form_state) {
+    $entity_type = $form_state->getValue('entity_type');
+    $field = $form_state->getValue('field');
+    $scheme = $form_state->getValue('scheme');
+    $update_field_settings = (bool) $form_state->getValue('update_field_settings');
+
+    $query = $this->entityTypeManager->getStorage($entity_type)->getQuery();
+    $entity_ids = $query->exists($field)->accessCheck(FALSE)->execute();
+
+    $batch = [
+      'operations' => [],
+      'finished' => get_class($this) . '::finishBatch',
+      'title' => $this->t('Migrating fields'),
+      'init_message' => $this->t('Starting migration process.'),
+      'progress_message' => $this->t('Completed @current step of @total.'),
+      'error_message' => $this->t('Field migration has encountered an error.'),
+    ];
+
+    foreach ($entity_ids as $entity_id) {
+      $batch['operations'][] = [
+        get_class($this) . '::migrateFieldStorage',
+        [$entity_type, $entity_id, $field, $scheme],
+      ];
+    }
+
+    if ($update_field_settings) {
+      $batch['operations'][] = [
+        get_class($this) . '::updateFieldSettings',
+        [$entity_type, $field, $scheme],
+      ];
+    }
+
+    batch_set($batch);
+  }
+
+}
diff --git a/src/Form/FlysystemAdapterConfigForm.php b/src/Form/FlysystemAdapterConfigForm.php
deleted file mode 100644
index 8e60efa..0000000
--- a/src/Form/FlysystemAdapterConfigForm.php
+++ /dev/null
@@ -1,311 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem\Form;
-
-use Drupal\Component\Plugin\Exception\PluginException;
-use Drupal\Component\Render\MarkupInterface;
-use Drupal\Component\Utility\Html;
-use Drupal\Core\Entity\EntityForm;
-use Drupal\Core\Form\FormStateInterface;
-use Drupal\Core\Messenger\MessengerInterface;
-use Drupal\Core\Plugin\PluginFormInterface;
-use Drupal\Core\Render\Markup;
-use Drupal\flysystem\Entity\FlysystemAdapterConfig;
-use Drupal\flysystem\FlysystemAdapterConfigInterface;
-use Drupal\flysystem\FlysystemAdapterPluginManager;
-use Symfony\Component\DependencyInjection\ContainerInterface;
-
-/**
- * Flysystem_adapter_config form.
- */
-final class FlysystemAdapterConfigForm extends EntityForm {
-  /**
-   * The adapter plugin manager.
-   *
-   * @var \Drupal\flysystem\FlysystemAdapterPluginManager
-   */
-  protected $subAdapterPluginManager;
-
-  /**
-   * The messenger.
-   *
-   * @var \Drupal\Core\Messenger\MessengerInterface
-   */
-  protected $messenger;
-
-  /**
-   * Constructs a FlysystemAdapterConfigForm object.
-   *
-   * @param \Drupal\flysystem\FlysystemAdapterPluginManager $subadapter_plugin_manager
-   *   The adapter plugin manager.
-   * @param \Drupal\Core\Messenger\MessengerInterface $messenger
-   *   The messenger.
-   */
-  public function __construct(FlysystemAdapterPluginManager $subadapter_plugin_manager, MessengerInterface $messenger) {
-    $this->subAdapterPluginManager = $subadapter_plugin_manager;
-    $this->messenger = $messenger;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public static function create(ContainerInterface $container) {
-    $subadapter_plugin_manager = $container->get('plugin.manager.flysystem_adapter');
-    $messenger = $container->get('messenger');
-
-    return new static($subadapter_plugin_manager, $messenger);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function form(array $form, FormStateInterface $form_state): array {
-    // If the form is being rebuilt, rebuild the entity with the current form
-    // values.
-    if ($form_state->isRebuilding()) {
-      $this->entity = $this->buildEntity($form, $form_state);
-    }
-
-    $form = parent::form($form, $form_state);
-
-    /** @var \Drupal\flysystem\FlysystemAdapterConfigInterface $flysystem_adapter_config */
-    $flysystem_adapter_config = $this->getEntity();
-
-    // var_dump($flysystem_adapter_config); die;
-    // Set the page title according to whether we are creating or editing the
-    // adapter.
-    if ($flysystem_adapter_config->isNew()) {
-      $form['#title'] = $this->t('Configure a new Flysystem Adapter');
-    }
-    else {
-      $form['#title'] = $this->t('Edit Flysystem Adapter %label', ['%label' => $flysystem_adapter_config->label()]);
-    }
-
-    $this->buildEntityConfigForm($form, $form_state, $flysystem_adapter_config);
-    // Skip adding the adapter config form if we cleared the adapter form due to
-    // an error.
-    if ($form) {
-      $this->buildSubAdapterConfigForm($form, $form_state, $flysystem_adapter_config);
-    }
-    return $form;
-  }
-
-  /**
-   * Builds the form for the basic adapter configuration properties.
-   *
-   * @param array $form
-   *   The current form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
-   *   The current form state.
-   * @param \Drupal\flysystem\FlysystemAdapterConfigInterface $flysystem_adapter_config
-   *   The server that is being created or edited.
-   */
-  protected function buildEntityConfigForm(array &$form, FormStateInterface $form_state, FlysystemAdapterConfigInterface $flysystem_adapter_config) {
-    $form['label'] = [
-      '#type' => 'textfield',
-      '#title' => $this->t('Scheme'),
-      '#description' => $this->t('The scheme used to identify files managed with this adapter.'),
-      '#maxlength' => 255,
-      '#default_value' => $flysystem_adapter_config->label(),
-      '#required' => TRUE,
-    ];
-
-    $form['id'] = [
-      '#type' => 'machine_name',
-      '#default_value' => $flysystem_adapter_config->id(),
-      '#machine_name' => [
-        'exists' => [FlysystemAdapterConfig::class, 'load'],
-      ],
-      '#disabled' => !$flysystem_adapter_config->isNew(),
-    ];
-
-    $form['status'] = [
-      '#type' => 'checkbox',
-      '#title' => $this->t('Enabled'),
-      '#default_value' => $flysystem_adapter_config->status(),
-    ];
-
-    $form['description'] = [
-      '#type' => 'textarea',
-      '#title' => $this->t('Description'),
-      '#default_value' => $flysystem_adapter_config->getDescription(),
-    ];
-
-    $sub_adapters = $this->subAdapterPluginManager->getDefinitions();
-    $options = [];
-    $descriptions = [];
-    foreach ($sub_adapters as $subadapter_id => $definition) {
-      $config = $subadapter_id === $flysystem_adapter_config->getSubAdapterId() ? $flysystem_adapter_config->getSubAdapterConfig() : [];
-      $config['#flysystem_adapter_config'] = $flysystem_adapter_config;
-      try {
-        /** @var \Drupal\flysystem\FlysystemSubAdapterInterface $sub_adapter */
-        $sub_adapter = $this->subAdapterPluginManager
-          ->createInstance($subadapter_id, $config);
-      }
-      catch (PluginException) {
-        // @todo add graceful error handling.
-        continue;
-      }
-      $options[$subadapter_id] = $this->escapeHtml($sub_adapter->label());
-      $descriptions[$subadapter_id]['#description'] = $this->escapeHtml($sub_adapter->getDescription());
-
-    }
-    asort($options, SORT_NATURAL | SORT_FLAG_CASE);
-    if ($options) {
-      if (count($options) == 1) {
-        $flysystem_adapter_config->set('sub_adapter', key($options));
-      }
-      $form['sub_adapter'] = [
-        '#type' => 'radios',
-        '#title' => $this->t('Flysystem Adapters'),
-        '#description' => $this->t('Choose a Flysystem Adapter type to configure.'),
-        '#options' => $options,
-        '#default_value' => $flysystem_adapter_config->getSubAdapterId(),
-        '#required' => TRUE,
-        '#disabled' => !$flysystem_adapter_config->isNew(),
-        '#ajax' => [
-          'callback' => [get_class($this), 'buildAjaxBackendConfigForm'],
-          'wrapper' => 'flysystem-adapter-config-form',
-          'method' => 'replace',
-          'effect' => 'fade',
-        ],
-      ];
-      $form['sub_adapter'] += $descriptions;
-    }
-    /*
-    else {
-    // @todo update with link to documentation on D.O.
-    $url = 'https://www.drupal.org/docs/8/modules/search-api/getting-started/server-backends-and-features';
-    $args[':url'] = Url::fromUri($url)->toString();
-    $error = $this->t('There are no Flysystem Adapters available to configure. \
-    Install a <a href=":url">module that provides a Flysystem Adapter</a> \
-    to proceed.', $args);
-    $this->messenger->addError($error);
-    $form = [];
-    }
-     */
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  protected function actions(array $form, FormStateInterface $form_state) {
-    if ($form === []) {
-      return [];
-    }
-
-    return parent::actions($form, $form_state);
-  }
-
-  /**
-   * Builds the adapter-specific configuration form.
-   *
-   * @param array $form
-   *   The current form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
-   *   The current form state.
-   * @param \Drupal\flysystem\FlysystemAdapterConfigInterface $flysystem_adapter_config
-   *   The adapter that is being created or edited.
-   */
-  public function buildSubAdapterConfigForm(array &$form, FormStateInterface $form_state, FlysystemAdapterConfigInterface $flysystem_adapter_config) {
-    // var_dump($form_state); die;
-    // var_dump($flysystem_adapter_config); die(__METHOD__ . ":" . __LINE__);
-    // var_dump($form_state->getValues()); die(__METHOD__ . ":" . __LINE__);.
-    $form['sub_adapter_config'] = [];
-
-    if ($flysystem_adapter_config->hasValidSubAdapter()) {
-      // var_dump($flysystem_adapter_config); die(__METHOD__ . ":" . __LINE__);.
-      $sub_adapter_plugin = $flysystem_adapter_config->getSubAdapter();
-      $form_state->set('sub_adapter', $sub_adapter_plugin->getPluginId());
-      $form_state->set(['sub_adapter_config', 'schema'], $flysystem_adapter_config->getSubAdapterConfigItem('schema'));
-
-      if ($sub_adapter_plugin instanceof PluginFormInterface) {
-        if ($form_state->isRebuilding()) {
-          $this->messenger->addWarning($this->t('Configure the selected Flysystem Adapter.'));
-        }
-
-        // Attach the subadapter plugin configuration form.
-        $form['sub_adapter_config'] = $sub_adapter_plugin->buildSubConfigurationForm($form['sub_adapter_config'], $form_state, $flysystem_adapter_config);
-
-        // Modify the backend plugin configuration container element.
-        $form['sub_adapter_config']['#type'] = 'details';
-        $form['sub_adapter_config']['#title'] = $this->t('Configure %plugin configuration', ['%plugin' => $sub_adapter_plugin->label()]);
-        $form['sub_adapter_config']['#open'] = TRUE;
-        // var_dump($form['sub_adapter_config']); die;.
-      }
-    }
-    // Only notify the user of a missing backend plugin if we're editing an
-    // existing server.
-    elseif (!$flysystem_adapter_config->isNew()) {
-      $this->messenger->addError($this->t('The Flysystem adapter plugin is missing or invalid.'));
-      return;
-    }
-    $form['sub_adapter_config'] += [
-      '#type' => 'container',
-    ];
-    $form['sub_adapter_config']['#attributes']['id'] = 'flysystem-adapter-config-form';
-    $form['sub_adapter_config']['#tree'] = TRUE;
-  }
-
-  /**
-   * Handles switching the selected adapter plugin.
-   *
-   * @param array $form
-   *   The current form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
-   *   The current form state.
-   *
-   * @return array
-   *   The part of the form to return as AJAX.
-   */
-  public static function buildAjaxAdapterConfigForm(array $form, FormStateInterface $form_state) {
-    // The work is already done in form(), where we rebuild the entity according
-    // to the current form values and then create the backend configuration form
-    // based on that. So we just need to return the relevant part of the form
-    // here.
-    return $form['sub_adapter_config'];
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function save(array $form, FormStateInterface $form_state): int {
-    $result = parent::save($form, $form_state);
-    $this->messenger->addStatus($this->t('The Flysystem adapter was successfully saved.'));
-    $message_args = ['%label' => $this->entity->label()];
-    $message = '';
-    switch ($result) {
-      case \SAVED_NEW:
-        $message = $this->t('Created new example %label.', $message_args);
-        break;
-
-      case \SAVED_UPDATED:
-        $message = $this->t('Updated example %label.', $message_args);
-        break;
-    }
-    $this->messenger()->addStatus($message);
-    $form_state->setRedirectUrl($this->entity->toUrl('collection'));
-    return $result;
-  }
-
-  /**
-   * Escapes HTML special characters in plain text, if necessary.
-   *
-   * @param string|\Drupal\Component\Render\MarkupInterface $text
-   *   The text to escape.
-   *
-   * @return \Drupal\Component\Render\MarkupInterface
-   *   If a markup object was passed as $text, it is returned as-is. Otherwise,
-   *   the text is escaped and returned
-   */
-  private function escapeHtml($text) {
-    if ($text instanceof MarkupInterface) {
-      return $text;
-    }
-
-    return Markup::create(Html::escape((string) $text));
-  }
-
-}
diff --git a/src/ImageStyleCopier.php b/src/ImageStyleCopier.php
new file mode 100644
index 0000000..34af014
--- /dev/null
+++ b/src/ImageStyleCopier.php
@@ -0,0 +1,201 @@
+<?php
+
+namespace Drupal\flysystem;
+
+use Drupal\Component\Utility\Crypt;
+use Drupal\Core\Cache\CacheTagsInvalidatorInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\File\FileExists;
+use Drupal\Core\File\FileSystemInterface;
+use Drupal\Core\Lock\LockBackendInterface;
+use Drupal\image\ImageStyleInterface;
+use Psr\Log\LoggerInterface;
+use Symfony\Component\EventDispatcher\EventSubscriberInterface;
+use Symfony\Component\HttpKernel\KernelEvents;
+
+/**
+ * Copies an image style from temporary storage to a flysystem adapter.
+ *
+ * This class is registered to run on the kernel's terminate event so it doesn't
+ * block image delivery.
+ */
+class ImageStyleCopier implements EventSubscriberInterface {
+
+  /**
+   * The cache tags invalidator.
+   *
+   * @var \Drupal\Core\Cache\CacheTagsInvalidatorInterface
+   */
+  protected $cacheTagsInvalidator;
+
+  /**
+   * An array of image derivatives to copy.
+   *
+   * @var array
+   */
+  protected $copyTasks = [];
+
+  /**
+   * The entity type manager.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * The file system.
+   *
+   * @var \Drupal\Core\File\FileSystem
+   */
+  protected $fileSystem;
+
+  /**
+   * The lock backend interface.
+   *
+   * @var \Drupal\Core\Lock\LockBackendInterface
+   */
+  protected $lock;
+
+  /**
+   * The system logger.
+   *
+   * @var \Psr\Log\LoggerInterface
+   */
+  protected $logger;
+
+  /**
+   * Constructs an ImageStyleCopier.
+   *
+   * @param \Drupal\Core\Lock\LockBackendInterface $lock
+   *   The lock backend.
+   * @param \Drupal\Core\File\FileSystemInterface $file_system
+   *   The file system.
+   * @param \Psr\Log\LoggerInterface $logger
+   *   The system logger.
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   The entity type manager.
+   * @param \Drupal\Core\Cache\CacheTagsInvalidatorInterface $cache_tags_invalidator
+   *   The cache tags invalidator.
+   */
+  public function __construct(
+    LockBackendInterface $lock,
+    FileSystemInterface $file_system,
+    LoggerInterface $logger,
+    EntityTypeManagerInterface $entity_type_manager,
+    CacheTagsInvalidatorInterface $cache_tags_invalidator,
+  ) {
+    $this->lock = $lock;
+    $this->fileSystem = $file_system;
+    $this->logger = $logger;
+    $this->entityTypeManager = $entity_type_manager;
+    $this->cacheTagsInvalidator = $cache_tags_invalidator;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function getSubscribedEvents() {
+    $events = [];
+    $events[KernelEvents::TERMINATE] = 'processCopyTasks';
+
+    return $events;
+  }
+
+  /**
+   * Adds a task to generate and copy an image derivative.
+   *
+   * @param string $temporary_uri
+   *   The URI of the temporary image to copy from.
+   * @param string $source_uri
+   *   The URI of the source image.
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style being copied.
+   */
+  public function addCopyTask($temporary_uri, $source_uri, ImageStyleInterface $image_style) {
+    $this->copyTasks[] = func_get_args();
+  }
+
+  /**
+   * Processes all image copy tasks.
+   */
+  public function processCopyTasks() {
+    foreach ($this->copyTasks as $task) {
+      [$temporary_uri, $source_uri, $image_style] = $task;
+      $this->copyToAdapter($temporary_uri, $source_uri, $image_style);
+    }
+
+    $this->copyTasks = [];
+  }
+
+  /**
+   * Generates an image with the remote stream wrapper.
+   *
+   * @param string $temporary_uri
+   *   The temporary file URI to copy to the adapter.
+   * @param string $source_uri
+   *   The URI of the source image.
+   * @param \Drupal\image\ImageStyleInterface $image_style
+   *   The image style to generate.
+   */
+  protected function copyToAdapter($temporary_uri, $source_uri, ImageStyleInterface $image_style) {
+    $derivative_uri = $image_style->buildUri($source_uri);
+
+    // file_unmanaged_copy() doesn't distinguish between a FALSE return due to
+    // and error or a FALSE return due to an existing file. If we can't acquire
+    // this lock, we know another thread is uploading the image and we ignore
+    // uploading it in this thread.
+    $lock_name = 'flysystem_copy_to_adapter:' . $image_style->id() . ':' . Crypt::hashBase64($source_uri);
+
+    if (!$this->lock->acquire($lock_name)) {
+      $this->logger->info('Another copy of %image to %destination is in progress',
+      [
+        '%image' => $temporary_uri,
+        '%destination' => $derivative_uri,
+      ]);
+      return;
+    }
+
+    try {
+      // Get the folder for the final location of this style.
+      $directory = $this->fileSystem->dirname($derivative_uri);
+
+      // Build the destination folder tree if it doesn't already exist.
+      if (!$this->fileSystem->prepareDirectory($directory, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS)) {
+        $this->logger->error('Failed to create image style directory: %directory', ['%directory' => $directory]);
+        return;
+      }
+
+      if (!$this->fileSystem->copy($temporary_uri, $derivative_uri, FileExists::Replace)) {
+        $this->logger->error('Unable to copy %image to %destination', [
+          '%image' => $temporary_uri,
+          '%directory' => $directory,
+        ]);
+        return;
+      }
+
+    }
+    finally {
+      $this->fileSystem->delete($temporary_uri);
+      $this->invalidateTags($source_uri);
+      $this->lock->release($lock_name);
+    }
+  }
+
+  /**
+   * Invalidates the cache tags for a file URI.
+   *
+   * @param string $uri
+   *   The file URI.
+   */
+  protected function invalidateTags($uri) {
+    $file = $this->entityTypeManager
+      ->getStorage('file')
+      ->loadByProperties(['uri' => $uri]);
+
+    if ($file) {
+      $file = reset($file);
+      $this->cacheTagsInvalidator->invalidateTags($file->getCacheTagsToInvalidate());
+    }
+  }
+
+}
diff --git a/src/Logger/Convert.php b/src/Logger/Convert.php
new file mode 100644
index 0000000..12376ad
--- /dev/null
+++ b/src/Logger/Convert.php
@@ -0,0 +1,37 @@
+<?php
+
+namespace Drupal\flysystem\Logger;
+
+use Drupal\Core\Logger\RfcLogLevel;
+
+/**
+ * Converts various log levels.
+ */
+class Convert {
+
+  /**
+   * Coverts from RFC 5424 to requirements error constants.
+   *
+   * @param int $level
+   *   The RFC log value.
+   *
+   * @return int
+   *   The requirements error value.
+   */
+  public static function rfcToHookRequirements($level) {
+    if ($level <= RfcLogLevel::ERROR) {
+      return REQUIREMENT_ERROR;
+    }
+
+    if ($level == RfcLogLevel::WARNING) {
+      return REQUIREMENT_WARNING;
+    }
+
+    if ($level == RfcLogLevel::NOTICE || $level == RfcLogLevel::INFO) {
+      return REQUIREMENT_INFO;
+    }
+
+    return REQUIREMENT_OK;
+  }
+
+}
diff --git a/src/PathProcessor/FlysystemImageStyleRedirectProcessor.php b/src/PathProcessor/FlysystemImageStyleRedirectProcessor.php
new file mode 100644
index 0000000..51a06c9
--- /dev/null
+++ b/src/PathProcessor/FlysystemImageStyleRedirectProcessor.php
@@ -0,0 +1,47 @@
+<?php
+
+namespace Drupal\flysystem\PathProcessor;
+
+use Drupal\Core\PathProcessor\InboundPathProcessorInterface;
+use Symfony\Component\HttpFoundation\Request;
+
+/**
+ * Defines a path processor to rewrite Flysystem URLs.
+ *
+ * As the route system does not allow arbitrary amount of parameters convert
+ * the file path to a query parameter on the request.
+ */
+class FlysystemImageStyleRedirectProcessor implements InboundPathProcessorInterface {
+
+  /**
+   * The base menu path for style redirects.
+   */
+  const STYLES_PATH = '/_flysystem-style-redirect';
+
+  /**
+   * {@inheritdoc}
+   */
+  public function processInbound($path, Request $request) {
+    // Quick exit.
+    if (strpos($path, static::STYLES_PATH . '/') !== 0) {
+      return $path;
+    }
+
+    // Stream wrapper protocols must conform to /^[a-zA-Z0-9+.-]+$/
+    // Via php_stream_wrapper_scheme_validate() in the PHP source.
+    $matches = [];
+    if (!preg_match('|^' . static::STYLES_PATH . '/([^/]+)/([a-zA-Z0-9+.-]+)/|', $path, $matches)) {
+      return $path;
+    }
+
+    $file = substr($path, strlen($matches[0]));
+    $image_style = $matches[1];
+    $scheme = $matches[2];
+
+    // Set the file as query parameter.
+    $request->query->set('file', $file);
+
+    return static::STYLES_PATH . '/' . $image_style . '/' . $scheme . '/' . hash('sha256', $file);
+  }
+
+}
diff --git a/src/PathProcessor/FlysystemPathProcessor.php b/src/PathProcessor/FlysystemPathProcessor.php
new file mode 100644
index 0000000..29c8a9b
--- /dev/null
+++ b/src/PathProcessor/FlysystemPathProcessor.php
@@ -0,0 +1,49 @@
+<?php
+
+namespace Drupal\flysystem\PathProcessor;
+
+use Drupal\Core\PathProcessor\InboundPathProcessorInterface;
+use Symfony\Component\HttpFoundation\Request;
+
+/**
+ * Defines a path processor to rewrite Flysystem URLs.
+ *
+ * As the route system does not allow arbitrary amount of parameters convert
+ * the file path to a query parameter on the request.
+ */
+class FlysystemPathProcessor implements InboundPathProcessorInterface {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function processInbound($path, Request $request) {
+    // Quick exit.
+    if (strpos($path, '/_flysystem/') !== 0) {
+      return $path;
+    }
+
+    // Stream wrapper protocols must conform to /^[a-zA-Z0-9+.-]+$/
+    // Via php_stream_wrapper_scheme_validate() in the PHP source.
+    if (!preg_match('|^/_flysystem/([a-zA-Z0-9+.-]+)/|', $path, $matches)) {
+      return $path;
+    }
+
+    $rest = substr($path, strlen($matches[0]));
+
+    // Support image styles.
+    if (strpos($rest, 'styles/') === 0 && substr_count($rest, '/') >= 3) {
+      [, $image_style, $scheme, $file] = explode('/', $rest, 4);
+
+      // Set the file as query parameter.
+      $request->query->set('file', $file);
+
+      return '/_flysystem/styles/' . $image_style . '/' . $scheme;
+    }
+
+    // Routes to FileDownloadController::download().
+    $request->query->set('file', $rest);
+
+    return '/_flysystem/' . $matches[1];
+  }
+
+}
diff --git a/src/PathProcessor/LocalPathProcessor.php b/src/PathProcessor/LocalPathProcessor.php
new file mode 100644
index 0000000..7019cae
--- /dev/null
+++ b/src/PathProcessor/LocalPathProcessor.php
@@ -0,0 +1,71 @@
+<?php
+
+namespace Drupal\flysystem\PathProcessor;
+
+use Drupal\Core\PathProcessor\InboundPathProcessorInterface;
+use Drupal\Core\Site\Settings;
+use Symfony\Component\HttpFoundation\Request;
+
+/**
+ * Defines a path processor to serve public files for the local adapter.
+ *
+ * As the route system does not allow arbitrary amount of parameters convert
+ * the file path to a query parameter on the request.
+ */
+class LocalPathProcessor implements InboundPathProcessorInterface {
+
+  /**
+   * The root of the local filesystem.
+   *
+   * @var string
+   */
+  protected $root;
+
+  /**
+   * The scheme.
+   *
+   * @var string
+   */
+  protected $scheme;
+
+  /**
+   * Constructs a LocalPathProcessor.
+   *
+   * @param string $scheme
+   *   The public scheme.
+   */
+  public function __construct($scheme) {
+    $this->scheme = $scheme;
+    $settings = Settings::get('flysystem', []);
+    $this->root = $settings[$scheme]['config']['root'];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function processInbound($path, Request $request) {
+    if (strpos($path, '/' . $this->root . '/') !== 0) {
+      return $path;
+    }
+
+    $rest = substr($path, strlen($this->root) + 2);
+
+    if (preg_match('#^(js|css)/#', $rest)) {
+      return $path;
+    }
+
+    if (strpos($rest, 'styles/') === 0 && substr_count($rest, '/') >= 3) {
+      [, $image_style, $scheme, $file] = explode('/', $rest, 4);
+
+      // Set the file as query parameter.
+      $request->query->set('file', $file);
+
+      return '/' . $this->root . '/styles/' . $image_style . '/' . $scheme;
+    }
+
+    $request->query->set('file', $rest);
+
+    return '/' . $this->root;
+  }
+
+}
diff --git a/src/Plugin/FlysystemAdapterPluginBase.php b/src/Plugin/FlysystemAdapterPluginBase.php
deleted file mode 100644
index 494cb34..0000000
--- a/src/Plugin/FlysystemAdapterPluginBase.php
+++ /dev/null
@@ -1,105 +0,0 @@
-<?php
-
-declare(strict_types=1);
-
-namespace Drupal\flysystem\Plugin;
-
-use Drupal\Component\Plugin\PluginBase;
-use Drupal\Core\Form\FormStateInterface;
-use Drupal\Core\Plugin\PluginDependencyTrait;
-use Drupal\Core\StringTranslation\StringTranslationTrait;
-use Symfony\Component\DependencyInjection\ContainerInterface;
-
-/**
- * Base class for flysystem_adapter plugins.
- */
-abstract class FlysystemAdapterPluginBase extends PluginBase {
-
-  use PluginDependencyTrait {
-    getPluginDependencies as traitGetPluginDependencies;
-    calculatePluginDependencies as traitCalculatePluginDependencies;
-  }
-  use StringTranslationTrait;
-
-  /**
-   * The adapter plugin configuration.
-   *
-   * @var array
-   */
-  protected $sub_adapter_config = []; // phpcs:ignore
-
-  /**
-   * {@inheritdoc}
-   */
-  public function __construct(array $configuration, $plugin_id, array $plugin_definition) {
-    $configuration += $this->defaultConfiguration();
-    parent::__construct($configuration, $plugin_id, $plugin_definition);
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
-    $plugin = new static($configuration, $plugin_id, $plugin_definition);
-
-    /** @var \Drupal\Core\StringTranslation\TranslationInterface $translation */
-    $translation = $container->get('string_translation');
-    $plugin->setStringTranslation($translation);
-
-    return $plugin;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function calculateDependencies() {
-    return [];
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function defaultConfiguration() {
-    return [];
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getConfiguration() {
-    return $this->configuration;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function setConfiguration(array $configuration) {
-    $this->configuration = $configuration + $this->defaultConfiguration();
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function label(): string {
-    // Cast the label to a string since it is a TranslatableMarkup object.
-    return (string) $this->pluginDefinition['label'];
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
-    return $form;
-  }
-
-  /**
-   * {@inheritdoc}
-   */
-  public function validateConfigurationForm(array &$form, FormStateInterface $form_state) {}
-
-  /**
-   * {@inheritdoc}
-   */
-  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {}
-
-}
diff --git a/src/Plugin/FlysystemAdapterPluginTrait.php b/src/Plugin/FlysystemAdapterPluginTrait.php
deleted file mode 100644
index 81a9aae..0000000
--- a/src/Plugin/FlysystemAdapterPluginTrait.php
+++ /dev/null
@@ -1,20 +0,0 @@
-<?php
-
-namespace Drupal\flysystem\Plugin;
-
-/**
- * Provides defined methods required for Adapter plugin config entities.
- *
- * @see \Drupal\flysystem\FlysystemSubAdapterInterface
- * @see \Drupal\flysystem\FlysystemAdapterInterface
- */
-trait FlysystemAdapterPluginTrait {
-
-  /**
-   * {@inheritdoc}
-   */
-  public function getDefaultPermissions() {
-    return $this->defaultPermissions;
-  }
-
-}
diff --git a/src/Plugin/FlysystemPluginInterface.php b/src/Plugin/FlysystemPluginInterface.php
new file mode 100644
index 0000000..22771fc
--- /dev/null
+++ b/src/Plugin/FlysystemPluginInterface.php
@@ -0,0 +1,48 @@
+<?php
+
+namespace Drupal\flysystem\Plugin;
+
+/**
+ * Interface definition for Flysystem plugins.
+ */
+interface FlysystemPluginInterface {
+
+  /**
+   * Returns the Flysystem adapter.
+   *
+   * Plugins should not keep references to the adapter. If a plugin needs to
+   * perform filesystem operations, it should either use a scheme:// or have the
+   * \Drupal\flysystem\FlysystemFactory injected.
+   *
+   * @return \League\Flysystem\AdapterInterface
+   *   The Flysystem adapter.
+   */
+  public function getAdapter();
+
+  /**
+   * Returns a web accessible URL for the resource.
+   *
+   * This function should return a URL that can be embedded in a web page
+   * and accessed from a browser. For example, the external URL of
+   * "youtube://abc123" might be
+   * "http://www.youtube.com/watch?v=abc123".
+   *
+   * @param string $uri
+   *   The URI to provide a URL for.
+   *
+   * @return string
+   *   Returns a string containing a web accessible URL for the resource.
+   */
+  public function getExternalUrl($uri);
+
+  /**
+   * Checks the sanity of the filesystem.
+   *
+   * If this is a local filesystem, .htaccess file should be in place.
+   *
+   * @return array
+   *   A list of error messages.
+   */
+  public function ensure($force = FALSE);
+
+}
diff --git a/src/Plugin/FlysystemPluginManager.php b/src/Plugin/FlysystemPluginManager.php
new file mode 100644
index 0000000..19135a6
--- /dev/null
+++ b/src/Plugin/FlysystemPluginManager.php
@@ -0,0 +1,57 @@
+<?php
+
+namespace Drupal\flysystem\Plugin;
+
+use Drupal\Component\Plugin\FallbackPluginManagerInterface;
+use Drupal\Core\Cache\CacheBackendInterface;
+use Drupal\Core\Extension\ModuleHandlerInterface;
+use Drupal\Core\Plugin\DefaultPluginManager;
+
+/**
+ * Manages Flysystem plugins.
+ */
+class FlysystemPluginManager extends DefaultPluginManager implements FallbackPluginManagerInterface {
+
+  /**
+   * Constructs a Flysystem object.
+   *
+   * @param \Traversable $namespaces
+   *   An object that implements \Traversable which contains the root paths
+   *   keyed by the corresponding namespace to look for plugin implementations.
+   * @param \Drupal\Core\Cache\CacheBackendInterface $cache_backend
+   *   Cache backend instance to use.
+   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   *   The module handler to invoke the alter hook with.
+   */
+  public function __construct(\Traversable $namespaces, CacheBackendInterface $cache_backend, ModuleHandlerInterface $module_handler) {
+    parent::__construct('Flysystem', $namespaces, $module_handler, 'Drupal\flysystem\Plugin\FlysystemPluginInterface', 'Drupal\flysystem\Annotation\Adapter');
+    $this->setCacheBackend($cache_backend, 'flysystem_plugins');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFallbackPluginId($plugin_id, array $configuration = []) {
+    return 'missing';
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function alterDefinitions(&$definitions) {
+    // Remove definitions that are missing necessary extensions.
+    foreach ($definitions as $id => $definition) {
+      foreach ($definition['extensions'] as $extension) {
+        if (extension_loaded($extension)) {
+          continue;
+        }
+
+        unset($definitions[$id]);
+        break;
+      }
+    }
+
+    parent::alterDefinitions($definitions);
+  }
+
+}
diff --git a/src/Plugin/FlysystemUrlTrait.php b/src/Plugin/FlysystemUrlTrait.php
new file mode 100644
index 0000000..3027a17
--- /dev/null
+++ b/src/Plugin/FlysystemUrlTrait.php
@@ -0,0 +1,95 @@
+<?php
+
+namespace Drupal\flysystem\Plugin;
+
+use Drupal\Core\Url;
+
+/**
+ * Helper trait for generating URLs from adapter plugins.
+ */
+trait FlysystemUrlTrait {
+
+  /**
+   * Returns a web accessible URL for the resource.
+   *
+   * This function should return a URL that can be embedded in a web page
+   * and accessed from a browser. For example, the external URL of
+   * "youtube://abc123" might be
+   * "http://www.youtube.com/watch?v=abc123".
+   *
+   * @param string $uri
+   *   The URI to provide a URL for.
+   *
+   * @return string
+   *   Returns a string containing a web accessible URL for the resource.
+   */
+  public function getExternalUrl($uri) {
+    $path = str_replace('\\', '/', $this->getTarget($uri));
+    $scheme = $this->getScheme($uri);
+    $arguments = [
+      'scheme' => $scheme,
+      'filepath' => $path,
+    ];
+    return Url::fromRoute('flysystem.serve', $arguments, ['absolute' => TRUE])->toString();
+  }
+
+  /**
+   * Returns the target file path of a URI.
+   *
+   * @param string $uri
+   *   The URI.
+   *
+   * @return string
+   *   The file path of the URI.
+   *
+   * @throws \LogicException
+   */
+  protected function getTarget($uri) {
+    $path = substr($uri, strpos($uri, '://') + 3);
+    $path = str_replace('\\', '/', $path);
+
+    while (preg_match('#\p{C}+|^\./#u', $path)) {
+      $path = preg_replace('#\p{C}+|^\./#u', '', $path);
+    }
+
+    $parts = [];
+
+    foreach (explode('/', $path) as $part) {
+      switch ($part) {
+        case '':
+        case '.':
+          break;
+
+        case '..':
+          if (empty($parts)) {
+            throw new \LogicException(
+                  'Path is outside of the defined root, path: [' . $path . ']'
+              );
+          }
+          array_pop($parts);
+          break;
+
+        default:
+          $parts[] = $part;
+          break;
+      }
+    }
+
+    return implode('/', $parts);
+
+  }
+
+  /**
+   * Returns the scheme from the internal URI.
+   *
+   * @param string $uri
+   *   The URI.
+   *
+   * @return string
+   *   The scheme.
+   */
+  protected function getScheme($uri) {
+    return substr($uri, 0, strpos($uri, '://'));
+  }
+
+}
diff --git a/src/Plugin/ImageStyleGenerationTrait.php b/src/Plugin/ImageStyleGenerationTrait.php
new file mode 100644
index 0000000..a729dba
--- /dev/null
+++ b/src/Plugin/ImageStyleGenerationTrait.php
@@ -0,0 +1,97 @@
+<?php
+
+namespace Drupal\flysystem\Plugin;
+
+use Drupal\Component\Utility\Crypt;
+use Drupal\image\Entity\ImageStyle;
+use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
+
+/**
+ * Helper trait for generating URLs from adapter plugins.
+ */
+trait ImageStyleGenerationTrait {
+
+  /**
+   * Generates an image style for a file target.
+   *
+   * @param string $target
+   *   The file target.
+   *
+   * @return bool
+   *   True on success, false on failure.
+   *
+   * @deprecated in flysystem:2.2.0 and is removed from flysystem:3.0.0.
+   *   Adapters should use generateImageUrl() to enable non-blocking image
+   *   uploads.
+   *
+   * @see https://www.drupal.org/project/flysystem/issues/2661588
+   *
+   * @todo Revise per https://www.drupal.org/project/flysystem/issues/2661588#comment-10972463
+   */
+  protected function generateImageStyle($target) {
+    if (strpos($target, 'styles/') !== 0 || substr_count($target, '/') < 3) {
+      return FALSE;
+    }
+
+    [, $style, $scheme, $file] = explode('/', $target, 4);
+
+    if (!$image_style = ImageStyle::load($style)) {
+      return FALSE;
+    }
+
+    $image_uri = $scheme . '://' . $file;
+
+    $derivative_uri = $image_style->buildUri($image_uri);
+
+    if (!file_exists($image_uri)) {
+      $path_info = pathinfo($image_uri);
+      $converted_image_uri = $path_info['dirname'] . '/' . $path_info['filename'];
+
+      if (!file_exists($converted_image_uri)) {
+        return FALSE;
+      }
+      else {
+        // The converted file does exist, use it as the source.
+        $image_uri = $converted_image_uri;
+      }
+    }
+
+    $lock_name = 'image_style_deliver:' . $image_style->id() . ':' . Crypt::hashBase64($image_uri);
+
+    if (!file_exists($derivative_uri)) {
+      $lock_acquired = \Drupal::lock()->acquire($lock_name);
+      if (!$lock_acquired) {
+        return FALSE;
+      }
+    }
+
+    $success = file_exists($derivative_uri) || $image_style->createDerivative($image_uri, $derivative_uri);
+
+    if (!empty($lock_acquired)) {
+      \Drupal::lock()->release($lock_name);
+    }
+
+    return $success;
+  }
+
+  /**
+   * Return the external URL for a generated image.
+   *
+   * @param string $target
+   *   The target URI.
+   *
+   * @return string
+   *   The generated URL.
+   */
+  protected function generateImageUrl($target) {
+    [, $style, $scheme, $file] = explode('/', $target, 4);
+    $args = [
+      'image_style' => $style,
+      'scheme' => $scheme,
+      'filepath' => $file,
+    ];
+
+    return \Drupal::urlGenerator()->generate('flysystem.image_style_redirect.serve', $args, UrlGeneratorInterface::ABSOLUTE_URL);
+  }
+
+}
diff --git a/src/Routing/FlysystemRoutes.php b/src/Routing/FlysystemRoutes.php
new file mode 100644
index 0000000..3ab8592
--- /dev/null
+++ b/src/Routing/FlysystemRoutes.php
@@ -0,0 +1,176 @@
+<?php
+
+namespace Drupal\flysystem\Routing;
+
+use Drupal\Core\DependencyInjection\ContainerInjectionInterface;
+use Drupal\Core\Extension\ModuleHandlerInterface;
+use Drupal\Core\Site\Settings;
+use Drupal\Core\StreamWrapper\StreamWrapperManagerInterface;
+use Drupal\flysystem\FlysystemFactory;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+use Symfony\Component\Routing\Route;
+
+/**
+ * Defines a route subscriber to register a url for serving image styles.
+ */
+class FlysystemRoutes implements ContainerInjectionInterface {
+
+  /**
+   * The Flysystem factory.
+   *
+   * @var \Drupal\flysystem\FlysystemFactory
+   */
+  protected $factory;
+
+  /**
+   * The module handler.
+   *
+   * @var \Drupal\Core\Extension\ModuleHandlerInterface
+   */
+  protected $moduleHandler;
+
+  /**
+   * The stream wrapper manager service.
+   *
+   * @var \Drupal\Core\StreamWrapper\StreamWrapperManagerInterface
+   */
+  protected $streamWrapperManager;
+
+  /**
+   * Constructs a new FlysystemRoutes object.
+   *
+   * @param \Drupal\flysystem\FlysystemFactory $factory
+   *   The Flysystem factory.
+   * @param \Drupal\Core\StreamWrapper\StreamWrapperManagerInterface $stream_wrapper_manager
+   *   The stream wrapper manager service.
+   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   *   The module handler.
+   */
+  public function __construct(FlysystemFactory $factory, StreamWrapperManagerInterface $stream_wrapper_manager, ModuleHandlerInterface $module_handler) {
+    $this->factory = $factory;
+    $this->streamWrapperManager = $stream_wrapper_manager;
+    $this->moduleHandler = $module_handler;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container) {
+    return new static(
+      $container->get('flysystem_factory'),
+      $container->get('stream_wrapper_manager'),
+      $container->get('module_handler')
+    );
+  }
+
+  /**
+   * Returns a list of route objects.
+   *
+   * @return \Symfony\Component\Routing\Route[]
+   *   An array of route objects.
+   */
+  public function routes() {
+    $public_directory_path = $this->streamWrapperManager->getViaScheme('public')->getDirectoryPath();
+    $routes = [];
+
+    $all_settings = Settings::get('flysystem', []);
+
+    foreach ($this->factory->getSchemes() as $scheme) {
+      $settings = $all_settings[$scheme];
+
+      if ($settings['driver'] !== 'local' || empty($settings['config']['public'])) {
+        continue;
+      }
+
+      // If the root is the same as the public files directory, skip adding a
+      // route.
+      if ($settings['config']['root'] === $public_directory_path) {
+        continue;
+      }
+
+      $routes['flysystem.' . $scheme . '.serve'] = new Route(
+        '/' . $settings['config']['root'],
+        [
+          '_controller' => 'Drupal\system\FileDownloadController::download',
+          '_disable_route_normalizer' => TRUE,
+          'scheme' => $scheme,
+        ],
+        [
+          '_access' => 'TRUE',
+        ],
+        [
+          '_maintenance_access' => TRUE,
+        ]
+      );
+
+      if ($this->moduleHandler->moduleExists('image')) {
+        // Public image route.
+        $routes['flysystem.' . $scheme . '.style_public'] = new Route(
+          '/' . $settings['config']['root'] . '/styles/{image_style}/' . $scheme,
+          [
+            '_controller' => 'Drupal\image\Controller\ImageStyleDownloadController::deliver',
+            '_disable_route_normalizer' => TRUE,
+            'required_derivative_scheme' => $scheme,
+            'scheme' => $scheme,
+          ],
+          [
+            '_access' => 'TRUE',
+          ],
+          [
+            '_maintenance_access' => TRUE,
+          ]
+        );
+      }
+
+      if ($this->moduleHandler->moduleExists('image')) {
+        // Public image route that proxies the response through Drupal.
+        $routes['flysystem.image_style'] = new Route(
+          '/_flysystem/styles/{image_style}/{scheme}',
+          [
+            '_controller' => 'Drupal\image\Controller\ImageStyleDownloadController::deliver',
+            '_disable_route_normalizer' => TRUE,
+            'required_derivative_scheme' => $scheme,
+          ],
+          [
+            '_access' => 'TRUE',
+            'scheme' => '^[a-zA-Z0-9+.-]+$',
+          ],
+          [
+            '_maintenance_access' => TRUE,
+          ]
+        );
+
+        // Public image route that serves initially from Drupal, and then
+        // redirects to a remote URL when it's ready.
+        $routes['flysystem.image_style_redirect'] = new Route(
+          "/_flysystem-style-redirect/{image_style}/{scheme}",
+          [
+            '_controller' => 'Drupal\flysystem\Controller\ImageStyleRedirectController::deliver',
+            '_disable_route_normalizer' => TRUE,
+            'required_derivative_scheme' => $scheme,
+          ],
+          [
+            '_access' => 'TRUE',
+            'scheme' => '^[a-zA-Z0-9+.-]+$',
+          ]
+        );
+
+        $routes['flysystem.image_style_redirect.serve'] = new Route(
+          "/_flysystem-style-redirect/{image_style}/{scheme}/{filepath}",
+          [
+            '_controller' => 'Drupal\flysystem\Controller\ImageStyleRedirectController::deliver',
+            '_disable_route_normalizer' => TRUE,
+            'required_derivative_scheme' => $scheme,
+          ],
+          [
+            '_access' => 'TRUE',
+            'scheme' => '^[a-zA-Z0-9+.-]+$',
+            'filepath' => '.+',
+          ]
+        );
+      }
+    }
+    return $routes;
+  }
+
+}
diff --git a/tests/bootstrap.php b/tests/bootstrap.php
new file mode 100644
index 0000000..079563d
--- /dev/null
+++ b/tests/bootstrap.php
@@ -0,0 +1,27 @@
+<?php
+
+/**
+ * @file
+ * Searches for the core bootstrap file.
+ */
+
+$dir = __DIR__;
+
+// Match against previous dir for Windows.
+$previous_dir = '';
+
+while ($dir = dirname($dir)) {
+  // We've reached the root.
+  if ($dir === $previous_dir) {
+    break;
+  }
+
+  $previous_dir = $dir;
+
+  if (is_file($dir . '/core/tests/bootstrap.php')) {
+    require_once $dir . '/core/tests/bootstrap.php';
+    return;
+  }
+}
+
+throw new RuntimeException('Unable to load core bootstrap.php.');
diff --git a/tests/src/Functional/ModuleInstallUninstallWebTest.php b/tests/src/Functional/ModuleInstallUninstallWebTest.php
new file mode 100644
index 0000000..8cb2d41
--- /dev/null
+++ b/tests/src/Functional/ModuleInstallUninstallWebTest.php
@@ -0,0 +1,38 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Functional;
+
+use Drupal\Tests\BrowserTestBase;
+
+/**
+ * Tests module installation and uninstallation.
+ *
+ * @group flysystem
+ */
+class ModuleInstallUninstallWebTest extends BrowserTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected $defaultTheme = 'stark';
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = ['flysystem'];
+
+  /**
+   * Tests installation and uninstallation.
+   */
+  public function testInstallationAndUninstallation() {
+    $module_handler = \Drupal::moduleHandler();
+    $this->assertTrue($module_handler->moduleExists(reset(static::$modules)));
+
+    /** @var \Drupal\Core\Extension\ModuleInstallerInterface $module_installer */
+    $module_installer = \Drupal::service('module_installer');
+
+    $module_installer->uninstall(static::$modules);
+    $this->assertFalse($module_handler->moduleExists(reset(static::$modules)));
+  }
+
+}
diff --git a/tests/src/Unit/Event/EnsureEventTest.php b/tests/src/Unit/Event/EnsureEventTest.php
new file mode 100644
index 0000000..8960845
--- /dev/null
+++ b/tests/src/Unit/Event/EnsureEventTest.php
@@ -0,0 +1,29 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Event;
+
+use Drupal\flysystem\Event\EnsureEvent;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * Tests EnsureEvent.
+ *
+ * @coversDefaultClass \Drupal\flysystem\Event\EnsureEvent
+ * @covers \Drupal\flysystem\Event\EnsureEvent
+ * @group flysystem
+ */
+class EnsureEventTest extends UnitTestCase {
+
+  /**
+   * Tests the basic setters/getters of EnsureEvent.
+   */
+  public function test() {
+    $event = new EnsureEvent('scheme', 10, 'message', ['1234']);
+
+    $this->assertSame('scheme', $event->getScheme());
+    $this->assertSame(10, $event->getSeverity());
+    $this->assertSame('message', $event->getMessage());
+    $this->assertSame(['1234'], $event->getContext());
+  }
+
+}
diff --git a/tests/src/Unit/EventSubscriber/EnsureSubscriberTest.php b/tests/src/Unit/EventSubscriber/EnsureSubscriberTest.php
new file mode 100644
index 0000000..2b2effd
--- /dev/null
+++ b/tests/src/Unit/EventSubscriber/EnsureSubscriberTest.php
@@ -0,0 +1,44 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\EventSubscriber;
+
+use Drupal\flysystem\Event\EnsureEvent;
+use Drupal\flysystem\Event\FlysystemEvents;
+use Drupal\flysystem\EventSubscriber\EnsureSubscriber;
+use Drupal\Tests\UnitTestCase;
+use Psr\Log\LoggerInterface;
+use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\EventSubscriber\EnsureSubscriber
+ * @covers \Drupal\flysystem\EventSubscriber\EnsureSubscriber
+ *
+ * @group flysystem
+ */
+class EnsureSubscriberTest extends UnitTestCase {
+
+  /**
+   * Tests that the event subscriber logs ensure() calls.
+   */
+  public function testLoggingHappens() {
+    $logger = $this->prophesize(LoggerInterface::class);
+    $dispatcher = $this->createMock(EventDispatcherInterface::class);
+    $logger->log('severity', 'message', ['context'])->shouldBeCalled();
+
+    $event = new EnsureEvent('scheme', 'severity', 'message', ['context']);
+
+    $subscriber = new EnsureSubscriber($logger->reveal());
+
+    $subscriber->onEnsure($event, FlysystemEvents::ENSURE, $dispatcher);
+  }
+
+  /**
+   * Tests that the ENSURE event is registered.
+   */
+  public function testSubscribedEvents() {
+    $result = EnsureSubscriber::getSubscribedEvents();
+
+    $this->assertTrue(isset($result[FlysystemEvents::ENSURE]));
+  }
+
+}
diff --git a/tests/src/Unit/Flysystem/Adapter/CacheItemBackendTest.php b/tests/src/Unit/Flysystem/Adapter/CacheItemBackendTest.php
new file mode 100644
index 0000000..3d52651
--- /dev/null
+++ b/tests/src/Unit/Flysystem/Adapter/CacheItemBackendTest.php
@@ -0,0 +1,102 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Flysystem\Adapter;
+
+use Drupal\Component\Datetime\TimeInterface;
+use Drupal\Core\Cache\MemoryBackend;
+use Drupal\flysystem\Flysystem\Adapter\CacheItem;
+use Drupal\flysystem\Flysystem\Adapter\CacheItemBackend;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * Tests \Drupal\flysystem\Flysystem\Adapter\CacheItemBackend.
+ *
+ * @group flysystem
+ *
+ * @coversDefaultClass \Drupal\flysystem\Flysystem\Adapter\CacheItemBackend
+ * @covers \Drupal\flysystem\Flysystem\Adapter\CacheItemBackend
+ */
+class CacheItemBackendTest extends UnitTestCase {
+
+  /**
+   * The cache backend used in the CacheItemBackend.
+   *
+   * @var \Drupal\Core\Cache\CacheBackendInterface
+   */
+  protected $cacheBackend;
+
+  /**
+   * The cache item backend to test.
+   *
+   * @var \Drupal\flysystem\Flysystem\Adapter\CacheItemBackend
+   */
+  protected $cacheItemBackend;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    $time = $this->createMock(TimeInterface::class);
+    $this->cacheBackend = new MemoryBackend($time);
+    $this->cacheItemBackend = new CacheItemBackend('test-scheme', $this->cacheBackend);
+  }
+
+  /**
+   * Tests whether a cache item exists.
+   */
+  public function testHas() {
+    $this->assertFalse($this->cacheItemBackend->has('test.txt'));
+  }
+
+  /**
+   * Tests loading a cache item from the cache.
+   */
+  public function testSetIsLoaded() {
+    $cache_item = new CacheItem();
+    $cache_item->updateMetadata(['mimetype' => 'test_mimetype']);
+    $this->cacheItemBackend->set('test_path', $cache_item);
+
+    $metadata = $this->cacheItemBackend->load('test_path')->getMetadata();
+    $this->assertSame('test_mimetype', $metadata['mimetype']);
+  }
+
+  /**
+   * Tests when loading a cache item creates a new item.
+   */
+  public function testLoadMiss() {
+    $item = $this->cacheItemBackend->load('test_path');
+    $this->assertInstanceOf(CacheItem::class, $item);
+  }
+
+  /**
+   * Tests deleting by a path.
+   */
+  public function testDelete() {
+    $cache_item = new CacheItem();
+    $cache_item->updateMetadata(['mimetype' => 'test_mimetype']);
+
+    $this->cacheItemBackend->set('test_path', $cache_item);
+    $this->cacheItemBackend->delete('test_path');
+
+    $metadata = $this->cacheItemBackend->load('test_path')->getMetadata();
+    $this->assertTrue(empty($metadata['mimetype']));
+  }
+
+  /**
+   * Tests deleting multiple items at once.
+   */
+  public function testDeleteMultiple() {
+    $cache_item_one = new CacheItem();
+    $cache_item_two = new CacheItem();
+
+    $this->cacheItemBackend->set('one', $cache_item_one);
+    $this->cacheItemBackend->set('two', $cache_item_two);
+
+    $this->cacheItemBackend->deleteMultiple(['one', 'two']);
+
+    $this->assertNotSame($cache_item_one, $this->cacheItemBackend->load('one'));
+    $this->assertNotSame($cache_item_two, $this->cacheItemBackend->load('two'));
+  }
+
+}
diff --git a/tests/src/Unit/Flysystem/Adapter/CacheItemTest.php b/tests/src/Unit/Flysystem/Adapter/CacheItemTest.php
new file mode 100644
index 0000000..70a91bf
--- /dev/null
+++ b/tests/src/Unit/Flysystem/Adapter/CacheItemTest.php
@@ -0,0 +1,42 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Flysystem\Adapter;
+
+use Drupal\flysystem\Flysystem\Adapter\CacheItem;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * Tests \Drupal\flysystem\Flysystem\Adapter\CacheItem.
+ *
+ * @group flysystem
+ *
+ * @coversDefaultClass \Drupal\flysystem\Flysystem\Adapter\CacheItem
+ * @covers \Drupal\flysystem\Flysystem\Adapter\CacheItem
+ */
+class CacheItemTest extends UnitTestCase {
+
+  /**
+   * Tests metadata updating and getting.
+   */
+  public function test() {
+    $cache_item = new CacheItem();
+
+    $metadata = [
+      'size' => 1234,
+      'mimetype' => 'test_mimetype',
+      'visibility' => 'public',
+      'timestamp' => 123456,
+      'type' => 'file',
+      'contents' => 'test contents',
+      'path' => 'file_path',
+    ];
+
+    $cache_item->updateMetadata($metadata);
+
+    unset($metadata['contents'], $metadata['path']);
+
+    $this->assertSame($metadata, $cache_item->getMetadata());
+
+  }
+
+}
diff --git a/tests/src/Unit/Flysystem/Adapter/DrupalCacheAdapterTest.php b/tests/src/Unit/Flysystem/Adapter/DrupalCacheAdapterTest.php
new file mode 100644
index 0000000..000d562
--- /dev/null
+++ b/tests/src/Unit/Flysystem/Adapter/DrupalCacheAdapterTest.php
@@ -0,0 +1,331 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Flysystem\Adapter;
+
+use Drupal\Component\Datetime\TimeInterface;
+use Drupal\Core\Cache\MemoryBackend;
+use Drupal\flysystem\Flysystem\Adapter\CacheItemBackend;
+use Drupal\flysystem\Flysystem\Adapter\DrupalCacheAdapter;
+use Drupal\Tests\UnitTestCase;
+use League\Flysystem\AdapterInterface;
+use League\Flysystem\Config;
+
+/**
+ * Test the Drupal Cache Adapter.
+ *
+ * @group flysystem
+ *
+ * @coversDefaultClass \Drupal\flysystem\Flysystem\Adapter\DrupalCacheAdapter
+ * @covers \Drupal\flysystem\Flysystem\Adapter\DrupalCacheAdapter
+ */
+class DrupalCacheAdapterTest extends UnitTestCase {
+
+  /**
+   * URI scheme to use for testing.
+   *
+   * @var string
+   */
+  const SCHEME = 'test-scheme';
+
+  /**
+   * The main test file.
+   *
+   * @var string
+   */
+  const FILE = 'test.txt';
+
+  /**
+   * The wrapped Flysystem adapter.
+   *
+   * @var \League\Flysystem\AdapterInterface|\PHPUnit_Framework_MockObject_MockObject
+   */
+  protected $adapter;
+
+  /**
+   * The cache adapter under test.
+   *
+   * @var \Drupal\flysystem\Flysystem\Adapter\DrupalCacheAdapter
+   */
+  protected $cacheAdapter;
+
+  /**
+   * The flysystem backend for testing.
+   *
+   * @var \Drupal\flysystem\Flysystem\Adapter\CacheItemBackend
+   */
+  protected $cacheItemBackend;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    $time = $this->prophesize(TimeInterface::class)->reveal();
+    $this->cacheItemBackend = new CacheItemBackend(static::SCHEME, new MemoryBackend($time));
+    $this->adapter = $this->prophesize(AdapterInterface::class);
+    $this->cacheAdapter = new DrupalCacheAdapter(static::SCHEME, $this->adapter->reveal(), $this->cacheItemBackend);
+  }
+
+  /**
+   * Tests creating a public file.
+   */
+  public function testWriteSuccess() {
+    $config = new Config();
+    $this->adapter
+      ->write(static::FILE, 'contents', $config)
+      ->willReturn(['visibility' => 'public']);
+
+    $metadata = $this->cacheAdapter->write(static::FILE, 'contents', $config);
+    $this->assertSame('public', $metadata['visibility']);
+    $this->assertSame('public', $this->cacheAdapter->getVisibility(static::FILE)['visibility']);
+    $this->assertTrue($this->cacheItemBackend->has(static::FILE));
+  }
+
+  /**
+   * Tests creating a public file stream.
+   */
+  public function testWriteStreamSuccess() {
+    $config = new Config();
+    $stream = fopen('data:text/plain,contents', 'rb');
+
+    $this->adapter
+      ->writeStream(static::FILE, $stream, $config)
+      ->willReturn(['timestamp' => 12345]);
+
+    $metadata = $this->cacheAdapter->writeStream(static::FILE, $stream, $config);
+    $this->assertSame(12345, $metadata['timestamp']);
+    $this->assertSame(12345, $this->cacheAdapter->getTimestamp(static::FILE)['timestamp']);
+    $this->assertTrue($this->cacheItemBackend->has(static::FILE));
+  }
+
+  /**
+   * Tests public file updates.
+   */
+  public function testUpdateSuccess() {
+    $config = new Config();
+    $this->adapter
+      ->update(static::FILE, 'contents', $config)
+      ->willReturn(['visibility' => 'public']);
+
+    $metadata = $this->cacheAdapter->update(static::FILE, 'contents', $config);
+    $this->assertSame('public', $metadata['visibility']);
+    $this->assertSame('public', $this->cacheAdapter->getVisibility(static::FILE)['visibility']);
+  }
+
+  /**
+   * Tests public file stream updates.
+   */
+  public function testUpdateStreamSuccess() {
+    $config = new Config();
+    $stream = fopen('data:text/plain,contents', 'rb');
+
+    $this->adapter
+      ->updateStream(static::FILE, $stream, $config)
+      ->willReturn(['mimetype' => 'test_mimetype']);
+
+    $metadata = $this->cacheAdapter->updateStream(static::FILE, $stream, $config);
+    $this->assertSame('test_mimetype', $metadata['mimetype']);
+    $this->assertSame('test_mimetype', $this->cacheAdapter->getMimetype(static::FILE)['mimetype']);
+    $this->assertTrue($this->cacheItemBackend->has(static::FILE));
+  }
+
+  /**
+   * Tests renaming a file.
+   */
+  public function testRenameSuccess() {
+    $config = new Config();
+    $this->adapter
+      ->write(static::FILE, 'contents', $config)
+      ->willReturn(['size' => 1234]);
+
+    $this->cacheAdapter->write(static::FILE, 'contents', $config);
+
+    $this->adapter
+      ->rename(static::FILE, 'new.txt')
+      ->willReturn(TRUE);
+
+    $this->assertTrue($this->cacheAdapter->rename(static::FILE, 'new.txt'));
+    $this->assertSame(1234, $this->cacheAdapter->getSize('new.txt')['size']);
+
+    $this->assertFalse($this->cacheItemBackend->has(static::FILE));
+    $this->assertTrue($this->cacheItemBackend->has('new.txt'));
+
+  }
+
+  /**
+   * Tests copying a file.
+   */
+  public function testCopySuccess() {
+    $config = new Config();
+    $this->adapter
+      ->write(static::FILE, 'contents', $config)
+      ->willReturn(['size' => 1234]);
+
+    $this->cacheAdapter->write(static::FILE, 'contents', $config);
+
+    $this->adapter->copy(static::FILE, 'new.txt')->willReturn(TRUE);
+
+    $this->assertTrue($this->cacheAdapter->copy(static::FILE, 'new.txt'));
+
+    $this->assertSame(1234, $this->cacheAdapter->getSize(static::FILE)['size']);
+    $this->assertSame(1234, $this->cacheAdapter->getSize('new.txt')['size']);
+    $this->assertTrue($this->cacheItemBackend->has(static::FILE));
+    $this->assertTrue($this->cacheItemBackend->has('new.txt'));
+  }
+
+  /**
+   * Tests deleting a file.
+   */
+  public function testDeleteSuccess() {
+    $config = new Config();
+    $this->adapter
+      ->write(static::FILE, 'contents', $config)
+      ->willReturn(['size' => 1234]);
+
+    $this->cacheAdapter->write(static::FILE, 'contents', $config);
+
+    $this->adapter->delete(static::FILE)->willReturn(TRUE);
+
+    $this->assertTrue($this->cacheAdapter->delete(static::FILE));
+    $this->assertFalse($this->cacheItemBackend->has(static::FILE));
+  }
+
+  /**
+   * Tests deleting a file directory.
+   */
+  public function testDeleteDirSuccess() {
+    $config = new Config();
+    // Create a directory with one sub file.
+    $this->adapter->createDir('test_dir', $config)->willReturn(['type' => 'dir']);
+    $this->adapter->write('test_dir/test.txt', 'contents', $config)
+      ->willReturn(['size' => 1234]);
+    $this->adapter->deleteDir('test_dir')->willReturn(TRUE);
+    $this->adapter->listContents('test_dir', TRUE)->willReturn([
+      ['path' => 'test_dir'],
+      ['path' => 'test_dir/test.txt'],
+    ]);
+
+    $this->cacheAdapter->createDir('test_dir', $config);
+    $this->cacheAdapter->write('test_dir/test.txt', 'contents', $config);
+
+    $this->assertTrue($this->cacheAdapter->deleteDir('test_dir'));
+
+    $this->assertFalse($this->cacheItemBackend->has('test_dir/test.txt'));
+    $this->assertFalse($this->cacheItemBackend->has('test_dir'));
+  }
+
+  /**
+   * Tests visibility checking on private files.
+   */
+  public function testSetVisibilitySuccess() {
+    $this->adapter
+      ->setVisibility(static::FILE, 'private')
+      ->willReturn(['visibility' => 'private']);
+
+    $metadata = $this->cacheAdapter->setVisibility(static::FILE, 'private');
+    $this->assertSame('private', $metadata['visibility']);
+    $this->assertSame('private', $this->cacheAdapter->getVisibility(static::FILE)['visibility']);
+    $this->assertTrue($this->cacheItemBackend->has(static::FILE));
+  }
+
+  /**
+   * Tests file loading success.
+   */
+  public function testHasSuccess() {
+    $cache_item = $this->cacheItemBackend->load(static::FILE);
+    $this->cacheItemBackend->set(static::FILE, $cache_item);
+    $this->assertTrue($this->cacheAdapter->has(static::FILE));
+  }
+
+  /**
+   * Tests file loading failure.
+   */
+  public function testHasFail() {
+    $this->adapter->has(static::FILE)->willReturn(TRUE);
+    $this->assertTrue($this->cacheAdapter->has(static::FILE));
+  }
+
+  /**
+   * Tests reading a file.
+   */
+  public function testRead() {
+    $this->adapter->read(static::FILE)->willReturn(FALSE);
+    $this->assertFalse($this->cacheAdapter->read(static::FILE));
+
+    $config = new Config();
+    $this->adapter
+      ->write(static::FILE, 'contents', $config);
+    $return = [
+      'type' => 'file',
+      'path' => static::FILE,
+      'contents' => $config,
+    ];
+    $this->adapter->read(static::FILE)->willReturn($return);
+    $this->assertSame($this->cacheAdapter->read(static::FILE), $return);
+  }
+
+  /**
+   * Tests reading a stream.
+   */
+  public function testReadStream() {
+    $this->adapter->readStream(static::FILE)->willReturn(FALSE);
+    $this->assertFalse($this->cacheAdapter->readStream(static::FILE));
+
+    $config = new Config();
+    $stream = fopen('data:text/plain,contents', 'rb');
+    $this->adapter
+      ->writeStream(static::FILE, $stream, $config);
+
+    $return = [
+      'type' => 'file',
+      'path' => static::FILE,
+      'stream' => $stream,
+    ];
+
+    $this->adapter->readStream(static::FILE)->willReturn($return);
+    $this->assertSame($this->cacheAdapter->readStream(static::FILE), $return);
+  }
+
+  /**
+   * Tests listing contents of a directory.
+   */
+  public function testListContentsSuccess() {
+    $return = [
+      ['path' => 'test_dir'],
+      ['path' => 'test_dir/test.txt'],
+    ];
+
+    $this->adapter->listContents('test_dir', TRUE)->willReturn($return);
+    $this->assertSame($this->cacheAdapter->listContents('test_dir', TRUE), $return);
+  }
+
+  /**
+   * Tests retrieving file metadata.
+   */
+  public function testGetMetadataSuccess() {
+    $cache_item = $this->cacheItemBackend->load(static::FILE);
+    $cache_item->updateMetadata(['type' => 'dir']);
+    $this->cacheItemBackend->set(static::FILE, $cache_item);
+
+    $this->assertSame('dir', $this->cacheAdapter->getMetadata(static::FILE)['type']);
+  }
+
+  /**
+   * Tests failing to retrieve file metadata.
+   */
+  public function testGetMetadataFail() {
+    $this->adapter->getMetadata(static::FILE)->willReturn(['type' => 'dir']);
+
+    $this->assertSame('dir', $this->cacheAdapter->getMetadata(static::FILE)['type']);
+  }
+
+  /**
+   * Tests failing to retrieve file size.
+   */
+  public function testGetSizeFail() {
+    $this->adapter->getSize(static::FILE)->willReturn(['size' => 123]);
+
+    $this->assertSame(123, $this->cacheAdapter->getSize(static::FILE)['size']);
+  }
+
+}
diff --git a/tests/src/Unit/Flysystem/Adapter/MissingAdapterTest.php b/tests/src/Unit/Flysystem/Adapter/MissingAdapterTest.php
new file mode 100644
index 0000000..7bae52f
--- /dev/null
+++ b/tests/src/Unit/Flysystem/Adapter/MissingAdapterTest.php
@@ -0,0 +1,42 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Flysystem\Adapter;
+
+use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+use Drupal\Tests\UnitTestCase;
+use League\Flysystem\Config;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\Flysystem\Adapter\MissingAdapter
+ * @group flysystem
+ */
+class MissingAdapterTest extends UnitTestCase {
+
+  /**
+   * @covers \Drupal\flysystem\Flysystem\Adapter\MissingAdapter
+   */
+  public function test() {
+    $adapter = new MissingAdapter();
+
+    $this->assertFalse($adapter->copy('', ''));
+    $this->assertFalse($adapter->createDir('', new Config()));
+    $this->assertFalse($adapter->delete(''));
+    $this->assertFalse($adapter->deleteDir(''));
+    $this->assertIsArray($adapter->listContents(''));
+    $this->assertFalse($adapter->getMetadata(''));
+    $this->assertFalse($adapter->getMimetype(''));
+    $this->assertFalse($adapter->getSize(''));
+    $this->assertFalse($adapter->getTimestamp(''));
+    $this->assertFalse($adapter->getVisibility(''));
+    $this->assertFalse($adapter->has(''));
+    $this->assertFalse($adapter->setVisibility('', 'public'));
+    $this->assertFalse($adapter->update('', '', new Config()));
+    $this->assertFalse($adapter->updateStream('', NULL, new Config()));
+    $this->assertFalse($adapter->read(''));
+    $this->assertFalse($adapter->readStream(''));
+    $this->assertFalse($adapter->rename('', ''));
+    $this->assertFalse($adapter->write('', '', new Config()));
+    $this->assertFalse($adapter->writeStream('', NULL, new Config()));
+  }
+
+}
diff --git a/tests/src/Unit/Flysystem/FtpTest.php b/tests/src/Unit/Flysystem/FtpTest.php
new file mode 100644
index 0000000..a4063b4
--- /dev/null
+++ b/tests/src/Unit/Flysystem/FtpTest.php
@@ -0,0 +1,125 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Flysystem {
+
+  use Drupal\Core\Logger\RfcLogLevel;
+  use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+  use Drupal\flysystem\Flysystem\Ftp;
+  use Drupal\Tests\UnitTestCase;
+  use League\Flysystem\Adapter\Ftp as LeagueFtp;
+
+  /**
+   * @coversDefaultClass \Drupal\flysystem\Flysystem\Ftp
+   * @group flysystem
+   */
+  class FtpTest extends UnitTestCase {
+
+    /**
+     * {@inheritdoc}
+     */
+    public function setUp(): void {
+      parent::setUp();
+      if (!defined('FTP_BINARY')) {
+        $this->markTestSkipped('The FTP_BINARY constant is not defined.');
+      }
+    }
+
+    /**
+     * @covers ::getAdapter
+     * @covers ::__construct
+     */
+    public function testGetAdapterSuccess() {
+      $plugin = new Ftp(['host' => 'success']);
+      $this->assertInstanceOf(LeagueFtp::class, $plugin->getAdapter());
+    }
+
+    /**
+     * @covers ::getAdapter
+     * @covers ::__construct
+     */
+    public function testGetAdapterFails() {
+      $plugin = new Ftp([]);
+      $this->assertInstanceOf(MissingAdapter::class, $plugin->getAdapter());
+    }
+
+    /**
+     * @covers ::ensure
+     */
+    public function testEnsureReturnsNoErrorsOnSuccess() {
+      $result = (new Ftp(['host' => 'success']))->ensure();
+
+      $this->assertCount(1, $result);
+      $this->assertSame(RfcLogLevel::INFO, $result[0]['severity']);
+    }
+
+    /**
+     * @covers ::ensure
+     */
+    public function testEnsureReturnsErrors() {
+      $plugin = new Ftp([]);
+      $result = $plugin->ensure();
+      $this->assertCount(1, $result);
+      $this->assertSame(21, $result[0]['context']['%port']);
+    }
+
+  }
+}
+
+namespace League\Flysystem\Adapter {
+
+  /**
+   * Stubs ftp_chdir().
+   */
+  function ftp_chdir() {
+    return TRUE;
+  }
+
+  /**
+   * Stubs ftp_close().
+   */
+  function ftp_close() {
+  }
+
+  /**
+   * Stubs ftp_connect().
+   */
+  function ftp_connect($host) {
+    return $host === 'success';
+  }
+
+  /**
+   * Stubs ftp_login().
+   */
+  function ftp_login() {
+    return TRUE;
+  }
+
+  /**
+   * Stubs ftp_pasv().
+   */
+  function ftp_pasv() {
+    return TRUE;
+  }
+
+  /**
+   * Stubs ftp_pwd().
+   */
+  function ftp_pwd() {
+    return '';
+  }
+
+  /**
+   * Stubs ftp_systype().
+   */
+  function ftp_systype() {
+    return TRUE;
+  }
+
+  /**
+   * Stubs ftp_raw().
+   */
+  function ftp_raw() {
+    return ['200'];
+  }
+
+}
diff --git a/tests/src/Unit/Flysystem/LocalTest.php b/tests/src/Unit/Flysystem/LocalTest.php
new file mode 100644
index 0000000..4123f0f
--- /dev/null
+++ b/tests/src/Unit/Flysystem/LocalTest.php
@@ -0,0 +1,147 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Flysystem;
+
+use Drupal\Core\DependencyInjection\ContainerBuilder;
+use Drupal\Core\Logger\RfcLogLevel;
+use Drupal\Core\Routing\UrlGeneratorInterface;
+use Drupal\Core\Site\Settings;
+use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+use Drupal\flysystem\Flysystem\Local;
+use Drupal\Tests\UnitTestCase;
+use League\Flysystem\Adapter\Local as LocalAdapter;
+use Prophecy\Argument;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\Flysystem\Local
+ * @group flysystem
+ */
+class LocalTest extends UnitTestCase {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    $GLOBALS['base_url'] = 'http://example.com';
+
+    $container = new ContainerBuilder();
+    $url_generator = $this->prophesize(UrlGeneratorInterface::class);
+    $url_generator->generateFromRoute(Argument::cetera())->willReturn('download');
+    $container->set('url_generator', $url_generator->reveal());
+    \Drupal::setContainer($container);
+    (new LocalAdapter('foo/bar'))->deleteDir('');
+    @rmdir('foo/bar');
+    @rmdir('foo');
+    mkdir('foo');
+    mkdir('foo/bar');
+
+    touch('test.txt');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function tearDown(): void {
+    (new LocalAdapter('foo'))->deleteDir('');
+    @rmdir('foo');
+
+    unlink('test.txt');
+
+    @unlink('does_not_exist/.htaccess');
+    @rmdir('does_not_exist');
+  }
+
+  /**
+   * @covers ::__construct
+   * @covers ::create
+   */
+  public function testCreateReturnsPlugin() {
+    $container = new ContainerBuilder();
+    $settings = new Settings([]);
+    $container->set('settings', $settings);
+
+    $configuration = ['root' => 'foo/bar'];
+
+    $this->assertInstanceOf(Local::class, Local::create($container, $configuration, '', []));
+  }
+
+  /**
+   * @covers ::getAdapter
+   * @covers ::ensureDirectory
+   */
+  public function testReturnsLocalAdapter() {
+    $this->assertInstanceOf(LocalAdapter::class, (new Local('foo/bar', FALSE))->getAdapter());
+  }
+
+  /**
+   * @covers ::getAdapter
+   * @covers ::ensureDirectory
+   */
+  public function testMissingAdapterReturnedWhenPathIsFile() {
+    $this->assertInstanceOf(MissingAdapter::class, (new Local('test.txt'))->getAdapter());
+  }
+
+  /**
+   * @covers ::getExternalUrl
+   */
+  public function testReturnsValidLocalUrl() {
+    $plugin = new Local('foo/bar', FALSE);
+    $this->assertSame('download', $plugin->getExternalUrl('uri://test.html'));
+  }
+
+  /**
+   * @covers ::getExternalUrl
+   */
+  public function testReturnsValidExternalUrl() {
+    $plugin = new Local('foo/bar', TRUE);
+    $this->assertSame('http://example.com/foo/bar/test%20thing.html', $plugin->getExternalUrl('uri://test thing.html'));
+  }
+
+  /**
+   * @covers ::ensure
+   * @covers ::ensureDirectory
+   */
+  public function testDirectoryIsAutoCreatedAndHtaccessIsWritten() {
+    new Local('does_not_exist');
+    $this->assertTrue(is_dir('does_not_exist'));
+    $this->assertTrue(is_file('does_not_exist/.htaccess'));
+
+  }
+
+  /**
+   * @covers ::ensure
+   * @covers ::writeHtaccess
+   */
+  public function testHtaccessNotOverwritten() {
+    file_put_contents('foo/bar/.htaccess', 'htaccess content');
+
+    $result = (new Local('foo/bar'))->ensure();
+
+    $this->assertCount(1, $result);
+    $this->assertSame(RfcLogLevel::INFO, $result[0]['severity']);
+    $this->assertSame('htaccess content', file_get_contents('foo/bar/.htaccess'));
+  }
+
+  /**
+   * @covers ::ensure
+   * @covers ::writeHtaccess
+   */
+  public function testHtaccessNotOverwrittenAndFails() {
+    mkdir('foo/bar/.htaccess', 0777, TRUE);
+
+    $result = (new Local('foo/bar'))->ensure(TRUE);
+    $this->assertCount(1, $result);
+    $this->assertSame('https://www.drupal.org/SA-CORE-2013-003', $result[0]['context']['@url']);
+  }
+
+  /**
+   * @covers ::ensure
+   * @covers ::writeHtaccess
+   */
+  public function testEnsureReturnsErrorWhenCantCreateDir() {
+    $result = (new Local('test.txt'))->ensure();
+    $this->assertSame('test.txt', $result[0]['context']['%root']);
+  }
+
+}
diff --git a/tests/src/Unit/Flysystem/MissingTest.php b/tests/src/Unit/Flysystem/MissingTest.php
new file mode 100644
index 0000000..0421e4c
--- /dev/null
+++ b/tests/src/Unit/Flysystem/MissingTest.php
@@ -0,0 +1,26 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Flysystem;
+
+use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+use Drupal\flysystem\Flysystem\Missing;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\Flysystem\Missing
+ * @group flysystem
+ */
+class MissingTest extends UnitTestCase {
+
+  /**
+   * @covers \Drupal\flysystem\Flysystem\Missing
+   */
+  public function test() {
+    $plugin = new Missing();
+    $this->assertInstanceOf(MissingAdapter::class, $plugin->getAdapter());
+    $this->assertTrue(is_array($plugin->ensure()));
+    $this->assertCount(1, $plugin->ensure());
+    $this->assertSame('', $plugin->getExternalUrl('asdf'));
+  }
+
+}
diff --git a/tests/src/Unit/FlysystemBridgeTest.php b/tests/src/Unit/FlysystemBridgeTest.php
new file mode 100644
index 0000000..e587e49
--- /dev/null
+++ b/tests/src/Unit/FlysystemBridgeTest.php
@@ -0,0 +1,123 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit;
+
+use Drupal\Core\StreamWrapper\StreamWrapperInterface;
+use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+use Drupal\flysystem\Flysystem\Missing;
+use Drupal\flysystem\FlysystemBridge;
+use Drupal\flysystem\FlysystemFactory;
+use Drupal\Tests\UnitTestCase;
+use League\Flysystem\Filesystem;
+use Symfony\Component\DependencyInjection\ContainerBuilder;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\FlysystemBridge
+ * @group flysystem
+ */
+class FlysystemBridgeTest extends UnitTestCase {
+
+  /**
+   * Flysystem Bridge.
+   *
+   * @var \Drupal\flysystem\FlysystemBridge
+   */
+  protected $bridge;
+
+  /**
+   * File system.
+   *
+   * @var \League\Flysystem\FilesystemInterface
+   */
+  protected $filesystem;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    $this->bridge = new FlysystemBridge();
+    $this->bridge->setStringTranslation($this->getStringTranslationStub());
+    $this->bridge->setUri('test_scheme://file.txt');
+
+    $factory = $this->prophesize(FlysystemFactory::class);
+    $factory->getPlugin('test_scheme')->willReturn(new Missing());
+
+    $this->filesystem = new Filesystem(new MissingAdapter());
+
+    $factory->getFilesystem('test_scheme')->willReturn($this->filesystem);
+
+    $factory->getSettings('test_scheme')->willReturn([
+      'name' => '',
+      'description' => '',
+    ]);
+
+    $container = new ContainerBuilder();
+    $container->set('flysystem_factory', $factory->reveal());
+    \Drupal::setContainer($container);
+  }
+
+  /**
+   * @covers ::getType
+   */
+  public function testGetTypeReturnsWriteVisible() {
+    $this->assertSame(StreamWrapperInterface::WRITE_VISIBLE, FlysystemBridge::getType());
+  }
+
+  /**
+   * @covers ::getName
+   */
+  public function testGetNameFormattingCorrect() {
+    $this->assertSame('Flysystem: test_scheme', (string) $this->bridge->getName());
+  }
+
+  /**
+   * @covers ::getDescription
+   */
+  public function testGetDescriptionFormattingCorrect() {
+    $this->assertSame('Flysystem: test_scheme', (string) $this->bridge->getDescription());
+  }
+
+  /**
+   * @covers ::getUri
+   * @covers ::setUri
+   */
+  public function testGetUriMatchesSetUri() {
+    $this->bridge->setUri('foo://bar');
+    $this->assertSame('foo://bar', $this->bridge->getUri());
+  }
+
+  /**
+   * @covers ::getExternalUrl
+   * @covers ::getFactory
+   */
+  public function testGetExternalUrlDelegatesToPlugin() {
+    $this->assertSame('', $this->bridge->getExternalUrl('test_scheme://testfile.txt'));
+  }
+
+  /**
+   * @covers ::realpath
+   */
+  public function testRealpathIsFalse() {
+    $this->assertFalse($this->bridge->realpath());
+  }
+
+  /**
+   * @covers ::dirname
+   */
+  public function testDirname() {
+    $this->assertSame('test_scheme://', $this->bridge->dirname());
+    $this->assertSame('test_scheme://dir://dir', $this->bridge->dirname('test_scheme:///dir://dir/file.txt'));
+  }
+
+  /**
+   * @covers ::getFilesystem
+   * @covers ::getFilesystemForScheme
+   */
+  public function testGetFilesystemOverridden() {
+    $method = new \ReflectionMethod($this->bridge, 'getFilesystem');
+    $method->setAccessible(TRUE);
+    $this->assertSame($this->filesystem, $method->invoke($this->bridge));
+  }
+
+}
diff --git a/tests/src/Unit/FlysystemFactoryTest.php b/tests/src/Unit/FlysystemFactoryTest.php
new file mode 100644
index 0000000..3820131
--- /dev/null
+++ b/tests/src/Unit/FlysystemFactoryTest.php
@@ -0,0 +1,207 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit;
+
+use Drupal\Component\Plugin\PluginManagerInterface;
+use Drupal\Core\Cache\NullBackend;
+use Drupal\Core\Site\Settings;
+use Drupal\Core\StreamWrapper\StreamWrapperManager;
+use Drupal\flysystem\Flysystem\Adapter\DrupalCacheAdapter;
+use Drupal\flysystem\Flysystem\Adapter\MissingAdapter;
+use Drupal\flysystem\Flysystem\Missing;
+use Drupal\flysystem\FlysystemFactory;
+use Drupal\flysystem\Plugin\FlysystemPluginInterface;
+use Drupal\Tests\UnitTestCase;
+use League\Flysystem\Adapter\NullAdapter;
+use League\Flysystem\FilesystemInterface;
+use League\Flysystem\Replicate\ReplicateAdapter;
+use Prophecy\Argument;
+use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\FlysystemFactory
+ * @group flysystem
+ */
+class FlysystemFactoryTest extends UnitTestCase {
+
+  /**
+   * Backend Cache.
+   *
+   * @var \Drupal\Core\Cache\CacheBackendInterface
+   */
+  protected $cache;
+
+  /**
+   * Event Dispatcher.
+   *
+   * @var \Symfony\Contracts\EventDispatcher\EventDispatcherInterface
+   */
+  protected $eventDispatcher;
+
+  /**
+   * Mocked File System.
+   *
+   * @var \Prophecy\Prophecy\ObjectProphecy
+   */
+  protected $filesystem;
+
+  /**
+   * Mocked Plugin.
+   *
+   * @var \Prophecy\Prophecy\ObjectProphecy
+   */
+  protected $plugin;
+
+  /**
+   * Mocked Plugin Manager.
+   *
+   * @var \Prophecy\Prophecy\ObjectProphecy
+   */
+  protected $pluginManager;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+
+    $this->cache = new NullBackend('bin');
+    $this->eventDispatcher = $this->createMock(EventDispatcherInterface::class);
+
+    $this->pluginManager = $this->prophesize(PluginManagerInterface::class);
+    $this->plugin = $this->prophesize(FlysystemPluginInterface::class);
+    $this->plugin->getAdapter()->willReturn(new NullAdapter());
+
+    $this->pluginManager->createInstance('test_driver', [])->willReturn($this->plugin->reveal());
+    $this->pluginManager->createInstance('', [])->willReturn(new Missing());
+
+    $this->filesystem = $this->prophesize(StreamWrapperManager::class);
+    $this->filesystem->isValidScheme(Argument::type('string'))->willReturn(TRUE);
+  }
+
+  /**
+   * @covers ::getFilesystem
+   * @covers ::__construct
+   * @covers ::getAdapter
+   * @covers ::getSettings
+   * @covers ::getPlugin
+   */
+  public function testGetFilesystemReturnsValidFilesystem() {
+    new Settings([
+      'flysystem' => [
+        'test_scheme' => ['driver' => 'test_driver'],
+      ],
+    ]);
+
+    $factory = $this->getFactory();
+
+    $this->assertInstanceOf(FilesystemInterface::class, $factory->getFilesystem('test_scheme'));
+    $this->assertInstanceOf(NullAdapter::class, $factory->getFilesystem('test_scheme')->getAdapter());
+  }
+
+  /**
+   * @covers ::getFilesystem
+   */
+  public function testGetFilesystemReturnsMissingFilesystem() {
+    new Settings([]);
+    $factory = $this->getFactory();
+    $this->assertInstanceOf(MissingAdapter::class, $factory->getFilesystem('test_scheme')->getAdapter());
+  }
+
+  /**
+   * @covers ::getFilesystem
+   * @covers ::getAdapter
+   */
+  public function testGetFilesystemReturnsCachedAdapter() {
+    new Settings([
+      'flysystem' => [
+        'test_scheme' => ['driver' => 'test_driver' , 'cache' => TRUE],
+      ],
+    ]);
+
+    $factory = $this->getFactory();
+    $this->assertInstanceOf(DrupalCacheAdapter::class, $factory->getFilesystem('test_scheme')->getAdapter());
+  }
+
+  /**
+   * @covers ::getFilesystem
+   * @covers ::getAdapter
+   */
+  public function testGetFilesystemReturnsReplicateAdapter() {
+    // Test replicate.
+    $this->pluginManager->createInstance('wrapped', [])->willReturn($this->plugin->reveal());
+
+    new Settings([
+      'flysystem' => [
+        'test_scheme' => ['driver' => 'test_driver' , 'replicate' => 'wrapped'],
+        'wrapped' => ['driver' => 'test_driver'],
+      ],
+    ]);
+
+    $factory = $this->getFactory();
+    $this->assertInstanceOf(ReplicateAdapter::class, $factory->getFilesystem('test_scheme')->getAdapter());
+  }
+
+  /**
+   * @covers ::getSchemes
+   * @covers ::__construct
+   */
+  public function testGetSchemesFiltersInvalidSchemes() {
+    new Settings([
+      'flysystem' => [
+        'test_scheme' => ['driver' => 'test_driver'],
+        'invalid_scheme' => ['driver' => 'test_driver'],
+      ],
+    ]);
+
+    $this->filesystem->isValidScheme('invalid_scheme')->willReturn(FALSE);
+
+    $this->assertSame(['test_scheme'], $this->getFactory()->getSchemes());
+  }
+
+  /**
+   * @covers ::getSchemes
+   */
+  public function testGetSchemesHandlesNoSchemes() {
+    new Settings([]);
+    $this->assertSame([], $this->getFactory()->getSchemes());
+  }
+
+  /**
+   * @covers ::ensure
+   */
+  public function testEnsureReturnsErrors() {
+    new Settings([
+      'flysystem' => [
+        'test_scheme' => ['driver' => 'test_driver'],
+      ],
+    ]);
+
+    $this->plugin->ensure(FALSE)->willReturn([[
+      'severity' => 'bad',
+      'message' => 'Something bad',
+      'context' => [],
+    ],
+    ]);
+
+    $errors = $this->getFactory()->ensure();
+
+    $this->assertSame('Something bad', $errors['test_scheme'][0]['message']);
+  }
+
+  /**
+   * Gets and returns the Flysystem Factory.
+   *
+   * @return \Drupal\flysystem\FlysystemFactory
+   *   Flysystem Factory.
+   */
+  protected function getFactory() {
+    return new FlysystemFactory(
+      $this->pluginManager->reveal(),
+      $this->filesystem->reveal(),
+      $this->cache,
+      $this->eventDispatcher
+    );
+  }
+
+}
diff --git a/tests/src/Unit/FlysystemServiceProviderTest.php b/tests/src/Unit/FlysystemServiceProviderTest.php
new file mode 100644
index 0000000..2a3c273
--- /dev/null
+++ b/tests/src/Unit/FlysystemServiceProviderTest.php
@@ -0,0 +1,83 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit;
+
+use Drupal\Core\DependencyInjection\ContainerBuilder;
+use Drupal\Core\Site\Settings;
+use Drupal\flysystem\FlysystemBridge;
+use Drupal\flysystem\FlysystemServiceProvider;
+use Drupal\flysystem\PathProcessor\LocalPathProcessor;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\FlysystemServiceProvider
+ * @group flysystem
+ */
+class FlysystemServiceProviderTest extends UnitTestCase {
+
+  /**
+   * The container.
+   *
+   * @var \Symfony\Component\DependencyInjection\ContainerInterface
+   */
+  protected $container;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    $this->container = new ContainerBuilder();
+  }
+
+  /**
+   * @covers ::register
+   */
+  public function testNothingFailsIfContainerIsEmpty() {
+    new Settings([]);
+    (new FlysystemServiceProvider())->register($this->container);
+    $this->assertFalse($this->container->has('flysystem_stream_wrapper'));
+  }
+
+  /**
+   * @covers ::register
+   */
+  public function testMissingDriverIsSkipped() {
+    new Settings(['flysystem' => ['test_scheme' => []]]);
+
+    (new FlysystemServiceProvider())->register($this->container);
+
+    $this->assertFalse($this->container->has('flysystem_stream_wrapper.test_scheme'));
+  }
+
+  /**
+   * @covers ::register
+   */
+  public function testValidSchemeConfiguration() {
+    new Settings(['flysystem' => ['test_scheme' => ['driver' => 'whatever']]]);
+
+    (new FlysystemServiceProvider())->register($this->container);
+
+    $this->assertTrue($this->container->has('flysystem_stream_wrapper.test_scheme'));
+    $this->assertSame(FlysystemBridge::class, $this->container->getDefinition('flysystem_stream_wrapper.test_scheme')->getClass());
+    $this->assertSame([['scheme' => 'test_scheme']], $this->container->getDefinition('flysystem_stream_wrapper.test_scheme')->getTag('stream_wrapper'));
+  }
+
+  /**
+   * @covers ::register
+   */
+  public function testLocalRouteProviderGetsAdded() {
+    new Settings([
+      'flysystem' => [
+        'test_scheme' => [
+          'driver' => 'local',
+          'config' => ['public' => TRUE],
+        ],
+      ],
+    ]);
+
+    (new FlysystemServiceProvider())->register($this->container);
+    $this->assertSame(LocalPathProcessor::class, $this->container->getDefinition('flysystem.test_scheme.path_processor')->getClass());
+  }
+
+}
diff --git a/tests/src/Unit/Form/ConfigFormTest.php b/tests/src/Unit/Form/ConfigFormTest.php
new file mode 100644
index 0000000..32acee1
--- /dev/null
+++ b/tests/src/Unit/Form/ConfigFormTest.php
@@ -0,0 +1,300 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Form {
+
+  use Drupal\Core\Form\FormState;
+  use Drupal\Core\Logger\LoggerChannelFactoryInterface;
+  use Drupal\Core\Messenger\MessengerInterface;
+  use Drupal\flysystem\FlysystemFactory;
+  use Drupal\flysystem\Form\ConfigForm;
+  use Drupal\Tests\UnitTestCase;
+  use League\Flysystem\Filesystem;
+  use League\Flysystem\FilesystemInterface;
+  use League\Flysystem\Memory\MemoryAdapter;
+  use Prophecy\Argument;
+  use Psr\Log\LoggerInterface;
+  use Symfony\Component\DependencyInjection\ContainerBuilder;
+  use function Drupal\flysystem\Form\batch_set;
+
+  /**
+   * @coversDefaultClass \Drupal\flysystem\Form\ConfigForm
+   * @group flysystem
+   */
+  class ConfigFormTest extends UnitTestCase {
+
+    /**
+     * The Flysystem factory prophecy.
+     *
+     * @var \Prophecy\Prophecy\ObjectProphecy
+     */
+    protected $factory;
+
+    /**
+     * The form object.
+     *
+     * @var \Drupal\flysystem\Form\ConfigForm
+     */
+    protected $form;
+
+    /**
+     * {@inheritdoc}
+     */
+    public function setUp(): void {
+      parent::setUp();
+
+      $this->factory = $this->prophesize(FlysystemFactory::class);
+      $this->factory->getFilesystem('from_empty')->willReturn(new Filesystem(new MemoryAdapter()));
+      $this->factory->getFilesystem('to_empty')->willReturn(new Filesystem(new MemoryAdapter()));
+      $this->factory->getSchemes()->willReturn(['from_empty', 'to_empty']);
+
+      $this->form = new ConfigForm($this->factory->reveal());
+      $this->form->setStringTranslation($this->getStringTranslationStub());
+      $messenger = $this->prophesize(MessengerInterface::class);
+
+      $container = new ContainerBuilder();
+      $container->set('string_translation', $this->getStringTranslationStub());
+      $container->set('flysystem_factory', $this->factory->reveal());
+      $container->set('messenger', $messenger->reveal());
+
+      $logger = $this->prophesize(LoggerChannelFactoryInterface::class);
+      $logger->get('flysystem')->willReturn($this->prophesize(LoggerInterface::class)->reveal());
+      $container->set('logger.factory', $logger->reveal());
+
+      \Drupal::setContainer($container);
+    }
+
+    /**
+     * @covers ::create
+     * @covers ::__construct
+     */
+    public function testCreate() {
+      $container = new ContainerBuilder();
+      $container->set('flysystem_factory', $this->factory->reveal());
+
+      $this->assertInstanceOf(ConfigForm::class, ConfigForm::create($container));
+    }
+
+    /**
+     * @covers ::getFormId
+     */
+    public function testGetFormId() {
+      $this->assertSame('flysystem_config_form', $this->form->getFormId());
+    }
+
+    /**
+     * @covers ::buildForm
+     */
+    public function testBuildForm() {
+      $form = $this->form->buildForm([], new FormState());
+      $this->assertCount(4, $form);
+
+      $this->assertTrue($form['sync_from']['#required']);
+      $this->assertTrue($form['sync_to']['#required']);
+    }
+
+    /**
+     * @covers ::validateForm
+     */
+    public function testValidateForm() {
+      $form_state = new FormState();
+      $form = $this->form->buildForm([], $form_state);
+      $form['sync_from']['#parents'] = ['sync_from'];
+      $form['sync_to']['#parents'] = ['sync_to'];
+
+      $form_state->setValue('sync_from', 'from');
+      $form_state->setValue('sync_to', 'to');
+
+      $this->form->validateForm($form, $form_state);
+      $this->assertCount(0, $form_state->getErrors());
+      $form_state->setValue('sync_to', 'from');
+
+      $this->form->validateForm($form, $form_state);
+      $this->assertCount(2, $form_state->getErrors());
+    }
+
+    /**
+     * @covers ::submitForm
+     * @covers ::getFileList
+     */
+    public function testSubmitForm() {
+      $form_state = new FormState();
+      $form = [];
+      $form_state->setValue('sync_from', 'from_empty');
+      $form_state->setValue('sync_to', 'to_empty');
+
+      $this->form->submitForm($form, $form_state);
+      $batch = batch_set();
+
+      $this->assertSame(ConfigForm::class . '::finishBatch', $batch['finished']);
+      $this->assertCount(0, $batch['operations']);
+
+      // Test with existing source files.
+      $from = new Filesystem(new MemoryAdapter());
+      $from->write('dir/test.txt', 'abcdefg');
+      $from->write('test.txt', 'abcdefg');
+      $this->factory->getFilesystem('from_files')->willReturn($from);
+
+      $form_state->setValue('sync_from', 'from_files');
+
+      $this->form->submitForm($form, $form_state);
+
+      $batch_files = array_map(function (array $operation) {
+        return $operation[1][2];
+      }, batch_set()['operations']);
+
+      $this->assertSame(['dir/test.txt', 'test.txt'], $batch_files);
+
+      // Test with existing destination files, and force true.
+      $form_state->setValue('force', TRUE);
+      $form_state->setValue('sync_to', 'from_files');
+
+      $this->form->submitForm($form, $form_state);
+
+      $batch_files = array_map(function (array $operation) {
+        return $operation[1][2];
+      }, batch_set()['operations']);
+
+      $this->assertSame(['dir/test.txt', 'test.txt'], $batch_files);
+    }
+
+    /**
+     * @covers ::copyFile
+     */
+    public function testCopyFile() {
+      $context = [];
+
+      $from = new Filesystem(new MemoryAdapter());
+      $from->write('dir/test.txt', 'abcdefg');
+      $this->factory->getFilesystem('from_files')->willReturn($from);
+
+      ConfigForm::copyFile('from_files', 'to_empty', 'dir/test.txt', $context);
+
+      $this->assertSame('abcdefg', $this->factory->reveal()->getFilesystem('to_empty')->read('dir/test.txt'));
+      $this->assertTrue(empty($context['results']));
+      $this->assertSame(1, $context['finished']);
+    }
+
+    /**
+     * @covers ::copyFile
+     */
+    public function testCopyFileFailedRead() {
+      // Tests failed read.
+      $context = [];
+      $failed_read = $this->prophesize(FilesystemInterface::class);
+      $failed_read->readStream('does_not_exist')->willReturn(FALSE);
+      $this->factory->getFilesystem('failed_read')->willReturn($failed_read->reveal());
+
+      ConfigForm::copyFile('failed_read', 'to_empty', 'does_not_exist', $context);
+
+      $to_files = $this->factory->reveal()->getFilesystem('to_empty')->listContents('', TRUE);
+      $this->assertCount(0, $to_files);
+      $this->assertCount(1, $context['results']['errors']);
+    }
+
+    /**
+     * @covers ::copyFile
+     */
+    public function testCopyFileFailedWrite() {
+      $context = [];
+
+      $from = new Filesystem(new MemoryAdapter());
+      $from->write('test.txt', 'abcdefg');
+      $this->factory->getFilesystem('from_files')->willReturn($from);
+
+      $failed_write = $this->prophesize(FilesystemInterface::class);
+      $failed_write->putStream(Argument::cetera())->willReturn(FALSE);
+      $this->factory->getFilesystem('to_fail')->willReturn($failed_write);
+
+      ConfigForm::copyFile('from_files', 'to_fail', 'test.txt', $context);
+
+      $this->assertCount(1, $context['results']['errors']);
+      $this->assertTrue(strpos($context['results']['errors'][0][0], 'could not be saved') !== FALSE);
+    }
+
+    /**
+     * @covers ::copyFile
+     */
+    public function testCopyFileException() {
+      $context = [];
+      ConfigForm::copyFile('from_empty', 'to_empty', 'does_not_exist.txt', $context);
+      $this->assertCount(2, $context['results']['errors']);
+      $this->assertTrue(strpos($context['results']['errors'][0][0], 'An error occurred while copying') !== FALSE);
+      $this->assertTrue(strpos($context['results']['errors'][1], 'File not found at path') !== FALSE);
+    }
+
+    /**
+     * @covers ::finishBatch
+     */
+    public function testFinishBatch() {
+      ConfigForm::finishBatch(TRUE, [], []);
+      ConfigForm::finishBatch(FALSE, [], ['from', 'to', 'file.txt']);
+      ConfigForm::finishBatch(TRUE, [
+        'errors' => [
+          'first error',
+          [
+            'second error', [''],
+          ],
+        ],
+      ], []);
+      // @todo refactor.
+      $this->assertTrue(TRUE);
+    }
+
+    /**
+     * Converts a file list from Flysystem into a list of files.
+     *
+     * @param array $list
+     *   The file list from Flysystem::listContents().
+     *
+     * @return string[]
+     *   A list of file paths.
+     */
+    protected function getFileList(array $list) {
+      $list = array_filter($list, function (array $file) {
+        return $file['type'] === 'file';
+      });
+
+      return array_map(function (array $file) {
+        return $file['path'];
+      }, $list);
+    }
+
+  }
+}
+
+namespace Drupal\flysystem\Form {
+
+  /**
+   * Override for drupal_set_message().
+   */
+  function drupal_set_message() {
+  }
+
+  /**
+   * Mock batch_set() for testing.
+   */
+  function batch_set($batch = NULL) {
+    static $last_batch;
+
+    if (isset($batch)) {
+      $last_batch = $batch;
+    }
+    return $last_batch;
+  }
+
+  /**
+   * Override for drupal_set_time_limit().
+   */
+  function drupal_set_time_limit($limit) {
+    if ($limit !== 0) {
+      throw new \Exception();
+    }
+  }
+
+  /**
+   * Override for Watchdog exception().
+   */
+  function watchdog_exception() {
+  }
+
+}
diff --git a/tests/src/Unit/InstallFunctionsTest.php b/tests/src/Unit/InstallFunctionsTest.php
new file mode 100644
index 0000000..e8414a6
--- /dev/null
+++ b/tests/src/Unit/InstallFunctionsTest.php
@@ -0,0 +1,63 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit;
+
+use Drupal\Core\Site\Settings;
+use Drupal\flysystem\FlysystemFactory;
+use Drupal\Tests\UnitTestCase;
+use Symfony\Component\DependencyInjection\ContainerBuilder;
+
+/**
+ * Tests flysystem.install functions.
+ *
+ * @group flysystem
+ */
+class InstallFunctionsTest extends UnitTestCase {
+
+  /**
+   * The Flysystem factory prophecy object.
+   *
+   * @var \Prophecy\Prophecy\ObjectProphecy
+   */
+  protected $factory;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+
+    if (!defined('REQUIREMENT_ERROR')) {
+      define('REQUIREMENT_ERROR', 2);
+    }
+
+    require_once dirname(dirname(dirname(__DIR__))) . '/flysystem.install';
+
+    $this->factory = $this->prophesize(FlysystemFactory::class);
+
+    $container = new ContainerBuilder();
+    $container->set('flysystem_factory', $this->factory->reveal());
+    $container->set('string_translation', $this->getStringTranslationStub());
+
+    \Drupal::setContainer($container);
+  }
+
+  /**
+   * Tests flysystem_requirements() detects invalid schemes.
+   */
+  public function testFlysystemRequirementsHandlesInvalidSchemes() {
+    new Settings(['flysystem' => ['test_scheme' => []]]);
+    $requirements = flysystem_requirements('update');
+
+    $this->assertTrue(isset($requirements['flysystem_invalid_scheme']));
+  }
+
+  /**
+   * Tests flysystem_install() calls ensure().
+   */
+  public function testFlysystemInstallCallsEnsure() {
+    $this->factory->ensure()->shouldBeCalled();
+    flysystem_install();
+  }
+
+}
diff --git a/tests/src/Unit/Logger/ConvertTest.php b/tests/src/Unit/Logger/ConvertTest.php
new file mode 100644
index 0000000..c885879
--- /dev/null
+++ b/tests/src/Unit/Logger/ConvertTest.php
@@ -0,0 +1,46 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Logger;
+
+use Drupal\Core\Logger\RfcLogLevel;
+use Drupal\flysystem\Logger\Convert;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\Logger\Convert
+ * @group flysystem
+ */
+class ConvertTest extends UnitTestCase {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    $consts = [
+      'REQUIREMENT_INFO' => -1,
+      'REQUIREMENT_OK' => 0,
+      'REQUIREMENT_WARNING' => 1,
+      'REQUIREMENT_ERROR' => 2,
+    ];
+
+    foreach ($consts as $const => $value) {
+      if (!defined($const)) {
+        define($const, $value);
+      }
+    }
+  }
+
+  /**
+   * @covers ::rfcToHookRequirements
+   */
+  public function test() {
+    $this->assertSame(REQUIREMENT_ERROR, Convert::rfcToHookRequirements(RfcLogLevel::EMERGENCY));
+    $this->assertSame(REQUIREMENT_ERROR, Convert::rfcToHookRequirements(RfcLogLevel::ERROR));
+    $this->assertSame(REQUIREMENT_WARNING, Convert::rfcToHookRequirements(RfcLogLevel::WARNING));
+    $this->assertSame(REQUIREMENT_INFO, Convert::rfcToHookRequirements(RfcLogLevel::NOTICE));
+    $this->assertSame(REQUIREMENT_INFO, Convert::rfcToHookRequirements(RfcLogLevel::INFO));
+    $this->assertSame(REQUIREMENT_OK, Convert::rfcToHookRequirements(RfcLogLevel::DEBUG));
+  }
+
+}
diff --git a/tests/src/Unit/ModuleFunctionsTest.php b/tests/src/Unit/ModuleFunctionsTest.php
new file mode 100644
index 0000000..ce9e235
--- /dev/null
+++ b/tests/src/Unit/ModuleFunctionsTest.php
@@ -0,0 +1,92 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit;
+
+use Drupal\Core\File\MimeType\ExtensionMimeTypeGuesser;
+use Drupal\Core\StreamWrapper\StreamWrapperManagerInterface;
+use Drupal\flysystem\FlysystemFactory;
+use Drupal\Tests\UnitTestCase;
+use org\bovigo\vfs\vfsStream;
+use Prophecy\Argument;
+use Symfony\Component\DependencyInjection\ContainerBuilder;
+
+/**
+ * Tests module functions.
+ *
+ * @group flysystem
+ */
+class ModuleFunctionsTest extends UnitTestCase {
+
+  /**
+   * The Flysystem factory prophecy object.
+   *
+   * @var \Prophecy\Prophecy\ObjectProphecy
+   */
+  protected $factory;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    vfsStream::setup('module_file');
+
+    require_once dirname(dirname(dirname(__DIR__))) . '/flysystem.module';
+
+    $this->factory = $this->prophesize(FlysystemFactory::class);
+    $this->factory->getSchemes()->willReturn(['vfs']);
+
+    $file_system_helper = $this->prophesize(StreamWrapperManagerInterface::class);
+    $file_system_helper->isValidScheme(Argument::type('string'))->will(function ($uri) {
+      [$scheme] = explode('://', $uri[0]);
+      return $scheme;
+    });
+
+    $guesser = $this->prophesize(ExtensionMimeTypeGuesser::class);
+    $guesser->guessMimeType(Argument::type('string'))->willReturn('txt/flysystem');
+
+    $container = new ContainerBuilder();
+    $container->set('file_system', $file_system_helper->reveal());
+    $container->set('flysystem_factory', $this->factory->reveal());
+    $container->set('file.mime_type.guesser.extension', $guesser->reveal());
+
+    \Drupal::setContainer($container);
+  }
+
+  /**
+   * Tests flysystem_cron() calls ensure.
+   */
+  public function testFlysystemCronCallsEnsure() {
+    $this->factory->ensure()->shouldBeCalled();
+    flysystem_cron();
+  }
+
+  /**
+   * Tests flysystem_rebuild() calls ensure.
+   */
+  public function testFlysystemRebuildCallsEnsure() {
+    $this->factory->ensure()->shouldBeCalled();
+    flysystem_rebuild();
+  }
+
+  /**
+   * Tests flysystem_file_download() handles valid schemes.
+   */
+  public function testFlysystemFileDownloadFindsValidScheme() {
+    $success = file_put_contents('vfs://module_file/file.txt', '1234');
+    $this->assertEquals($success, 4);
+    $return = flysystem_file_download('vfs://module_file/file.txt');
+
+    $this->assertEquals(2, count($return));
+    $this->assertSame('txt/flysystem', $return['Content-Type']);
+    $this->assertEquals(4, $return['Content-Length']);
+  }
+
+  /**
+   * Tests flysystem_file_download() ignores invalid schemes.
+   */
+  public function testFlysystemFileDownloadIgnoresInvalidScheme() {
+    $this->assertNull(flysystem_file_download('invalid://module_file/file.txt'));
+  }
+
+}
diff --git a/tests/src/Unit/PathProcessor/FlysystemPathProcessorTest.php b/tests/src/Unit/PathProcessor/FlysystemPathProcessorTest.php
new file mode 100644
index 0000000..9c19f93
--- /dev/null
+++ b/tests/src/Unit/PathProcessor/FlysystemPathProcessorTest.php
@@ -0,0 +1,56 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\PathProcessor;
+
+use Drupal\flysystem\PathProcessor\FlysystemPathProcessor;
+use Drupal\Tests\UnitTestCase;
+use Symfony\Component\HttpFoundation\Request;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\PathProcessor\FlysystemPathProcessor
+ * @group flysystem
+ */
+class FlysystemPathProcessorTest extends UnitTestCase {
+
+  /**
+   * @covers ::processInbound
+   */
+  public function testCorrectPathsAreProcessed() {
+    $processor = new FlysystemPathProcessor();
+    $this->assertSame('beep', $processor->processInbound('beep', new Request()));
+    $this->assertSame('/_flysystem/scheme', $processor->processInbound('/_flysystem/scheme', new Request()));
+  }
+
+  /**
+   * @covers ::processInbound
+   */
+  public function testImageStylesAreProcessed() {
+    $request = new Request();
+    $processor = new FlysystemPathProcessor();
+    $this->assertSame('/_flysystem/styles/scheme/small', $processor->processInbound('/_flysystem/scheme/styles/scheme/small/image.jpg', $request));
+    $this->assertSame($request->query->get('file'), 'image.jpg');
+    $this->assertSame('/_flysystem/styles/scheme/small', $processor->processInbound('/_flysystem/scheme/styles/scheme/small/dir/image.jpg', $request));
+    $this->assertSame($request->query->get('file'), 'dir/image.jpg');
+  }
+
+  /**
+   * @covers ::processInbound
+   */
+  public function testDownloadPathsAreProcessed() {
+    $request = new Request();
+    $processor = new FlysystemPathProcessor();
+    $this->assertSame('/_flysystem/scheme', $processor->processInbound('/_flysystem/scheme/file.txt', $request));
+    $this->assertSame('file.txt', $request->query->get('file'));
+  }
+
+  /**
+   * @covers ::processInbound
+   */
+  public function testDownloadPathsInSubDirsAreProcessed() {
+    $request = new Request();
+    $processor = new FlysystemPathProcessor();
+    $this->assertSame('/_flysystem/scheme', $processor->processInbound('/_flysystem/scheme/a/b/c/file.txt', $request));
+    $this->assertSame('a/b/c/file.txt', $request->query->get('file'));
+  }
+
+}
diff --git a/tests/src/Unit/PathProcessor/LocalPathProcessorTest.php b/tests/src/Unit/PathProcessor/LocalPathProcessorTest.php
new file mode 100644
index 0000000..25a3b7b
--- /dev/null
+++ b/tests/src/Unit/PathProcessor/LocalPathProcessorTest.php
@@ -0,0 +1,74 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\PathProcessor;
+
+use Drupal\Core\Site\Settings;
+use Drupal\flysystem\PathProcessor\LocalPathProcessor;
+use Drupal\Tests\UnitTestCase;
+use Symfony\Component\HttpFoundation\Request;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\PathProcessor\LocalPathProcessor
+ * @group flysystem
+ */
+class LocalPathProcessorTest extends UnitTestCase {
+
+  /**
+   * Inbound Path processor.
+   *
+   * @var \Drupal\Core\PathProcessor\InboundPathProcessorInterface
+   */
+  protected $processor;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    new Settings(
+      [
+        'flysystem' => [
+          'test_scheme' => [
+            'driver' => 'local',
+            'config' => ['root' => 'sites/default/files/flysystem'],
+          ],
+        ],
+      ]);
+    $this->processor = new LocalPathProcessor('test_scheme');
+  }
+
+  /**
+   * @covers ::processInbound
+   * @covers ::__construct
+   */
+  public function testProcessInboundIgnoresInvalidPaths() {
+    $this->assertSame('beep', $this->processor->processInbound('beep', new Request()));
+  }
+
+  /**
+   * @covers ::processInbound
+   */
+  public function testProcessInboundHandlesImageStyles() {
+    $request = new Request();
+
+    $this->assertSame('/sites/default/files/flysystem/styles/test_scheme/small', $this->processor->processInbound('/sites/default/files/flysystem/styles/test_scheme/small/image.jpg', $request));
+    $this->assertSame($request->query->get('file'), 'image.jpg');
+
+    $this->assertSame('/sites/default/files/flysystem/styles/test_scheme/small', $this->processor->processInbound('/sites/default/files/flysystem/styles/test_scheme/small/dir/image.jpg', $request));
+    $this->assertSame($request->query->get('file'), 'dir/image.jpg');
+  }
+
+  /**
+   * @covers ::processInbound
+   */
+  public function testProcessInboundHandlesSystemDownload() {
+    $request = new Request();
+
+    $this->assertSame('/sites/default/files/flysystem', $this->processor->processInbound('/sites/default/files/flysystem/file.txt', $request));
+    $this->assertSame('file.txt', $request->query->get('file'));
+
+    $this->assertSame('/sites/default/files/flysystem', $this->processor->processInbound('/sites/default/files/flysystem/a/b/c/file.txt', $request));
+    $this->assertSame('a/b/c/file.txt', $request->query->get('file'));
+  }
+
+}
diff --git a/tests/src/Unit/Plugin/FlysystemPluginManagerTest.php b/tests/src/Unit/Plugin/FlysystemPluginManagerTest.php
new file mode 100644
index 0000000..687c275
--- /dev/null
+++ b/tests/src/Unit/Plugin/FlysystemPluginManagerTest.php
@@ -0,0 +1,48 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Plugin;
+
+use Drupal\Component\Datetime\TimeInterface;
+use Drupal\Core\Cache\MemoryBackend;
+use Drupal\Core\Extension\ModuleHandlerInterface;
+use Drupal\flysystem\Plugin\FlysystemPluginManager;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\Plugin\FlysystemPluginManager
+ * @group flysystem
+ */
+class FlysystemPluginManagerTest extends UnitTestCase {
+
+  /**
+   * @covers \Drupal\flysystem\Plugin\FlysystemPluginManager
+   */
+  public function test() {
+    $namespaces = new \ArrayObject();
+    $time = $this->createMock(TimeInterface::class);
+    $cache_backend = new MemoryBackend($time);
+    $module_handle = $this->createMock(ModuleHandlerInterface::class);
+
+    // Cache Backend.
+    $manager = new FlysystemPluginManager($namespaces, $cache_backend, $module_handle);
+    $this->assertSame('missing', $manager->getFallbackPluginId('beep'));
+    $this->assertIsArray($manager->getDefinitions());
+
+    // Test alterDefinitions().
+    $method = new \ReflectionMethod($manager, 'alterDefinitions');
+    $method->setAccessible(TRUE);
+
+    $definitions = [
+      'test1' => ['extensions' => []],
+      'test2' => ['extensions' => ['pdo']],
+      'test3' => ['extensions' => ['missing_extension']],
+    ];
+
+    $method->invokeArgs($manager, [&$definitions]); // phpcs:ignore
+    $this->assertCount(2, $definitions);
+    $this->assertArrayHasKey('test1', $definitions);
+    $this->assertArrayHasKey('test2', $definitions);
+    $this->assertArrayNotHasKey('test3', $definitions);
+  }
+
+}
diff --git a/tests/src/Unit/Plugin/FlysystemUrlTraitTest.php b/tests/src/Unit/Plugin/FlysystemUrlTraitTest.php
new file mode 100644
index 0000000..0a74b8a
--- /dev/null
+++ b/tests/src/Unit/Plugin/FlysystemUrlTraitTest.php
@@ -0,0 +1,51 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Plugin;
+
+use Drupal\Core\DependencyInjection\ContainerBuilder;
+use Drupal\Core\Routing\UrlGenerator;
+use Drupal\flysystem\Plugin\FlysystemUrlTrait;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\Plugin\FlysystemUrlTrait
+ * @group flysystem
+ */
+class FlysystemUrlTraitTest extends UnitTestCase {
+
+  // @codingStandardsIgnoreStart
+  /**
+   * Create an anonymous class for the provided trait.
+   *
+   * @param trait-string $traitName Name of the trait to create a mock for.
+   */
+  public function createMockForTrait(string $traitName) {
+    return eval('return new class { use ' . $traitName . '; };');
+  }
+  // @codingStandardsIgnoreEnd
+
+  /**
+   * @covers ::getExternalUrl
+   * @covers ::getScheme
+   * @covers ::getTarget
+   */
+  public function testGetExternalUrl() {
+    $trait = $this->createMockForTrait(FlysystemUrlTrait::class);
+
+    $url_generator = $this->prophesize(UrlGenerator::class);
+    $url_generator->generateFromRoute(
+      'flysystem.serve',
+      ['scheme' => 'test_scheme', 'filepath' => 'dir/file.txt'],
+      ['absolute' => TRUE],
+      FALSE)
+      ->willReturn('download');
+
+    $container = new ContainerBuilder();
+    $container->set('url_generator', $url_generator->reveal());
+
+    \Drupal::setContainer($container);
+
+    $this->assertSame('download', $trait->getExternalUrl('test_scheme://dir\file.txt'));
+  }
+
+}
diff --git a/tests/src/Unit/Plugin/ImageStyleGenerationTraitTest.php b/tests/src/Unit/Plugin/ImageStyleGenerationTraitTest.php
new file mode 100644
index 0000000..a57f38b
--- /dev/null
+++ b/tests/src/Unit/Plugin/ImageStyleGenerationTraitTest.php
@@ -0,0 +1,98 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Plugin;
+
+use Drupal\Core\DependencyInjection\ContainerBuilder;
+use Drupal\Core\Entity\EntityStorageInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Entity\EntityTypeRepositoryInterface;
+use Drupal\Core\Lock\LockBackendInterface;
+use Drupal\Core\Lock\NullLockBackend;
+use Drupal\flysystem\Plugin\ImageStyleGenerationTrait;
+use Drupal\image\Entity\ImageStyle;
+use Drupal\Tests\UnitTestCase;
+use org\bovigo\vfs\vfsStream;
+use Prophecy\Argument;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\Plugin\ImageStyleGenerationTrait
+ * @group flysystem
+ */
+class ImageStyleGenerationTraitTest extends UnitTestCase {
+
+  // @codingStandardsIgnoreStart
+  /**
+   * Create an anonymous class for the provided trait.
+   *
+   * @param trait-string $traitName Name of the trait to create a mock for.
+   */
+  public function createMockForTrait(string $traitName) {
+    return eval('return new class { use ' . $traitName . '; };');
+  }
+  // @codingStandardsIgnoreStart
+
+  /**
+   * @covers ::generateImageStyle
+   */
+  public function testGenerateImageStyle() {
+    vfsStream::setup('flysystem');
+    touch('vfs://flysystem/foo.jpg');
+    mkdir('vfs://flysystem/styles/pass', 0777, TRUE);
+
+    $container = new ContainerBuilder();
+
+    $image_style = $this->prophesize(ImageStyle::class);
+    $image_style->buildUri('vfs://flysystem/foo.jpg')->willReturn('vfs://flysystem/styles/pass/foo.jpg');
+    $image_style->buildUri('vfs://flysystem/foo.jpg.png')->willReturn('vfs://flysystem/styles/pass/foo.jpg.png');
+    $image_style->id()->willReturn('pass');
+    $image_style->createDerivative('vfs://flysystem/foo.jpg', 'vfs://flysystem/styles/pass/foo.jpg')->willReturn(TRUE);
+    $image_style->createDerivative('vfs://flysystem/foo.jpg', 'vfs://flysystem/styles/pass/foo.jpg.png')->willReturn(TRUE);
+
+    $storage = $this->prophesize(EntityStorageInterface::class);
+    $storage->load('pass')->willReturn($image_style->reveal());
+    $storage->load('fail')->willReturn(FALSE);
+
+    $entity_type_manager = $this->prophesize(EntityTypeManagerInterface::class);
+    $entity_type_repository = $this->prophesize(EntityTypeRepositoryInterface::class);
+    $entity_type_repository->getEntityTypeFromClass(ImageStyle::class)->willReturn('image_style');
+    $entity_type_manager->getStorage('image_style')->willReturn($storage->reveal());
+
+    $container->set('entity_type.repository', $entity_type_repository->reveal());
+    $container->set('entity_type.manager', $entity_type_manager->reveal());
+    $container->set('lock', new NullLockBackend());
+
+    \Drupal::setContainer($container);
+
+    $trait = $this->createMockForTrait(ImageStyleGenerationTrait::class);
+
+    $method = (new \ReflectionMethod($trait, 'generateImageStyle'))->getClosure($trait);
+
+    // Test invalid paths.
+    $this->assertFalse($method('foo/bar'));
+    $this->assertFalse($method('styles/image_style/vfs'));
+
+    // Test invalid image style.
+    $this->assertFalse($method('styles/fail/vfs/flysystem/foo.jpg'));
+
+    // Test existing derivative.
+    touch('vfs://flysystem/styles/pass/foo.jpg');
+    $this->assertTrue($method('styles/pass/vfs/flysystem/foo.jpg'));
+    unlink('vfs://flysystem/styles/pass/foo.jpg');
+
+    // Basic passing.
+    $this->assertTrue($method('styles/pass/vfs/flysystem/foo.jpg'));
+    $this->assertTrue($method('styles/pass/vfs/flysystem/foo.jpg.png'));
+
+    // Test failed lock.
+    $fail_lock = $this->prophesize(LockBackendInterface::class);
+    $fail_lock->acquire(Argument::type('string'))->willReturn(FALSE);
+    $container->set('lock', $fail_lock->reveal());
+    $this->assertFalse($method('styles/pass/vfs/flysystem/foo.jpg'));
+    $container->set('lock', new NullLockBackend());
+
+    // Test missing source.
+    unlink('vfs://flysystem/foo.jpg');
+    $this->assertFalse($method('styles/pass/vfs/flysystem/foo.jpg.png'));
+  }
+
+}
diff --git a/tests/src/Unit/Routing/FlysystemRoutesTest.php b/tests/src/Unit/Routing/FlysystemRoutesTest.php
new file mode 100644
index 0000000..9242aea
--- /dev/null
+++ b/tests/src/Unit/Routing/FlysystemRoutesTest.php
@@ -0,0 +1,165 @@
+<?php
+
+namespace Drupal\Tests\flysystem\Unit\Routing;
+
+use Drupal\Core\DependencyInjection\ContainerBuilder;
+use Drupal\Core\Extension\ModuleHandlerInterface;
+use Drupal\Core\Site\Settings;
+use Drupal\Core\StreamWrapper\LocalStream;
+use Drupal\Core\StreamWrapper\StreamWrapperManagerInterface;
+use Drupal\flysystem\FlysystemFactory;
+use Drupal\flysystem\Routing\FlysystemRoutes;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * @coversDefaultClass \Drupal\flysystem\Routing\FlysystemRoutes
+ * @group flysystem
+ */
+class FlysystemRoutesTest extends UnitTestCase {
+
+  /**
+   * Flysystem Factory.
+   *
+   * @var \Drupal\flysystem\FlysystemFactory
+   */
+  protected $factory;
+
+  /**
+   * Drupal ModuleHandler.
+   *
+   * @var \Drupal\Core\Extension\ModuleHandlerInterface
+   */
+  protected $moduleHandler;
+
+  /**
+   * Flysystem routing for files.
+   *
+   * @var \Drupal\flysystem\Routing\FlysystemRoutes
+   */
+  protected $router;
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setUp(): void {
+    parent::setUp();
+    $container = new ContainerBuilder();
+
+    $stream_wrapper = $this->prophesize(LocalStream::class);
+    $stream_wrapper->getDirectoryPath()->willReturn('sites/default/files');
+
+    $stream_wrapper_manager = $this->prophesize(StreamWrapperManagerInterface::class);
+    $stream_wrapper_manager->getViaScheme('public')->willReturn($stream_wrapper->reveal());
+
+    $this->moduleHandler = $this->prophesize(ModuleHandlerInterface::class);
+
+    $factory = $this->prophesize(FlysystemFactory::class);
+    $factory->getSchemes()->willReturn(['test']);
+
+    $container->set('flysystem_factory', $factory->reveal());
+    $container->set('stream_wrapper_manager', $stream_wrapper_manager->reveal());
+    $container->set('module_handler', $this->moduleHandler->reveal());
+
+    $this->router = FlysystemRoutes::create($container);
+  }
+
+  /**
+   * @covers ::__construct
+   * @covers ::create
+   * @covers ::routes
+   */
+  public function testInvalidSettingsAreSkipped() {
+    new Settings([
+      'flysystem' => [
+        'invalid' => ['driver' => 'local'],
+        'test' => ['driver' => 'local'],
+      ],
+    ]);
+
+    $this->assertSame([], $this->router->routes());
+  }
+
+  /**
+   * @covers ::routes
+   */
+  public function testInvalidDriversAreSkipped() {
+    new Settings(['flysystem' => ['test' => ['driver' => 'ftp']]]);
+
+    $this->assertSame([], $this->router->routes());
+  }
+
+  /**
+   * @covers ::routes
+   */
+  public function testDriversNotPublicAreSkipped() {
+    new Settings(['flysystem' => ['test' => ['driver' => 'local']]]);
+
+    $this->assertSame([], $this->router->routes());
+  }
+
+  /**
+   * @covers ::routes
+   */
+  public function testLocalPathSameAsPublicIsSkipped() {
+    new Settings([
+      'flysystem' => [
+        'test' => [
+          'driver' => 'local',
+          'public' => TRUE,
+          'config' => [
+            'public' => TRUE,
+            'root' => 'sites/default/files',
+          ],
+        ],
+      ],
+    ]);
+
+    $this->assertSame([], $this->router->routes());
+  }
+
+  /**
+   * @covers ::routes
+   */
+  public function testValidRoutesReturned() {
+    new Settings([
+      'flysystem' => [
+        'test' => [
+          'driver' => 'local',
+          'public' => TRUE,
+          'config' => [
+            'public' => TRUE,
+            'root' => 'sites/default/files/flysystem',
+          ],
+        ],
+      ],
+    ]);
+
+    $routes = $this->router->routes();
+    $this->assertCount(1, $routes);
+    $this->assertTrue(isset($routes['flysystem.test.serve']));
+  }
+
+  /**
+   * @covers ::routes
+   */
+  public function testValidRoutesReturnedWithImageModule() {
+    new Settings([
+      'flysystem' => [
+        'test' => [
+          'driver' => 'local',
+          'public' => TRUE,
+          'config' => [
+            'public' => TRUE,
+            'root' => 'sites/default/files/flysystem',
+          ],
+        ],
+      ],
+    ]);
+
+    $this->moduleHandler->moduleExists('image')->willReturn(TRUE);
+    $routes = $this->router->routes();
+    $this->assertCount(5, $routes);
+    $this->assertTrue(isset($routes['flysystem.image_style']));
+  }
+
+}
